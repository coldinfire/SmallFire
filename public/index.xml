<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Small Fire`s Blog on Small Fire`s Blog</title>
    <link>https://coldinfire.github.io/</link>
    <description>Recent content in Small Fire`s Blog on Small Fire`s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 20 Oct 2019 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://coldinfire.github.io/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Books</title>
      <link>https://coldinfire.github.io/books/</link>
      <pubDate>Thu, 15 Jun 2017 23:39:47 +0800</pubDate>
      
      <guid>https://coldinfire.github.io/books/</guid>
      <description>

&lt;h3 id=&#34;开卷有益&#34;&gt;开卷有益&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Number&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;th&gt;State&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;img width=200/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img width=500/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img width=500/&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://book.douban.com/subject/1084336/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;小王子&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://book.douban.com/subject/1023045/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;我们仨&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;孩子你慢些走&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://book.douban.com/subject/1008145/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;围城&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://book.douban.com/subject/5346110/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;穷查理宝典&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;🕐&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://book.douban.com/subject/3533221/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;非暴力沟通&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://book.douban.com/subject/1056295/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;人性的弱点&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;🕐&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://book.douban.com/subject/20427187/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;看见&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://coldinfire.github.io/about/</link>
      <pubDate>Thu, 15 Jun 2017 23:39:47 +0800</pubDate>
      
      <guid>https://coldinfire.github.io/about/</guid>
      <description>&lt;p&gt;这个人很懒，什么都没留下&amp;hellip;&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABAP 科学计数法问题</title>
      <link>https://coldinfire.github.io/2019/ABAP_NumberQAS/</link>
      <pubDate>Sun, 20 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/ABAP_NumberQAS/</guid>
      <description>

&lt;h4 id=&#34;科学计数法转换数字&#34;&gt;科学计数法转换数字&lt;/h4&gt;

&lt;p&gt;​   ABAP 函数 &lt;code&gt;QSS0_FLTP_TO_CHAR_CONVERSION&lt;/code&gt;，能将 SAP 系统内的科学计数法显示的数字转换成一般数字。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;DATA: l_result TYPE qsollwerte,
       l_value TYPE char16.
       
CALL FUNCTION &#39;QSS0_FLTP_TO_CHAR_CONVERSION&#39;
  EXPORTING
    i_number_of_digits  = 2
    i_fltp_value        = l_result
  IMPORTING
    e_char_field        = l_value
           .
  CONDENSE l_value.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;数字千分位的转换处理&#34;&gt;数字千分位的转换处理&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;DATA: p_value type p,
       l_value TYPE char16.

CALL FUNCTION &#39;HRCM_STRING_TO_AMOUNT_CONVERT&#39;
  EXPORTING
    string            = l_value
    decimal_separator  = &#39;.&#39;
  IMPORTING
    betrg                     = p_value
  EXCEPTIONS
    convert_error             = 1
    OTHERS                    = 2
           .
IF sy-subrc = 1.
   CALL FUNCTION &#39;HRCM_STRING_TO_AMOUNT_CONVERT&#39;
     EXPORTING
       string            = l_value
       decimal_separator = &#39;,&#39;
     IMPORTING
       betrg             = p_value
     EXCEPTIONS
       convert_error     = 1
       OTHERS            = 2.
ENDIF.


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;既要有千分位又要把符号提前的情况:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;*&amp;amp;---------------------------------------------------------------------*
*&amp;amp;      Form  NUMTOSTR
*&amp;amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&amp;gt;VALUE      text
*      --&amp;gt;(ZNUM)     text
*      --&amp;gt;VALUE      text
*      --&amp;gt;(ZSTR)     text
*----------------------------------------------------------------------*
FORM  numtostr CHANGING  p_is_result_amount
                         ``p_is_result_amount_h
                         ``p_is_result_total
                         ``p_is_result_total_h.
  ``DATA : zclen TYPE i,
  ``n TYPE i,
  ``zcstr(30) TYPE c,
  ``zcstr2(30) TYPE c,
  ``zctemp(3) TYPE c,
  ``zflag(1) TYPE c VALUE ``&#39;.&#39;``,
  ``zflag2 TYPE i VALUE 0,
  ``zcdec(30) TYPE c, &amp;quot;记录小数部分.
  ``znum(30),
  ``znum_h(30),
  ``ztotal(30),
  ``ztotal_h(30).
  ``&amp;quot;zstr = ``&#39;&#39;``.
  ``znum = is_result-amount.
  ``znum_h = is_result-amount_h.
  ``ztotal = is_result-total.
  ``ztotal_h = is_result-total_h.
  ``CLEAR: is_result-amount,is_result-amount_h,is_result-total,is_result-total_h.
*---------------------------------------------------------------------------------------------*1
  ``IF znum &amp;lt;&amp;gt; 0.
    ``IF znum &amp;lt;= -1000.
      ``zflag2 = 1.
      ``znum = znum * ( -1 ).
    ``ENDIF.
    ``IF znum &amp;gt;= 1000.
      ``zcstr = znum.
* 压缩字符串，去除前面的空格。
      ``CONDENSE zcstr NO-GAPS.
* 分离整数与小数，好单独处理整数。
      ``SPLIT zcstr AT zflag INTO zcstr zcdec.
      ``zclen = ``strlen``( zcstr ).
* 在循环中从右面在每三位的前面加上一个逗号。
      ``WHILE zclen &amp;gt; 3.
        ``n = zclen - 3.
        ``zctemp = zcstr+n(3).
        ``IF NOT zcstr2 IS INITIAL.
          ``CONCATENATE zctemp zcstr2 INTO zcstr2 SEPARATED BY ``&#39;,&#39;``.
        ``ELSE.
          ``zcstr2 = zctemp.
        ``ENDIF.
        ``zclen = zclen - 3.
      ``ENDWHILE.
* 将不剩下的不足三位数加到前面
      ``CONCATENATE zcstr+0(zclen) zcstr2 INTO zcstr2 SEPARATED BY ``&#39;,&#39;``.
      ``IF zflag2 = 1.
        ``CONCATENATE ``&#39;-&#39;` `zcstr2 INTO zcstr2.
      ``ENDIF.
      ``CLEAR zcstr.
* 将处理过的整数与小数连接起来。
      ``IF ``strlen``( zcdec ) &amp;gt; 1.
        ``CONCATENATE zcstr2 zcdec INTO zcstr SEPARATED BY zflag.
      ``ELSE.
        ``CONCATENATE zcdec ``&#39;00&#39;` `INTO zcdec.
        ``CONCATENATE zcstr2 zcdec  INTO zcstr SEPARATED BY zflag.
      ``ENDIF.
* 将值返回
      ``is_result-amount = zcstr.
    ``ELSE.
      ``is_result-amount = znum.
    ``ENDIF.
  ``ENDIF.
  ``CLEAR: zflag2,zcstr,zcdec,zclen,zctemp,zcstr2,n.
ENDFORM
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;计算数学表达式的方法&#34;&gt;计算数学表达式的方法&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;FORM cacule_value  USING    p_wf_formula TYPE string
                            p_source  TYPE string
                            p_js_processor TYPE REF TO cl_java_script
                   CHANGING p_value .
  DATA:molecule TYPE string,
     denominator TYPE string,
     denominator_source TYPE string,
     denominator_value  TYPE rr_szntr,
     l_result TYPE qsollwerte,
     l_value TYPE char16.

  IF p_wf_formula CS &#39;/&#39;.
    CLEAR:molecule,denominator.
    SPLIT p_wf_formula AT &#39;/&#39; INTO molecule denominator.
    CONCATENATE
    &#39;var string = &#39; denominator &#39;;&#39;
    &#39;function Set_String()                          &#39;
    &#39;  { string = eval(string);                     &#39;
    &#39;  }                                            &#39;
    &#39;Set_String();                                  &#39;
    &#39;string;                                        &#39;
      INTO denominator_source SEPARATED BY cl_abap_char_utilities=&amp;gt;cr_lf.
    denominator_value = js_processor-&amp;gt;evaluate( denominator_source ).
    IF denominator_value = 0.
      p_value = 0.
    ELSE.
      CONCATENATE
      &#39;var string = &#39; p_wf_formula &#39;;&#39;
      &#39;function Set_String()                          &#39;
      &#39;  { string = eval(string);                     &#39;
      &#39;  }                                            &#39;
      &#39;Set_String();                                  &#39;
      &#39;string;                                        &#39;
        INTO p_source SEPARATED BY cl_abap_char_utilities=&amp;gt;cr_lf.
      l_result = js_processor-&amp;gt;evaluate( p_source ).
*      p_value = js_processor-&amp;gt;evaluate( p_source ).

      CALL FUNCTION &#39;QSS0_FLTP_TO_CHAR_CONVERSION&#39;
        EXPORTING
          i_number_of_digits             = 2
          i_fltp_value                   = l_result
*         I_VALUE_NOT_INITIAL_FLAG       = &#39;X&#39;
*         I_SCREEN_FIELDLENGTH           = 16
       IMPORTING
         e_char_field                   = l_value
                .
      CONDENSE l_value.

      CALL FUNCTION &#39;HRCM_STRING_TO_AMOUNT_CONVERT&#39;
        EXPORTING
          string                    = l_value
         decimal_separator         = &#39;.&#39;
*         THOUSANDS_SEPARATOR       =
*         WAERS                     = &#39; &#39;
       IMPORTING
         betrg                     = p_value
       EXCEPTIONS
         convert_error             = 1
         OTHERS                    = 2
                .
      IF sy-subrc = 1.
        CALL FUNCTION &#39;HRCM_STRING_TO_AMOUNT_CONVERT&#39;
          EXPORTING
            string            = l_value
            decimal_separator = &#39;,&#39;
          IMPORTING
            betrg             = p_value
          EXCEPTIONS
            convert_error     = 1
            OTHERS            = 2.
      ENDIF.

    ENDIF.
  ELSE.
    CONCATENATE
      &#39;var string = &#39; p_wf_formula &#39;;&#39;
      &#39;function Set_String()                          &#39;
      &#39;  { string = eval(string);                     &#39;
      &#39;  }                                            &#39;
      &#39;Set_String();                                  &#39;
      &#39;string;                                        &#39;
        INTO p_source SEPARATED BY cl_abap_char_utilities=&amp;gt;cr_lf.
    p_value = js_processor-&amp;gt;evaluate( p_source ).
  ENDIF.
ENDFORM.                    &amp;quot; CACULE_VALUE
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>SO10创建标准文本</title>
      <link>https://coldinfire.github.io/2019/ABAP_SO10/</link>
      <pubDate>Fri, 18 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/ABAP_SO10/</guid>
      <description>&lt;p&gt;通过 Tcode SO10 可以创建标准文本：&lt;/p&gt;

&lt;p&gt;​   &lt;img src=&#34;https://coldinfire.github.io/images/ABAP/SO10.png&#34; alt=&#34;SO10&#34; /&gt;&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;p&gt;通过占位符替换长文本：&lt;/p&gt;

&lt;p&gt;​   &lt;img src=&#34;https://coldinfire.github.io/images/ABAP/SO10_1.png&#34; alt=&#34;SO10 Symbol&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;DATA lv_name TYPE thead-tdname.
DATA lv_langu LIKE sy-langu VALUE &#39;EN&#39;.
DATA lt_line TYPE STANDARD TABLE OF tline WITH HEADER LINE.
DATA lv_count TYPE i.
lv_name = &#39;Z_TEST&#39;.
&amp;quot;read text from SO10
  CALL FUNCTION &#39;READ_TEXT&#39;
  EXPORTING
    client                  = sy-mandt
    id                      = &#39;ST&#39;
    language                = lv_langu
    name                    = lv_name
    object                  = &#39;TEXT&#39;
  TABLES
    lines                   = lt_line
  EXCEPTIONS
    id                      = 1
    language                = 2
    name                    = 3
    not_found               = 4
    object                  = 5
    reference_check         = 6
    wrong_access_to_archive = 7
    OTHERS                  = 8.
  IF sy-subrc EQ 0 .
&amp;quot;initialize the text symbols
  CALL FUNCTION &#39;INIT_TEXTSYMBOL&#39;.
&amp;quot;set dynamic text symbol
  CALL FUNCTION &#39;SET_TEXTSYMBOL&#39;
    EXPORTING
      name    = &#39;&amp;amp;l_aa&amp;amp;&#39;
      value   = &#39;输入需要替换的内容&#39;
      replace = &#39;X&#39;.
  DESCRIBE TABLE lt_line LINES lv_count.
&amp;quot;replace all text symbol in your long text
  CALL FUNCTION &#39;REPLACE_TEXTSYMBOL&#39;
    EXPORTING
      endline   = lv_count
      startline = 1
    TABLES
      lines     = lt_line.
ENDIF.
LOOP AT lt_line.
  WRITE:/ lt_line-tdline.
ENDLOOP.
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>IDoc操作</title>
      <link>https://coldinfire.github.io/2019/ABAP_IDoc/</link>
      <pubDate>Sun, 22 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/ABAP_IDoc/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://www.baidusap.com/abap/ale_edi_idoc/782&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;idoc&#34;&gt;IDoc&lt;/h3&gt;

&lt;h4 id=&#34;1-idoc简介&#34;&gt;1.IDoc简介&lt;/h4&gt;

&lt;p&gt;IDoc:是基于文档，用作异步传输数据的载体，类似于XML;使用功能场景：假设 1040 和 1020 是同一个集团下两个不同子公司的 SAP 系统，1040 需要将其采购订单信息及时发送给 1020，可以使用IDoc传输。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;IDOC 的整个配置，涉及了远程连接、ALE、消息控制、tRFC 等技术的集成&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;IDoc支持异步、同步、可以收集一定数量的包后发送，最重要的是，IDOC有完整的监控系统和错误处理机制。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;IDoc支持SAP系统集团之间，SAP-CRM/SRM/PI等之间，SAP-第三方系统之间的集成&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过系统预定义IDOC类型，可以自动收集IDoc，挂JOB定时发送，也可以配置消息控制。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;数据段是IDoc结构组件，是IDoc构成的单元;有Segment type：数据段类型与Segment.definition：数据段定义&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;:Segment type名称与SAP版本无关，以&amp;rdquo;E1/Z1&amp;rdquo;开头&lt;/li&gt;
&lt;li&gt;:Segment definition名称与SAP版本有关，外部系统确定数据段版本的关键；以&amp;rdquo;E2/Z2&amp;rdquo;开头+版本号
访问IDoc中具体某个字段时，需要通过Segment type。&lt;/li&gt;
&lt;li&gt;IDoc包含多个Segment,每个Segment内包含有多个字段&lt;/li&gt;
&lt;li&gt;Segment类似于XML的节点以及节点属性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;IDoc特性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IDoc 包含有三种类型的记录：一条控制记录，一个或多个数据记录，一个或多个状态记录&lt;/li&gt;
&lt;li&gt;IDoc type：IDoc 结构，不同的 SAP 业务对象对应不同的 IDoc 类型（一个或多个）。&lt;/li&gt;
&lt;li&gt;IDoc 类型中定义了数据段（Segment）以及数据段的层级和次序。定义节点间的相互逻辑关系。&lt;/li&gt;
&lt;li&gt;标准 SAP 系统提供的 IDoc 类型称为基本类型（Basic type），该类型可以通过 IDoc 扩展（Extention）进行调整，即在 SAP IDoc 类型结构的基础上增加新的数据段或者在数据段中增加新字段。&lt;/li&gt;
&lt;li&gt;IDoc Basic Type: 是承载数据的一个类型，可以认为是一个数据结构。Basic Type 由 Segment 构成，有点类似于 XML 的格式。每个 Segment 指定了一些字段，在这些字段里面可以输入一些限定的数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;2-包含组件&#34;&gt;2.包含组件&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ALE（Application Link and Enabling）是 SAP 专门为 SAP 与 SAP 之间所设计的整合中间件，多用于同一个企业中不同 SAP 系统之间的数据交换，通过 IDoc 格式的数据创建分布式系统 。分布式数据交换提供了可靠安全的通讯机制。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;EDI（Electronic Document Interchange，电子数据交换）其实就是采用标准格式的电子数据，用于在通讯网络中在业务伙伴间交换业务文档所用。按相同的排列放置数据到一个数据文档中，并按相同的排列解析此文档以得到所需的内容。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;IDoc（Intermediate Document，中转文档）是 SAP 提供的系统整合专用的数据 / 消息格式，它通过 ALE 方式来进行交换，IDoc 提供了 EDI 的支持，可以认为 IDoc 是 EDI 的一个实现。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;3-idoc发送接收流程&#34;&gt;3.IDoc发送接收流程&lt;/h4&gt;

&lt;p&gt;外发过程（Outbound process：OP）:处理数据集并发出消息&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;应用文档被创建&lt;/li&gt;
&lt;li&gt;IDoc 生成&lt;/li&gt;
&lt;li&gt;IDoc 从 SAP 传送到操作系统&lt;/li&gt;
&lt;li&gt;IDoc 被转换成 EDI 标准格式&lt;/li&gt;
&lt;li&gt;EDI 文件被传送到业务伙伴处（所以业务伙伴可以没有 SAP，因为 EDI 是个标准）&lt;/li&gt;
&lt;li&gt;EDI 子系统将传送的状态回报给 SAP&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接收过程（Inbound process：IP）：接收消息并处理&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;EDI 文档被接收&lt;/li&gt;
&lt;li&gt;EDI 文档被转换成 IDoc&lt;/li&gt;
&lt;li&gt;IDoc 传送到 SAP 层&lt;/li&gt;
&lt;li&gt;应用文档在 SAP 中创建&lt;/li&gt;
&lt;li&gt;应用文档现在可供浏览了&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;4-idoc流程步骤及tcode&#34;&gt;4.IDoc流程步骤及TCode&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;    外发配置(OP)   					   接收配置(IP)
WE31:创建IDOC所需要的字段                        WE31:开发Segment Type
WE30:开发IDOC基本类型和扩展，把Segment分配给IDOC   WE81：开发Message Type
WE81：开发Message Type
WE82:Message Type和IDoc Type绑定                WE82:Message Type和IDoc Type绑定
BD64:添加视图模型，添加消息类型配置伙伴参数    BD64:增加消息类型
WE20:配置发送系统出站信息                     WE20:配置接收系统入站信息
SE38:编写发送程序                            SE37:编写接收接口
WE14:若为黄灯，手动发送                       WE57:分配IDOC类型给处理函数
BD51:配置进站函数模块属性
WE42:配置进站处理代码
WE02:IDOC发送信息检查
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;5-process-code处理代码设定&#34;&gt;5.Process Code处理代码设定&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;WE41,WE42,WE40,WE64&lt;/li&gt;
&lt;li&gt;处理代码用于确定数据写入 IDoc 或从 IDoc 读取的处理方式，处理代码对应具体的功能模块或者工作流。入站和出站处理的伙伴参数中都可以指定处理代码&lt;/li&gt;
&lt;li&gt;Outbound Process Code: 出站的处理代码。其实就是具体的一个操作流程。在得到了 Output Type，确定了 IDoc Basic Type 以后，需要从 Output Type 提供的所有数据里面，按 IDoc Basic Type 组合出 IDoc 来，即给 IDoc Basic Type 赋值。&lt;/li&gt;
&lt;li&gt;Inbound Process Code: 进站的处理代码。就是接收到一个 IDoc 以后，根据 Message Type 来确定要怎么处理这个 IDoc。&lt;/li&gt;
&lt;li&gt;程序的思路就是，把每个 IDOC 结点按字符串形式逐个添加，而字符串的添加次序自然也体现了 IDOC 结点间的逻辑关系。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;6-端口-port-we21&#34;&gt;6.端口（Port）：WE21&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;端口用于外发流程，它判断 EDI 子系统程序名称、IDoc 文件传送到操作系统的目录，IDoc 文件名和 RFC 目的地&lt;/li&gt;
&lt;li&gt;端口，指定这个 IDoc 的接收方，可以是任何其他系统，也可以发到当前的 SAP 当前的 Client。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;7-rfc目的地-sm59&#34;&gt;7.RFC目的地：SM59&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;用于定义到远程系统通讯连接的特性以及需要调用何种功能&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;8-partnr-profile-we20&#34;&gt;8.Partnr Profile：WE20&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Partnr:对口的合作伙伴&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Partner Profile：是Partner的一些参数，分为OP和IP.它们是为了让系统知道怎么去处理 Outbound/Inbound 的事件.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Partner Profile 指定在外发过程中所用的各类组件（业务伙伴号、IDoc 类型、信息类型、端口、处理码等），通讯方式（异步或同步）以及当错误时通知何人&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;9-message-type&#34;&gt;9.Message Type&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;用于消息类型的处理，就是告诉 Inbound 一方，我这个 IDoc 是用来做什么的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;WE81， 创建Message type&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;WE82，连接 Message type和 IDOC type&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;10-idoc类型定义的相关函数&#34;&gt;10.IDoc类型定义的相关函数&lt;/h4&gt;

&lt;p&gt;函数组 EDIM 中的 SAP 内部功能模块用于操作 IDoc 基本类型和扩展：OBJECT代指所操作的队象，既IDOCTYPE或EXTTYPE.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;[OBJECT]_CREATE&lt;/li&gt;
&lt;li&gt;[OBJECT]_UPDATE&lt;/li&gt;
&lt;li&gt;[OBJECT]_READ&lt;/li&gt;
&lt;li&gt;[OBJECT]_DELETE&lt;/li&gt;
&lt;li&gt;[OBJECT]_CLOSE&lt;/li&gt;
&lt;li&gt;[OBJECT]_UNCLOSE&lt;/li&gt;
&lt;li&gt;[OBJECT]_EXISTENCE_CHECK&lt;/li&gt;
&lt;li&gt;[OBJECT]_INTEGRITY_CHECK&lt;/li&gt;
&lt;li&gt;[OBJECT]_TRANSPORT&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;函数组EDIJ中的SAP内部功能模块用于操作IDoc数据段&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SEGMENT_CREATE&lt;/li&gt;
&lt;li&gt;SEGMENT_MODIFY&lt;/li&gt;
&lt;li&gt;SEGMENT_DELETE&lt;/li&gt;
&lt;li&gt;SEGMENT_INITION_DELETE&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;11-idoc常用tcode&#34;&gt;11.IDoc常用TCode&lt;/h4&gt;

&lt;p&gt;SAP 提供了一个事务码列出的基本上所有的 IDoc 相关的事务码&lt;code&gt;WEDI&lt;/code&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;/BD87&lt;/th&gt;
&lt;th&gt;/WE18&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;/SUIM&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/SM58&lt;/td&gt;
&lt;td&gt;/WE19&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;/GS03&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/WE09&lt;/td&gt;
&lt;td&gt;/WE20&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;/BDLS&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>ABAP字符串处理</title>
      <link>https://coldinfire.github.io/2019/ABAP_String/</link>
      <pubDate>Wed, 18 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/ABAP_String/</guid>
      <description>&lt;p&gt;​       字符串的处理在程序中的使用十分常见，在这里结合自己日常的使用对ABAP的字符串常用操作进行总结，以便后续使用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.获取字符串长度&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;var1  = strlen(str);&lt;/code&gt;将str作为字符数据处理，计算出其字符长度&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;  DATA: l_len type i,
        str1(20) VALUE &#39;1234&#39;.
    l_len = strlen(str1).
  WRITE: / len.  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.拼接字符串&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CONCATENATE &amp;lt;str1&amp;gt; ... &amp;lt;strn&amp;gt; into &amp;lt;var&amp;gt; [SEPARATED BY &amp;lt;s&amp;gt;][RESPECTING BLANKS]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将多个字符串拼接到指定的变量Var中，注意Var的长度&lt;/li&gt;
&lt;li&gt;C,D,N,T类型的前导空格会保留，尾部空格会去掉，对String类型的所有空格都会保留&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[SEPARATED BY &amp;lt;s&amp;gt;]&lt;/code&gt;:根据该间隔符号(S)进行拼接(SPACE)&lt;/li&gt;
&lt;li&gt;respecting：针对C,D,N,T数据，表示尾部空格会保留&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3.压缩字符串&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CONDENCE &amp;lt;str&amp;gt; [NO-GAPS]&lt;/code&gt;:去除字段str中的前后空格，并将字段中多个空格使用一个空格替换；如果加上NO-GAPS则去除所有空格。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;4.截取字符串&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;subtext = str+0(4)：从最左边取出4个字符&lt;/li&gt;
&lt;li&gt;subtext = str+2(4)：从第2个字符开始取出4个字符&lt;/li&gt;
&lt;li&gt;str+0(1) = &amp;lsquo;X&amp;rsquo;：变更指定位置的值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;5.查找字符串&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SEARCH &amp;lt;var&amp;gt; FOR &amp;lt;str&amp;gt; &amp;lt;options&amp;gt;.&lt;/code&gt;:在var中搜索子字符串，成功SY-SUBRC=0&lt;/li&gt;
&lt;li&gt;str:可以使用正则表达式，也可以使用普通字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;6.替换字符串&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;REPLACE &amp;lt;str1&amp;gt; WITH &amp;lt;str2&amp;gt; INTO &amp;lt;var&amp;gt; [LENGTH &amp;lt;l&amp;gt;].&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将str1在var中的字段替换为str2&lt;/li&gt;
&lt;li&gt;如果指定长度，则只将str1中指定长度的字符替换为str2中的内容&lt;/li&gt;
&lt;li&gt;如果替换后内容总长度超过var定义的长度，会出现截断现象&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;7.移动字符串内容&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;SHIFT &amp;lt;var&amp;gt; [BY &amp;lt;n&amp;gt; PLACES] [&amp;lt;mode&amp;gt;].&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将var移动n个位置，&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;MODE:LEFT(默认),RIGHT,CIRCULAR&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;SHIFT &amp;lt;var&amp;gt; LEFT DELETING LEADING &amp;lt;str&amp;gt;.&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;SHIFT &amp;lt;var&amp;gt; RIGHT DELETING TRAILING &amp;lt;str&amp;gt;.&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果左边第一个字符串或则右边第一个字符串出现在str中，将var移动相应的位置&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;8.比较字符串&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;判断是否包含特定值&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IF field CN &amp;lsquo;0123456789&amp;rsquo;.&lt;/li&gt;
&lt;li&gt;IF field CN &amp;lsquo;ABCDEFG*&amp;rsquo;&lt;/li&gt;
&lt;li&gt;IF field CN &amp;lsquo;abcdefg*&amp;rsquo;&lt;/li&gt;
&lt;li&gt;IF field CN &amp;lsquo;/&amp;rsquo; &amp;hellip;..&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;CN：Contains Not Only (包含，不仅包含)&lt;/strong&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;&lt;strong&gt;CO：Contains Only（仅包含）&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;CS：Contains String (包含字符串)&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;NS：Contains No String (不包含字符串)&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;NP：No Pattern （不包含记号）&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;NA：Contains Not Only(不包含任何)&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;CA：Contains Any（包含任何）&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;CP：Covers Pattern (包含记号)&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;9.&lt;strong&gt;拆分字符串&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;​   SPLIT dobj AT sep INTO {res1 res2&amp;hellip;&amp;hellip;resn}. ：将字符串的值分配给具体变量&lt;/p&gt;

&lt;p&gt;​   SPLIT s_source AT sep INTO TABLE itab：将字符串的值分配给一内表。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10.大小写转换：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   TRANSLATE c TO UPPER|LOWER CASE.：将字符串转换为大|小写&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;11.字符前拼接空格&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   在Grid ALV上也显示空格：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;IF &amp;lt;fw_output&amp;gt;-name2+0(1) eq space AND &amp;lt;fw_output&amp;gt;-name2 IS NOT INITIAL.
  h_white = cl_abap_conv_in_ce=&amp;gt;uccpi( 160 ).
  REPLACE ALL OCCURRENCES OF REGEX &#39;\s&#39; IN &amp;lt;fw_output&amp;gt;-name2 WITH h_white.
ENDIF.
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>生产订单标准BAPI</title>
      <link>https://coldinfire.github.io/2019/SAP_PO_BAPI/</link>
      <pubDate>Wed, 28 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/SAP_PO_BAPI/</guid>
      <description>

&lt;h3 id=&#34;创建po&#34;&gt;创建PO&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;*&amp;amp;---------------------------------------------------------------------*
*&amp;amp;      Form  FRM_ORDER_CREATE
*&amp;amp;---------------------------------------------------------------------*
*----------------------------------------------------------------------*
&amp;quot;--&amp;gt;  p1        text
&amp;quot;&amp;lt;--  p2        text
*----------------------------------------------------------------------*
  FORM frm_order_create .
  DATA: ls_upload LIKE LINE OF gt_upload,
        ls_style  TYPE lvc_s_styl,
        lv_index  LIKE sy-tabix.
  DATA: ls_order  TYPE bapi_pp_order_create,
        ls_return TYPE bapiret2,
        lv_ordnum TYPE bapi_order_key-order_number,
        lv_ordtyp TYPE bapi_order_copy-order_type.
  LOOP AT gt_upload INTO ls_upload WHERE ztype EQ space AND box EQ &#39;X&#39;.
    lv_index = sy-tabix.
    CLEAR: ls_order, ls_return, lv_ordnum, lv_ordtyp, ls_style.
    IF ls_upload-externind EQ &#39;X&#39;.
      ls_order-order_number = ls_upload-aufnr.
    ENDIF.
    ls_order-material = ls_upload-plnbez.
    ls_order-plant = ls_upload-dwerk.
    ls_order-planning_plant = ls_upload-dwerk.
    ls_order-order_type = ls_upload-dauat.
    ls_order-quantity = ls_upload-gamng.
    ls_order-quantity_uom = ls_upload-gmein.
    ls_order-basic_start_date = ls_upload-gstps.
    ls_order-basic_start_time = ls_upload-gsuzs.
    ls_order-basic_end_date = ls_upload-gltps.
    ls_order-basic_end_time  = ls_upload-gluzs.
    ls_order-unloading_point = ls_upload-ablad.
    ls_order-sequence_number = ls_upload-cy_seqnr.
    IF ls_upload-verid NE space.
      ls_order-prod_version = ls_upload-verid.
    ENDIF.
    IF ls_upload-lgort NE space.
      ls_order-storage_location = ls_upload-lgort.
    ENDIF.
    CALL FUNCTION &#39;BAPI_PRODORD_CREATE&#39;
      EXPORTING
        orderdata    = ls_order
      IMPORTING
        return       = ls_return
        order_number = lv_ordnum
        order_type   = lv_ordtyp.
    IF lv_ordnum NE space.
      CALL FUNCTION &#39;BAPI_TRANSACTION_COMMIT&#39;
        EXPORTING
          wait = &#39;X&#39;.
      CLEAR: ls_upload-fstyle, ls_upload-fstyle[].
      ls_style-style = cl_gui_alv_grid=&amp;gt;mc_style_disabled.
      INSERT ls_style INTO TABLE ls_upload-fstyle.
      ls_upload-aufnr = lv_ordnum.
      ls_upload-ztype = &#39;S&#39;.
      ls_upload-message = &#39;Update successfully&#39;.
    ELSE.
      ls_upload-ztype = ls_return-type.
      CALL FUNCTION &#39;BAPI_TRANSACTION_ROLLBACK&#39;.
    ENDIF.
    IF ls_return-type NE space.
      APPEND ls_return TO ls_upload-retmsg.
    ENDIF.
    IF ls_upload-ztype = &#39;E&#39; .
      ls_upload-zcol = &#39;C610&#39; .
    ENDIF .
    MODIFY gt_upload FROM ls_upload INDEX lv_index.
  ENDLOOP.
  ENDFORM.                    &amp;quot; FRM_ORDER_CREATE
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>SAP Product Order status</title>
      <link>https://coldinfire.github.io/2019/SAP_PO/</link>
      <pubDate>Sun, 25 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/SAP_PO/</guid>
      <description>

&lt;h3 id=&#34;sap生产订单状态&#34;&gt;SAP生产订单状态&lt;/h3&gt;

&lt;h4 id=&#34;sap-系统的常见订单状态如下&#34;&gt;&lt;strong&gt;SAP 系统的常见订单状态如下：&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CRTD (创建)：&lt;/strong&gt;标识生产订单刚刚创建，此时禁止做后续发料和报工确认等操作；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PREL (部分下达)：&lt;/strong&gt;当生产订单部分下达时，如仅下达部分工序时出现此状态；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;REL    (已下达)：&lt;/strong&gt;当生产任务已经明确可下发生产时，将生产订单转换为已下达状态，这个状态后可以继续后续业务操作，如打印订单、发料、报完工等操作；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MANC (未检查物料可用性)：&lt;/strong&gt;生产订单未进行零部件物料的可用性检查；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SETC (结算规则维护)：&lt;/strong&gt;生产订单已维护结算规则；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MSPT (物料短缺)：&lt;/strong&gt;生产订单的零部件物料在进行可用性检查后发现存在短缺；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MACM (已承诺的物料)：&lt;/strong&gt;生产订单的零部件物料在进行可用性检查后确认完全可用；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GMPS (已过帐的货物移动)：&lt;/strong&gt;生产订单已经进行过发料；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PCNF (部分确认)：&lt;/strong&gt;生产订单只进行了部分完工确认，比如说订单需求 10 个，只进行了 5 个生产，或者订单有 2 道工序，只完成了第一道工序；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CNF (已确认) ：&lt;/strong&gt;生产订单已全部完工确认；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PDLV (部分交货)：&lt;/strong&gt;生产订单只有部分产品入库；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DLV (交货) ：&lt;/strong&gt;生产订单已经完全交货入库，这意味着生产订单业务全部完成。CO 看到 DLV 状态或 TECO 状态时将对订单进行完工结算。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;VCAL (差异计算) ：&lt;/strong&gt;生产订单进行过差异运算；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TECO (技术完成) ：&lt;/strong&gt;在生产过程中，会出现订单未完成但是不再继续生产的情况，这时就可以打上技术完结标识，此时订单对零部件的需求同时删除。在很多项目中，为了简便处理，会对所有完成的订单进行技术完结处理 (注：不再继续生产也是一种完成)。CO 看到 DLV 状态或 TECO 状态时将对订单进行完工结算；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RESA (进行结果分析)：&lt;/strong&gt;生产订单进行过结算；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CLSD (关闭)：&lt;/strong&gt;生产订单做账务关闭，不允许对订单发生任何过账，通常情况下，财务月末对订单进行结算后，如果确认不会再有追加发料等业务发生，则应该将订单进行关闭；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DLID (删除) ：&lt;/strong&gt;对生产订单做删除标识，数据仍然存在数据库中，状态可恢复。如果想彻底删除，需对订单进行归档处理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;状态相关表&#34;&gt;状态相关表&lt;/h4&gt;

&lt;p&gt;​   根据工单可以去&lt;strong&gt;AUFK&lt;/strong&gt;表中找到工单对应的Object Number(OBJNR).状态表为：&lt;strong&gt;JEST,&lt;/strong&gt; 字段 OBJNR 为 OR + 订单号，STAT 即为订单状态。但是 STAT 的都是 I 打头的状态，通过 &lt;strong&gt;CO03&lt;/strong&gt; 看生产订单状态都是英文简短字段标识。两者间的关系保存在表&lt;strong&gt;TJ02&lt;/strong&gt;中，&lt;strong&gt;TJ02T&lt;/strong&gt;：系统状态文本表（一般文本表都是标准表后加T）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/Resource/AUFK.png&#34; alt=&#34;AUFK&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/Resource/JEST.png&#34; alt=&#34;JEST&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/Resource/TJ02.png&#34; alt=&#34;TJ02&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/Resource/TJ02T.png&#34; alt=&#34;TJ02T&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;函数使用&#34;&gt;函数使用&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;STATUS_READ：获取输入工单的状态&lt;/li&gt;
&lt;li&gt;STATUS_CHECK：检查生产订单状态，看是否有某种状态&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;状态判断&#34;&gt;状态判断&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;通过JEST表中的状态判断读取,需要根据AUFNR在表AUFK中获取OBJNR字段&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;  DATA:jest type standard table jest.
  SELECT SINGLE * FROM aufk WHERE aufnr = it_table-aufnr. &amp;quot;
  &amp;quot;判定工单状态
  &amp;quot; 判定工单是否 RELASE
  CLEAR: jest.
  SELECT SINGLE * FROM jest
  WHERE objnr = aufk-objnr
  AND ( stat = &#39;I0002&#39; OR &amp;quot; RELEASE
  stat = &#39;I0042&#39;) &amp;quot; Partial RELEASE
  AND inact = space.
  IF sy-subrc &amp;lt;&amp;gt; 0.
  CONTINUE.
  ENDIF.
  
  &amp;quot; 判定工单状态
  CLEAR: jest.
  SELECT SINGLE * FROM jest
  WHERE objnr = aufk-objnr
  AND ( stat = &#39;I0045&#39; OR &amp;quot; TECO
  stat = &#39;I0013&#39; OR &amp;quot; DELETE
  stat = &#39;I0076&#39; OR &amp;quot; DELETE FLAG
  stat = &#39;I0046&#39; OR &amp;quot; CLSD
  stat = &#39;I0012 &#39;) &amp;quot;DLV
  AND inact = space.
  IF sy-subrc = 0.
  CONTINUE.
  ENDIF.
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ABAP混合算术运算</title>
      <link>https://coldinfire.github.io/2019/ABAP_MixedCalculate/</link>
      <pubDate>Mon, 12 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/ABAP_MixedCalculate/</guid>
      <description>

&lt;h3 id=&#34;使用&#34;&gt;使用&lt;/h3&gt;

&lt;p&gt;​   在ABAP程序中将数值与表达式分别存放，通过表达式计算对应的结果。&lt;/p&gt;

&lt;h4 id=&#34;一-调用bapi-eval-formula&#34;&gt;一、调用BAPI：EVAL_FORMULA&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;TYPES:BEGIN OF TY_VAL,
      OPERAND TYPE C,
      VALUE TYPE STRING,
      END OF TY_VAL.
TYPES:BEGIN OF TY_FRM,
      NO TYPE I,
      FORMULA TYPE CHAR50,
      END OF TY_FRM.
DATA:IT_VAL TYPE TABLE OF TY_VAL,
     WA_VAL TYPE TY_VAL.
DATA:IT_FORMULA TYPE TABLE OF TY_FRM,
     WA_FRM TYPE TY_FRM.
DATA:WF_STRING TYPE CHAR255,
     WF_LEN TYPE I,
     WF_FORMULA TYPE CHAR50.
DATA: WF_RETCODE      LIKE SY-SUBRC,
      WF_FUNCNAME(30) TYPE C,
      WF_MESSAGE(70)  TYPE C,
      WF_POS          TYPE I,
      WF_C            TYPE P LENGTH 15 DECIMALS 2.
      
WA_VAL-OPERAND = &#39;A&#39;.
WA_VAL-VALUE = &#39;1&#39;.
APPEND WA_VAL TO IT_VAL.
WA_VAL-OPERAND = &#39;B&#39;.
WA_VAL-VALUE = &#39;2&#39;.
APPEND WA_VAL TO IT_VAL.
WA_VAL-OPERAND = &#39;C&#39;.
WA_VAL-VALUE = &#39;3&#39;.
APPEND WA_VAL TO IT_VAL.
WA_FRM-NO = 1.
WA_FRM-FORMULA = &#39;A*B+C&#39;.
APPEND WA_FRM TO IT_FORMULA.
WA_FRM-NO = 2.
WA_FRM-FORMULA = &#39;C*(A-B)&#39;.
APPEND WA_FRM TO IT_FORMULA.
LOOP AT IT_FORMULA INTO WA_FRM.
  WF_STRING = WA_FRM-FORMULA.
  WF_FORMULA = WA_FRM-FORMULA.
  REPLACE ALL OCCURRENCES OF REGEX &#39;[^[:alpha:]]&#39; IN WF_STRING WITH ` `.
  CONDENSE WF_STRING NO-GAPS.
  WF_LEN = STRLEN( WF_STRING ).
  DO WF_LEN TIMES.
    SY-INDEX = SY-INDEX - 1.
    READ TABLE IT_VAL INTO WA_VAL WITH KEY OPERAND = WF_STRING+SY-INDEX(1).
    IF SY-SUBRC = 0.
      REPLACE ALL OCCURRENCES OF WF_STRING+SY-INDEX(1)
                              IN WF_FORMULA
                              WITH WA_VAL-VALUE.
    ENDIF.
  ENDDO.
  CALL FUNCTION &#39;CHECK_FORMULA&#39;
    EXPORTING
      FORMULA  = WF_FORMULA
    IMPORTING
      SUBRC    = WF_RETCODE
      FUNCNAME = WF_FUNCNAME
      MESSAGE  = WF_MESSAGE
      POS      = WF_POS.
  IF WF_RETCODE IS INITIAL.
    CALL FUNCTION &#39;EVAL_FORMULA&#39;
      EXPORTING
        FORMULA = WF_FORMULA
      IMPORTING
        VALUE   = WF_C
      EXCEPTIONS
        OTHERS  = 1.
    IF SY-SUBRC = 0.
      WRITE: / WA_FRM-FORMULA,&#39;-&#39;, WF_C.
    ELSE.
      WRITE: / &#39;Error&#39;..
    ENDIF.
  ELSE.
    WRITE: / WF_FUNCNAME, WF_MESSAGE, WF_POS.
  ENDIF.
ENDLOOP.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;替换表达式的运算单位&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;REPLACE ALL OCCURRENCES OF REGEX &#39;[^[:alnum:]]&#39; IN WF_STRING WITH ‘ ’&lt;/code&gt; .&lt;/li&gt;
&lt;li&gt;&lt;code&gt;REPLACE ALL OCCURRENCES OF REGEX &#39;[^[:alpha:]]&#39; IN WF_STRING WITH ‘ ’&lt;/code&gt; .&lt;/li&gt;
&lt;li&gt;``：两个表示空格&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;将字符串切分保存到内表&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SPLIT  WF_STRING  AT SPACE INTO TABLE table_name.&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;二-通过直接调用表达式完成计算&#34;&gt;二、通过直接调用表达式完成计算&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;DATA: MESSAGE TYPE STRING,
      SOURCE TYPE STRING,
      RETURN_VALUE TYPE P LENGTH 15 DECIMALS 2,
      TXT_VAR1 TYPE CHAR40,
      TXT_VAR2 TYPE CHAR40,
      TXT_VAR3 TYPE CHAR40 VALUE &#39;987979.234-&#39;.

CALL FUNCTION &#39;CLOI_PUT_SIGN_IN_FRONT&#39;
  CHANGING
    VALUE  = TXT_VAR3.

MESSAGE = &#39;(-351422999.55+-59211228.95+-1297670.94+-3135583.53+-35337844.40)*100/(613848716.07+0.00+-1552672.73)&#39;.

DATA: JS_PROCESSOR TYPE REF TO CL_JAVA_SCRIPT.
  JS_PROCESSOR = CL_JAVA_SCRIPT=&amp;gt;CREATE( ).
    CONCATENATE
      &#39;var string = &#39; MESSAGE &#39;;&#39;
      &#39;function Set_String()                          &#39;
      &#39;  { string = eval(string);                     &#39;
      &#39;  }                                            &#39;
      &#39;Set_String();                                  &#39;
      &#39;string;                                        &#39;
    INTO SOURCE SEPARATED BY
    CL_ABAP_CHAR_UTILITIES=&amp;gt;CR_LF.
RETURN_VALUE = JS_PROCESSOR-&amp;gt;EVALUATE( SOURCE ).
WRITE: RETURN_VALUE.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;实际使用&#34;&gt;实际使用&lt;/h4&gt;

&lt;p&gt;​   可以将以上两种方法进行结合，计算出表达式的结果。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Search</title>
      <link>https://coldinfire.github.io/search/</link>
      <pubDate>Thu, 08 Aug 2019 15:05:27 +0800</pubDate>
      
      <guid>https://coldinfire.github.io/search/</guid>
      <description></description>
    </item>
    
    <item>
      <title>递归遍历成本中心组</title>
      <link>https://coldinfire.github.io/2019/ABAP_RecursiveCostCenter/</link>
      <pubDate>Thu, 01 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/ABAP_RecursiveCostCenter/</guid>
      <description>

&lt;h4 id=&#34;成本中心组下嵌套成本中心组&#34;&gt;成本中心组下嵌套成本中心组&lt;/h4&gt;

&lt;p&gt;​   成本中心后台数据表是 CSKS，描述表是 CSKT。在表 CSKS 中，主键是 MANDT（客户端）、KOKRS（控制范围）、KOSTL（成本中心）、DATBI（有效截至日期），在一个控制范围下的某个成本中心，会因为时间段的不同，会在表 CSKS 和 CSKT 存储多条记录。&lt;/p&gt;

&lt;p&gt;​   &lt;img src=&#34;https://coldinfire.github.io/images/ABAP/utils17.jpg&#34; alt=&#34;成本中心组&#34; /&gt;&lt;/p&gt;

&lt;p&gt;​   这是一个树型结构，针对根节点、子节点、叶节点，SAP 有三张表：SETHEADER、SETNODE、SETLEAF。既然是树型结构那用递归遍历是最合适不过了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;*&amp;amp;--------------------------------------------------------------------*
*&amp;amp;      Form  frm_get_kostl
*&amp;amp;--------------------------------------------------------------------*
*       递归查询一个成本中心组下的所有成本中心。
*---------------------------------------------------------------------*
*      --&amp;gt;I_TREE     成本中心组根节点
*---------------------------------------------------------------------*
FORM FRM_GET_KOSTL USING I_TREE LIKE I_TREE.
  DATA: I_TEMPTREE LIKE I_TREE OCCURS 0 WITH HEADER LINE.
  SELECT SUBSETNAME
    INTO I_TEMPTREE
    FROM SETNODE
    WHERE SETCLASS = &#39;0101&#39;
    AND SUBCLASS = &#39;YZJT&#39;
    AND SETNAME = I_TREE-SETNAME.
   IF SY-SUBRC = 0.
    PERFORM FRM_GET_KOSTL USING I_TEMPTREE.
   ENDIF.
  ENDSELECT.
  SELECT VALFROM FROM SETLEAF INTO F_KOSTL
    WHERE SETCLASS = &#39;0101&#39;
    AND SUBCLASS = &#39;YZJT&#39;
    AND SETNAME = I_TREE-SETNAME.
   APPEND F_KOSTL .
  ENDSELECT.
ENDFORM.                    &amp;quot;frm_get_kostl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;&amp;quot;数据结构定义
DATA: BEGIN OF I_TREE OCCURS 0,
      SETNAME LIKE SETNODE-SETNAME,
      END OF I_TREE.
DATA: BEGIN OF I_KOSTL OCCURS 0,
      VALFROM LIKE SETLEAF-VALFROM,
      END OF I_KOSTL.
DATA: I_SETHEADER LIKE I_TREE OCCURS 0 WITH HEADER LINE. 

PERFORM FRM_GET_KOSTL USING I_SETHEADER.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;针对 SAP 中 SET（集）的操作，有好多函数，如 G_SET_GET_ALL_VALUES：Read All Values in a Set Hierarchy&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title> ALV Tree标准Demo </title>
      <link>https://coldinfire.github.io/2019/ABAP_ALVTree/</link>
      <pubDate>Mon, 24 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/ABAP_ALVTree/</guid>
      <description>

&lt;h3 id=&#34;demo列表&#34;&gt;Demo列表&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;BCALV_TREE_01                  ALV 树控制：构建层次树
BCALV_TREE_02                  ALV 树控制：事件处理
BCALV_TREE_03                  ALV 树控制：使用自己的上下文菜单
BCALV_TREE_04                  ALV 树控制：添加按钮到工具栏
BCALV_TREE_05                  ALV 树控制：添加菜单到工具栏
BCALV_TREE_06                  ALV 树控制: 节点/项目的图标和图标栏
BCALV_TREE_DEMO                ALV 树控制的演示
BCALV_TREE_DND                 ALV 树控制: 在层次树中拖放
BCALV_TREE_DND_MULTIPLE        ALV 树控制: 在层次树中拖放
BCALV_TREE_EVENT_RECEIVER
BCALV_TREE_EVENT_RECEIVER01
BCALV_TREE_ITEMLAYOUT          ALV 树: 在运行时更改项目格式
BCALV_TREE_MOVE_NODE_TEST
BCALV_TREE_SIMPLE_DEMO         程序 BCALV_TREE_SIMPLE_DEMO
BCALV_TREE_VERIFY              ALV 树和简单 ALV 树的校验者
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>BAPI使用</title>
      <link>https://coldinfire.github.io/2019/BAPI/</link>
      <pubDate>Sun, 16 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/BAPI/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;BAPI：Business Application Process Interface(业务应用编辑接口)，它实质上就是一种特殊的RFC函数。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;BAPI函数及函数参数参考的结构类型名，都要以ZBAPI开头；&lt;/li&gt;
&lt;li&gt;BAPI函数参数只能是传值，不能有Change与Exception参数&lt;/li&gt;
&lt;li&gt;BAPI函数需要有Return返回参数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查找事务码对应的BAPI&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;进入事务码，system status &amp;ndash;&amp;gt; 事务码双击，找到Package VA &amp;ndash;&amp;gt; SE80打开包VA/Display Object List
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;BAPI事务处理&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;同时调用多个BAPI，需要在程序中进行事务控制，决定何时执行数据库提交或回滚；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;BAPI内部不包含COMMIT WORK,ROLLBACK WORK&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;根据BAPI函数的返回数据进行判断：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt; IF return-type &amp;lt;&amp;gt; &#39;S&#39;.
   CALL FUNCTION &#39;BAPI_TRANSACTION_ROLLBACK&#39;.
 ELSE.
   CALL FUNCTION &#39;BAPI_TRANSACTION_COMMIT&#39;
 EXPORTING
   wait = &#39;X&#39;.
 ENDIF.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.多个BAPI调用时需要遵守以下原则&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;1&gt;如果有更新操作的BAPI,对实例进行另外的读取操作的BAPI只能访问上一个COMMIT WORK 执行后的最新数据&lt;/li&gt;
&lt;li&gt;&lt;2&gt;在同一个LUW中，不能对同一个业务对象实例时行超过一次的更新操作。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>BOM了解</title>
      <link>https://coldinfire.github.io/2019/BOM/</link>
      <pubDate>Thu, 25 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/BOM/</guid>
      <description>

&lt;h3 id=&#34;bom定义&#34;&gt;BOM定义&lt;/h3&gt;

&lt;p&gt;​   BOM:物料清单，是部件完整、正式的结构化清单，组成一个产品或装配。包括每个部件的项目号、损耗、数量和计量单位。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Work Center 了解</title>
      <link>https://coldinfire.github.io/2019/MMWorkCenter/</link>
      <pubDate>Thu, 25 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/MMWorkCenter/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
