<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Small Fire`s Blog on Small Fire`s Blog</title>
    <link>https://coldinfire.github.io/</link>
    <description>Recent content in Small Fire`s Blog on Small Fire`s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 14 Apr 2019 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://coldinfire.github.io/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Books</title>
      <link>https://coldinfire.github.io/books/</link>
      <pubDate>Thu, 15 Jun 2017 23:39:47 +0800</pubDate>
      
      <guid>https://coldinfire.github.io/books/</guid>
      <description>

&lt;h3 id=&#34;开卷有益&#34;&gt;开卷有益&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Number&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;th&gt;State&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;img width=200/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img width=500/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img width=500/&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://book.douban.com/subject/1084336/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;小王子&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://book.douban.com/subject/26952718/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;好好学习&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;🕐&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://book.douban.com/subject/26948148/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;好好说话&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;🕐&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://book.douban.com/subject/1008145/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;围城&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;🕐&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://book.douban.com/subject/5346110/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;穷查理宝典&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;🕐&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://book.douban.com/subject/3533221/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;非暴力沟通&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;🕐&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://book.douban.com/subject/1056295/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;人性的弱点&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;🕐&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://coldinfire.github.io/about/</link>
      <pubDate>Thu, 15 Jun 2017 23:39:47 +0800</pubDate>
      
      <guid>https://coldinfire.github.io/about/</guid>
      <description>&lt;p&gt;这个人很懒，什么都没留下&amp;hellip;&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>移库动作产生的报错:Error BS001 when posting goods movment</title>
      <link>https://coldinfire.github.io/2019/SAPQ1/</link>
      <pubDate>Sun, 14 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/SAPQ1/</guid>
      <description>&lt;p&gt;Q：当进行移库操作时，同一个程序中执行多次移库动作会产生Error Message:No status object is available for HU  XXXXXX?&lt;/p&gt;

&lt;p&gt;A：需要每次进行移库前刷新数据：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&amp;ldquo;调用BAPI进行移库操作&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;CALL FUNCTION &amp;lsquo;HU_PACKING_REFRESH&amp;rsquo;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;CALL FUNCTION &amp;lsquo;SERIAL_INTTAB_REFRESH&amp;rsquo;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;CALL FUNCTION &amp;lsquo;V51G_REFRESH&amp;rsquo;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;  CALL FUNCTION &#39;HU_CREATE_GOODS_MOVEMENT&#39;
    EXPORTING
      IF_EVENT       = &#39;0006&#39;
      IF_COMMIT      = &#39;&#39;
      IF_TCODE       = &#39;HUMO&#39;
      IT_MOVE_TO     = IT_MOVE_TO[]
      IT_EXTERNAL_ID = IT_EXTERNAL_ID[]
    IMPORTING
      ES_MESSAGE     = ES_MESSAGE
      ET_MESSAGES    = ET_MESSAGES[]
      ES_EMKPF       = ES_EMKPF.
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>STO详解</title>
      <link>https://coldinfire.github.io/2019/ABAPSTO/</link>
      <pubDate>Mon, 01 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/ABAPSTO/</guid>
      <description>

&lt;h3 id=&#34;一-工厂间转储&#34;&gt;一、工厂间转储&lt;/h3&gt;

&lt;p&gt;（1）MB1B 移动类型 301 工厂到工厂（一步）转账 -&amp;gt; 简单明了一步转储；过账后会产生 GR，MITA 增加了，MIZH 减少了，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MB03：-&amp;gt; 会产生 GR, 如果俩工厂标准价或者移动平均价不同，差异会调整到库存调拨损益科目。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;（2）MB1B （两步转储）移动类型 1. 转出 303, 2. 转入 305，两步转储操作，过账后，产生&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;物料凭证 - MB03,&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;会计凭证 - FB03,&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;（3）区别&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;​ MMBE 仔细看一下接收库存，会发现和一步的 区别，
在库存传送那出现了 - 转储的数量，
接下来就是接收库存，MB1B,过账后,也会产生 GR , 却不会产生 FR 财务凭证。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   移动类型的工厂 1 步，2 步的转储，后台配置主要配置好存货科目，及转储中的损益科目便可。&lt;/p&gt;

&lt;h3 id=&#34;二-跨工厂转储-公司间调拨&#34;&gt;二、跨工厂转储（公司间调拨）&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;MM 转储操作 MB1B&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;【过账抬头】&lt;/p&gt;

&lt;p&gt;​   移动类型：表示库存地点一步转储&lt;/p&gt;

&lt;p&gt;​   工厂：指定公司代码&lt;/p&gt;

&lt;p&gt;​   库存地点：物料储存的仓库代码&lt;/p&gt;

&lt;p&gt;【过账项目】&lt;/p&gt;

&lt;p&gt;​   接收库存地点：物料转储后存放的库位代码&lt;/p&gt;

&lt;p&gt;​   物料：原料等级代码&lt;/p&gt;

&lt;p&gt;​   数量：转储物料的量,和后面单位要对应&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WM 层面 转储操作 LT06&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   此界面正常情况下自动进入，若出现断线等异常情况，则用事物码 LT05 进入本界面，
并输入相应的物料凭证号。&lt;/p&gt;

&lt;p&gt;【抬头】&lt;/p&gt;

&lt;p&gt;​   物料凭证：物料转储后产生的凭证号&lt;/p&gt;

&lt;p&gt;​   物料凭证年份： 指定的年份&lt;/p&gt;

&lt;p&gt;​   仓库号：指定的仓库好&lt;/p&gt;

&lt;p&gt;​   在将转出的仓位号前填写转移数量&lt;/p&gt;

&lt;p&gt;​   去掉 “记帐到同一仓位” 下的√&lt;/p&gt;

&lt;h3 id=&#34;原料厂内转储单&#34;&gt;原料厂内转储单&lt;/h3&gt;

&lt;p&gt;在 “工厂” 中输入工厂在 “物料凭证编号” 中输入‘凭证号‘点执行按钮&lt;/p&gt;

&lt;p&gt;1   检查单据内容，无误后点菜单栏 “文本”→“打印”    打印原料厂内转储单&lt;/p&gt;

&lt;p&gt;-&amp;gt; 查询各物料库存信息： MMBE/MB52/LS24&lt;/p&gt;

&lt;p&gt;-&amp;gt;SAP 系统内进行转储操作 MB1B&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;移动类型 311；工厂 &amp;lsquo;XXXX&amp;rsquo;；发货库存地点 &amp;lsquo;XXXX&amp;rsquo;；转储物料编码 &amp;lsquo;XXXX&amp;rsquo;；数量 &amp;lsquo;XXXX&amp;rsquo;；接收库存地点 &amp;lsquo;XXXX&amp;rsquo;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;-&amp;gt; 在 SAP 系统的 WM 模块中确定&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;确定转出、转入仓位 &amp;lsquo;XXXX&amp;rsquo;；物料凭证&amp;rsquo;XXXX&amp;rsquo;；物料凭证的年份&amp;rsquo;XXXX&amp;rsquo;；仓库号&amp;rsquo;XXXX&amp;rsquo;；源仓位 &amp;lsquo;01-01-08&amp;rsquo;；目的仓位 &amp;lsquo;01-01-05&amp;rsquo;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;-&amp;gt; 查看物料凭证 MB03&lt;/p&gt;

&lt;p&gt;-&amp;gt; 查询物料凭证清单 MB51&lt;/p&gt;

&lt;p&gt;-&amp;gt; MMBE 单个料查询库存&lt;/p&gt;

&lt;p&gt;-&amp;gt; MB52（此查询带金额）&lt;/p&gt;

&lt;p&gt;-&amp;gt; LS24（查询某一物料的仓位库存）&lt;/p&gt;

&lt;p&gt;-&amp;gt; MB03 显示物料凭证 &amp;lt;-&amp;gt; 同部分 migo&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title> SAP下载程序源码工具 </title>
      <link>https://coldinfire.github.io/2019/ABAPUtils10/</link>
      <pubDate>Wed, 27 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/ABAPUtils10/</guid>
      <description>&lt;p&gt;程序：转自 &lt;a href=&#34;http://blog.sina.com.cn/s/blog_4d1570de0100pvhd.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://blog.sina.com.cn/s/blog_4d1570de0100pvhd.html&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;*@---------------------------------------------------------------------*
*@ Report ZZXUE01 下载程序代码
*@ T-code
*@---------------------------------------------------------------------*
*@ Created by Xavery Hsueh on 2011-03-01
*@ Lasted Edited date:
*@---------------------------------------------------------------------*
REPORT XXX NO STANDARD PAGE HEADING.

***********************************************************************@
** 声明数据库表
***********************************************************************@
TABLES:rs38m,
trdir. &amp;quot;
***********************************************************************@
** 内表结构类型的定义
***********************************************************************@
DATA BEGIN OF dynpfields OCCURS 1.
INCLUDE STRUCTURE dynpread.
DATA END OF dynpfields.

TYPES:BEGIN OF typ_result,
box TYPE c,
tabix TYPE sytabix, &amp;quot;顺序号
name TYPE char40, &amp;quot;程序名称
cnam TYPE cnam, &amp;quot;创建人员
unam TYPE unam, &amp;quot;最后修改人
code(72) TYPE c, &amp;quot;程序描述
END OF typ_result.
***********************************************************************@
** 变量与内表的定义
***********************************************************************@
DATA:gt_report TYPE TABLE OF tdline WITH HEADER LINE.
DATA:gt_result TYPE TABLE OF typ_result WITH HEADER LINE.
DATA:gt_trdir TYPE TABLE OF trdir WITH HEADER LINE.
DATA:gt_btab TYPE TABLE OF textpool WITH HEADER LINE.

DATA:g_filenm TYPE rlgrap-filename. &amp;quot;文件名称
RANGES r_prog FOR rs38m-programm. &amp;quot;程序名称
*@------------------ ALV 相关的变量 -----------------------------------*
TYPE-POOLS:slis.
DATA: g_repid LIKE sy-repid,
wa_print TYPE slis_print_alv,
gt_list_top_of_page TYPE slis_t_listheader,
gt_events TYPE slis_t_event WITH HEADER LINE,
gt_sort TYPE slis_t_sortinfo_alv,
wa_layout TYPE slis_layout_alv,
gt_fieldcat TYPE slis_t_fieldcat_alv WITH HEADER LINE,
wa_fieldcat LIKE LINE OF gt_fieldcat,
g_save TYPE c,
g_pos TYPE i.
***********************************************************************@
** 宏定义
***********************************************************************@
DEFINE mcr_field.
clear wa_fieldcat.
g_pos = g_pos + 1 .
wa_fieldcat-col_pos = g_pos.
wa_fieldcat-fieldname = &amp;amp;1.
wa_fieldcat-tabname = &#39;I_RESULT&#39;.

&amp;quot; wa_fieldcat-no_out = &#39;X&#39;. &amp;quot;field no display, choose from layout
  wa_fieldcat-key = &#39; &#39;. &amp;quot;SUBTOTAL KEY
  wa_fieldcat-seltext_l = &amp;amp;2.
  wa_fieldcat-outputlen = &amp;amp;3.
  append wa_fieldcat to gt_fieldcat.
  END-OF-DEFINITION.
*@---------------------------------------------------------------------*
*@ MACRO MCR_RANGE 初始化选择条件
*@---------------------------------------------------------------------*
* &amp;amp;1 RANGE 变量
* &amp;amp;2 操作符
* &amp;amp;3 LOW
* &amp;amp;4 HIGH
*----------------------------------------------------------------------*
  DEFINE mcr_range.
  clear &amp;amp;1.
  &amp;amp;1-sign = &#39;I&#39;.
  &amp;amp;1-option = &amp;amp;2.
  &amp;amp;1-low = &amp;amp;3.
  &amp;amp;1-high = &amp;amp;4.
  append &amp;amp;1.
  END-OF-DEFINITION.
 ***********************************************************************@
 ** 屏幕定义
 ***********************************************************************@
  SELECTION-SCREEN BEGIN OF BLOCK xavery WITH FRAME TITLE text_001.
  SELECTION-SCREEN BEGIN OF LINE.
  SELECTION-SCREEN COMMENT 1(15) text_002 FOR FIELD p_prog.
  PARAMETERS:p_prog TYPE rs38m-programm MEMORY ID rid.
  SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(15) text_003 FOR FIELD p_cnam.
PARAMETERS:p_cnam TYPE cnam DEFAULT sy-uname.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(15) text_004 FOR FIELD p_filenm.
PARAMETERS:p_filenm TYPE rlgrap-filename.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN END OF BLOCK xavery.
***********************************************************************@
** 执行程序事件
***********************************************************************@
INITIALIZATION.
PERFORM f_init_condition.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_prog.
PERFORM sub_get_program.

START-OF-SELECTION.
PERFORM sub_query_report.
PERFORM sub_process_report.

END-OF-SELECTION.
PERFORM sub_init_layout.
PERFORM sub_create_fieldcat.
PERFORM sub_display_as_alv. &amp;quot;以ALV的方式输出结果表
*@---------------------------------------------------------------------*
*@ Form F_INIT_CONDITION
*@---------------------------------------------------------------------*
* 初始化选择条件
*----------------------------------------------------------------------*
  FORM f_init_condition .
  text_001 = &#39;查询条件&#39;.
  text_002 = &#39;程序名称&#39;.
  text_003 = &#39;程序创建人&#39;.
  text_004 = &#39;下载文件名称&#39;.
&amp;quot; 选择屏幕初始值
  p_prog = &#39;Z*&#39;.
  p_filenm = &#39;C:\ABAP\&#39;.
  ENDFORM. &amp;quot; F_INIT_CONDITION
*&amp;amp;---------------------------------------------------------------------*
*&amp;amp; Form SUB_GET_PROGRAM
*&amp;amp;---------------------------------------------------------------------*
* text
*----------------------------------------------------------------------*
  FORM sub_get_program .
  DATA: repid LIKE sy-repid.
  dynpfields-fieldname = &#39;P_PROG&#39;.
  APPEND dynpfields.
  repid = sy-repid.
  CALL FUNCTION &#39;DYNP_VALUES_READ&#39;
  EXPORTING
  dyname = repid
  dynumb = sy-dynnr
  TABLES
  dynpfields = dynpfields
  EXCEPTIONS
  OTHERS.
  READ TABLE dynpfields INDEX 1.
  p_prog = dynpfields-fieldvalue.
  PERFORM program_directory USING p_prog &#39;X&#39;.
  ENDFORM. &amp;quot; SUB_GET_PROGRAM

*---------------------------------------------------------------------*
* FORM PROGRAM_DIRECTORY *
*---------------------------------------------------------------------*
  FORM program_directory USING programm LIKE rs38m-programm
  f4_call.
  DATA: info_object LIKE euobj-id,
  l_programm LIKE rs38m-programm.
  IF sy-tcode(4) = &#39;SE38&#39;.
  info_object = &#39;PROG&#39;.
  IF f4_call = &#39;X&#39;.
  CALL FUNCTION &#39;REPOSITORY_INFO_SYSTEM_F4&#39;
  EXPORTING
  object_type = info_object
  object_name = programm
  suppress_selection = &#39;X&#39;
  IMPORTING
  object_name_selected = programm
  EXCEPTIONS
  cancel = 01.
  ELSE.
  CALL FUNCTION &#39;REPOSITORY_INFO_SYSTEM&#39;
  EXPORTING
  object_type = info_object
  action = &#39;S&#39;
  object_name = programm
  IMPORTING
  object_name_selected = programm
  EXCEPTIONS
  cancel = 01
  wrong_type = 02.
  ENDIF.
  ELSE.
  l_programm = programm.
  IF l_programm = space.
  SUBMIT rsabadab AND RETURN VIA SELECTION-SCREEN
  WITH f4_call = f4_call.
  ELSE.
  SUBMIT rsabadab AND RETURN VIA SELECTION-SCREEN
  WITH repname CP l_programm
  WITH f4_call = f4_call.
  ENDIF.
  GET PARAMETER ID &#39;RID&#39; FIELD p_prog.
  ENDIF.
  ENDFORM. &amp;quot;program_directory
*&amp;amp;---------------------------------------------------------------------*
*&amp;amp; Form SUB_QUERY_REPORT
*&amp;amp;---------------------------------------------------------------------*
* 查询程序代码
*----------------------------------------------------------------------*
  FORM sub_query_report .
  mcr_range r_prog &#39;CP&#39; p_prog &#39;&#39;.
  SELECT * FROM trdir
  INTO TABLE gt_trdir
  WHERE name IN r_prog AND
  cnam EQ p_cnam AND
  subc NE &#39;X&#39;.
  ENDFORM. &amp;quot; SUB_QUERY_REPORT
*&amp;amp;---------------------------------------------------------------------*
*&amp;amp; Form SUB_DOWNLOAD_REPORT
*&amp;amp;---------------------------------------------------------------------*
*下载程序代码
*----------------------------------------------------------------------*
  FORM sub_download_report USING l_filenm TYPE rlgrap-filename.
  DATA: binfilesize TYPE i.
  DATA: l_file TYPE string.
  DATA: l_message TYPE char100.
  CONCATENATE &#39;文件已下载到：&#39; p_filenm &#39;文件夹中！&#39;
  INTO l_message.
  l_file = l_filenm.
  CALL FUNCTION &#39;GUI_DOWNLOAD&#39;
  EXPORTING
  bin_filesize = binfilesize
  filename = l_file
  filetype = &#39;ASC&#39;
  TABLES
  data_tab = gt_report[]
  EXCEPTIONS
  file_write_error = 1
  no_batch = 2
  gui_refuse_filetransfer = 3
  invalid_type = 4
  no_authority = 5
  unknown_error = 6
  header_not_allowed = 7
  separator_not_allowed = 8
  filesize_not_allowed = 9
  header_too_long = 10
  dp_error_create = 11
  dp_error_send = 12
  dp_error_write = 13
  unknown_dp_error = 14
  access_denied = 15
  dp_out_of_memory = 16
  disk_full = 17
  dp_timeout = 18
  file_not_found = 19
  dataprovider_exception = 20
  control_flush_error = 21
  OTHERS = 22.

IF sy-subrc = 0.
MESSAGE l_message TYPE &#39;S&#39;.
ENDIF.
ENDFORM. &amp;quot; SUB_DOWNLOAD_REPORT
*&amp;amp;---------------------------------------------------------------------*
*&amp;amp; Form SUB_PROCESS_REPORT
*&amp;amp;---------------------------------------------------------------------*
* 处理文件名称，并放到内表中
*----------------------------------------------------------------------*
  FORM sub_process_report .
  SORT gt_trdir BY name.
  LOOP AT gt_trdir.
  CLEAR gt_result.
  gt_result-name = gt_trdir-name.
  gt_result-cnam = gt_trdir-cnam.
  gt_result-unam = gt_trdir-unam.
  gt_result-tabix = sy-tabix.
  REFRESH gt_btab.
  READ TEXTPOOL gt_trdir-name INTO gt_btab LANGUAGE sy-langu.
  CLEAR gt_btab.
  READ TABLE gt_btab WITH KEY &#39;R&#39;.
  IF sy-subrc = 0.
  MOVE gt_btab-entry TO gt_result-code.
  ENDIF.
  APPEND gt_result.
  ENDLOOP.
&amp;quot; 清空内表
  FREE gt_trdir.
  ENDFORM. &amp;quot; SUB_PROCESS_REPORT
*&amp;amp;---------------------------------------------------------------------*
*&amp;amp; Form SUB_CREATE_FIELDCAT
*&amp;amp;---------------------------------------------------------------------*
* text
*----------------------------------------------------------------------*
  FORM sub_create_fieldcat .
  CLEAR gt_fieldcat[].
  mcr_field &#39;TABIX&#39; &#39;顺序号&#39; &#39;10&#39;.
  mcr_field &#39;NAME&#39; &#39;程序名称&#39; &#39;15&#39;.
  mcr_field &#39;CNAM&#39; &#39;程序创建人&#39; &#39;20&#39;.
  mcr_field &#39;UNAM&#39; &#39;最后修改人&#39; &#39;20&#39;.
  mcr_field &#39;CODE&#39; &#39;程序描述&#39; &#39;30&#39;.
  ENDFORM. &amp;quot; SUB_CREATE_FIELDCAT
*&amp;amp;---------------------------------------------------------------------*
*&amp;amp; Form SUB_INIT_LAYOUT
*&amp;amp;---------------------------------------------------------------------*
* text
*----------------------------------------------------------------------*
  FORM sub_init_layout .
  wa_layout-zebra = &#39;X&#39;.
  wa_layout-window_titlebar = &#39;开发程序名称清单&#39;.
  wa_layout-colwidth_optimize = &#39;X&#39;.
  wa_layout-box_fieldname = &#39;BOX&#39;.
  ENDFORM. &amp;quot; SUB_INIT_LAYOUT
*&amp;amp;---------------------------------------------------------------------*
*&amp;amp; Form SUB_DISPLAY_AS_ALV
*&amp;amp;---------------------------------------------------------------------*
* text
*----------------------------------------------------------------------*
  FORM sub_display_as_alv .
  g_repid = sy-repid.
  *ABAP List Viewer
  CALL FUNCTION &#39;REUSE_ALV_GRID_DISPLAY&#39;
  EXPORTING
  i_callback_program = g_repid
  i_structure_name = &#39;TYP_RESULT&#39;
  i_callback_user_command = &#39;SUB_USER_COMMAND&#39;
  i_callback_pf_status_set = &#39;SUB_SET_PF_STATUS&#39;
  i_save = g_save
  is_layout = wa_layout
  it_fieldcat = gt_fieldcat[]
  TABLES
  t_outtab = gt_result
  EXCEPTIONS
  program_error = 1
  OTHERS = 2.
  ENDFORM. &amp;quot; SUB_DISPLAY_AS_ALV
*@--------------------------------------------------------------------*
*@ Form sub_user_command
*@--------------------------------------------------------------------*
* --&amp;gt;R_UCOMM 事务功能码
* --&amp;gt;RS_SELFIELD ALV相关的数据
*---------------------------------------------------------------------*
  FORM sub_user_command USING r_ucomm LIKE sy-ucomm
  rs_selfield TYPE slis_selfield.

CASE r_ucomm.
WHEN &#39;&amp;amp;IC1&#39;. &amp;quot;双击事件的功能码
WHEN &#39;DOWNLOAD&#39;. &amp;quot;下载代码
PERFORM sub_ucomm_down.
ENDCASE.

* 刷新ALV屏幕报表
  rs_selfield-refresh = &#39;X&#39;.
  ENDFORM. &amp;quot;sub_user_command
*@---------------------------------------------------------------------*
*@ FORM SUB_SET_PF_STATUS *
*@---------------------------------------------------------------------*
* 设置ALV菜单
* 通过SE41，拷贝程序SAPLSLVC_FULLSCREEN的状态STANDARD_FULLSCREEN过来
*@---------------------------------------------------------------------*
  FORM sub_set_pf_status USING rt_extab TYPE slis_t_extab.
  SET PF-STATUS &#39;STANDARD_FULLSCREEN&#39;.
  ENDFORM. &amp;quot;sub_set_pf_status
*&amp;amp;---------------------------------------------------------------------*
*&amp;amp; Form SUB_UCOMM_DOWN
*&amp;amp;---------------------------------------------------------------------*
* 下载选中的行的程序代码
*----------------------------------------------------------------------*
  FORM sub_ucomm_down .
  LOOP AT gt_result WHERE box = &#39;X&#39;.
* 得到文件名称
  CLEAR g_filenm.
  CONCATENATE p_filenm gt_result-name &#39;-&#39;
  gt_result-code &#39;.txt&#39;
  INTO g_filenm.
* 得到程序代码
  CLEAR gt_report[].
  READ REPORT gt_result-name INTO gt_report.
* 下载程序
  PERFORM sub_download_report USING g_filenm.
  ENDLOOP.
  ENDFORM. &amp;quot; SUB_UCOMM_DOWN
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title> SAP发送邮件 </title>
      <link>https://coldinfire.github.io/2019/ABAPUtils11/</link>
      <pubDate>Wed, 27 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/ABAPUtils11/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;TRY.
&amp;quot; 创建发送请求
  l_send_request = cl_bcs=&amp;gt;create_persistent( ).
&amp;quot; 设定发送内容
  l_document = cl_document_bcs=&amp;gt;create_document( i_type  = &#39;RAW&#39;
                                           i_text  = i_content[]
                                           I_IMPORTANCE = &#39;1&#39;
                                           i_subject = l_subject ).
&amp;quot; 增加发送内容到发送请求
  CALL METHOD l_send_request-&amp;gt;set_document( l_document ).
&amp;quot; 取得发送者（取得发件人，前提是这个邮箱地址能发邮件，并且不需要密码）
  l_uname = sy-uname.
  l_sender = cl_sapuser_bcs=&amp;gt;create( l_uname ).
  CALL METHOD l_send_request-&amp;gt;set_sender
    EXPORTING
      i_sender = l_sender.
&amp;quot; 设置收件人
   LOOP AT it_mailaccept.
     CONCATENATE it_mailaccept-name &#39;@XXXXX.COM&#39; INTO i_email.
     TRANSLATE i_email TO LOWER CASE.
     l_recipient = cl_cam_address_bcs=&amp;gt;create_internet_address( i_email ).
     CALL METHOD l_send_request-&amp;gt;add_recipient
       EXPORTING
         i_recipient  = l_recipient
         i_express    = &#39;X&#39;
         i_copy       = &#39; &#39;
         i_blind_copy = &#39; &#39;
         i_no_forward = &#39; &#39;.
   ENDLOOP.
&amp;quot; 设置抄送人
    LOOP AT it_mailaccept_copy.
      CONCATENATE it_mailaccept_copy-name &#39;@XXXXX&#39; INTO i_email.
      TRANSLATE i_email TO LOWER CASE.
      l_recipient = cl_cam_address_bcs=&amp;gt;create_internet_address( i_email ).
      CALL METHOD l_send_request-&amp;gt;add_recipient
        EXPORTING
          i_recipient  = l_recipient
          i_express    = &#39;X&#39;
          i_copy       = &#39;X&#39;
          i_blind_copy = &#39; &#39;
          i_no_forward = &#39; &#39;.
    ENDLOOP.
*&amp;amp;  立即发送
  l_send_request-&amp;gt;set_send_immediately( &#39;X&#39; ).
*&amp;amp;  发送
  CALL METHOD l_send_request-&amp;gt;send( ).
    COMMIT WORK.
  CATCH cx_document_bcs INTO l_bcs_exception.
  CATCH cx_send_req_bcs INTO l_send_exception.
  CATCH cx_address_bcs  INTO l_addr_exception.
ENDTRY.
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>SAP后台JOB</title>
      <link>https://coldinfire.github.io/2019/ABAPJOB/</link>
      <pubDate>Fri, 22 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/ABAPJOB/</guid>
      <description>

&lt;h3 id=&#34;定义后台-job&#34;&gt;定义后台 job&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一种：SE38执行可执行程序&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;菜单栏‘program’&amp;mdash;&amp;gt;&amp;lsquo;Execute in Background&amp;rsquo;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/ABAP/JOB1.png&#34; alt=&#34;后台JOB&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;输入输出设备&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/ABAP/JOB3.png&#34; alt=&#34;输出设备&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;选择开始时间（立刻执行，或定义日期时间，也可周期执行）后保存。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/ABAP/JOB2.png&#34; alt=&#34;时间&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第二种：SM36定义作业名&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;点击‘Start condition’选择job开始时间（立刻执行，或定义日期时间，也可周期执行）后保存.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/ABAP/JOB4.png&#34; alt=&#34;Start Condition&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;再点击‘Step’，填写abap程序‘NAME’和‘Variant’后保存，回到主界面后再保存。后台会在你定义的时间，自动执行按照变式的条件执行程序。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/ABAP/JOB5.png&#34; alt=&#34;Step&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.sina.com.cn/s/blog_76c57b480100rumm.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;如何在 SAP 中定义 Event 类型的后台 Job&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;强制结束后台作业-sap-sm37-sm35-sm50&#34;&gt;强制结束后台作业（SAP SM37 SM35 SM50)&lt;/h4&gt;

&lt;p&gt;解决方法：&lt;/p&gt;

&lt;p&gt;第一步：SM50&lt;/p&gt;

&lt;p&gt;​   找到Ty. 列为 BGD 的(Background)，然后再找到你刚运行的那个后台 Job 的行，选中；然后在菜单点击：Process&amp;mdash;Cancel with core. 即可。&lt;/p&gt;

&lt;p&gt;第二步：SM37 查看 Background Job，应该为 “取消” 状态。&lt;/p&gt;

&lt;p&gt;第三步：SM35，选中 Session Name，点击小绿旗 release 即可。&lt;/p&gt;

&lt;h4 id=&#34;如何查看一个后台job对应哪些程序&#34;&gt;如何查看一个后台job对应哪些程序?&lt;/h4&gt;

&lt;p&gt;​   sm36&amp;ndash;&amp;gt;点击“job selection”&amp;ndash;&amp;gt;运行结果双击选择job&amp;ndash;&amp;gt;回到第一个界面，点击“步骤”按钮，转到步骤清单总览，里面就可以看到程序名称了已取消，完成的job是不能修改的其它状态的都可以改，在sm37里，选择相应的job，菜单里有个更改项
sm37就是sm36里job selection的链接.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title> Fiori简介 </title>
      <link>https://coldinfire.github.io/2019/FioriOverview/</link>
      <pubDate>Sat, 16 Mar 2019 17:20:58 +0800</pubDate>
      
      <guid>https://coldinfire.github.io/2019/FioriOverview/</guid>
      <description>

&lt;h2 id=&#34;框架设计&#34;&gt;框架设计&lt;/h2&gt;

&lt;p&gt;SAP Fiori UI5有五种设计原则。这些原则使SAP Fiori变得简单，并将不同的事务分解为基于任务的简单UI应用程序。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;基于角色 - SAP已经分解了各种SAP事务并将其更改为漂亮的用户交互式应用程序，这些应用程序仅向用户显示最相关的信息。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;响应能力 - 当SAP Fiori与SAP HANA的强大功能相结合时，它提供了无与伦比的应用程序响应和查询执行时间。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;简单 - 为了使SAP Fiori易于满足用户需求，SAP将其设计为1-1-3方案。这意味着1个用户，1个用例和3个屏幕。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;无缝体验 - SAP提供了基于相同语言的所有Fiori应用程序，并且在部署和平台上无关紧要。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;令人愉快 - SAP Fiori旨在与ECC 6.0协同工作，使用户可以轻松地在现有SAP系统上进行部署。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SAP Fiori应用程序分为三类。它们的功能和基础设施要求非常突出。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;交易应用&lt;/li&gt;
&lt;li&gt;实况报道&lt;/li&gt;
&lt;li&gt;分析应用程序
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;交易应用程序最重要的功能是 ：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SAP Fiori的第一个版本包括25个交易应用程序。&lt;/li&gt;
&lt;li&gt;SAP Fiori中的交易应用程序用于执行交易任务，例如经理 - 员工交易，例如请假请求，旅行请求等。&lt;/li&gt;
&lt;li&gt;事务性应用程序在SAP HANA数据库上运行最佳，但可以与任何性能可接受的数据库一起部署。这些应用程序允许用户在移动设备以及台式机或笔记本电脑上运行简单的SAP事务。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实况报道的重要特征如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;实况表用于在业务操作中钻取关键信息和上下文信息。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;它还允许您将一个事实表导航到其所有相关的情况说明书。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;情况说明书还允许您导航到事务性应用程序以运行SAP事务。一些情况说明书还提供了地理地图的集成选项。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;您可以从Fiori Launchpad搜索结果，其他情况说明书或交易或分析应用程序中调用Fact Sheet。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;情况说明书仅在SAP HANA数据库上运行，并且还需要ABAP堆栈，并且无法将其移植到SAP HANA Live第2层架构。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;分析应用程序用于&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;提供有关业务操作的基于角色的实时信息。分析应用程序将SAP HANA的强大功能与SAP业务套件相集成。它从前端Web浏览器中的大量数据中提供实时信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;学习sap-fiori的先决条件&#34;&gt;学习SAP Fiori的先决条件：&lt;/h3&gt;

&lt;p&gt;● ABAP程序和对象&lt;/p&gt;

&lt;p&gt;● HTML5&lt;/p&gt;

&lt;p&gt;● JavaScript&lt;/p&gt;

&lt;p&gt;● SAP UI5&lt;/p&gt;

&lt;p&gt;● ERP实施经验&lt;/p&gt;

&lt;p&gt;● OData和SAP NetWeaver网关&lt;/p&gt;

&lt;p&gt;● SAP HANA&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title> SAP HANA</title>
      <link>https://coldinfire.github.io/2019/SAPHANA1/</link>
      <pubDate>Sat, 16 Mar 2019 17:20:58 +0800</pubDate>
      
      <guid>https://coldinfire.github.io/2019/SAPHANA1/</guid>
      <description>

&lt;h3 id=&#34;了解-hana-的途径有&#34;&gt;了解 HANA 的途径有&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://help.sap.com&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://help.sap.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.sdn.sap.com/irj/sdn/in-memory&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.sdn.sap.com/irj/sdn/in-memory&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://service.sap.com/hana&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://service.sap.com/hana&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;hana主要组成成分&#34;&gt;HANA主要组成成分&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;客户端：HANA Studio(In-memory studio)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;内存内数据库：HANA Database&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数据复制组件：SLT/Sybase Replication Sever/BusinessObjects DataServices&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;三种复制数据方法&#34;&gt;三种复制数据方法&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Trigger-based：使用的是 SAP 自己开发的已经有一段历史的工具 SAP Landscape Transformation Replication Server (SLT RS)，这是与底层数据库无关的技术。&lt;/li&gt;
&lt;li&gt;ETL-based：其实就是 ETL 数据到 HANA，使用的当然是 SAP EIM 的旗舰产品BusinessObjects DataServices。&lt;/li&gt;
&lt;li&gt;Log-based：是 Sybase 的 Replication Server，而这曾经是 SAP HANA 的首选，是基于数据库 change log 的复制技术。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;sap-hana应用场景&#34;&gt;SAP HANA应用场景&lt;/h4&gt;

&lt;p&gt;​   HANA DB 是一个列存储的数据库 ,列存储的数据库更容易压缩，聚合结果更快，所以是为分析所设计的。这是 HANA 将会使数据分析提速的因素之一。&lt;/p&gt;

&lt;p&gt;​   HANA DB 是内存内计算数据库，也就是说不仅仅是部分数据存储在内存里，更重要的是，一些逻辑计算发生在内存的数据里，这样肯定要比在应用层计算快得多。这也是 HANA 使数据分析提速的重要因素。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title> SAPUI5 </title>
      <link>https://coldinfire.github.io/2019/SAPUI5/</link>
      <pubDate>Sat, 16 Mar 2019 17:20:58 +0800</pubDate>
      
      <guid>https://coldinfire.github.io/2019/SAPUI5/</guid>
      <description>

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;h3 id=&#34;mvc模式&#34;&gt;MVC模式&lt;/h3&gt;

&lt;p&gt;​     MVC是程序设计的思想实现，通过将界面展示，用户操作，程序数据进行分离，降低模块间的耦合性，有利于项目的开发和维护。&lt;/p&gt;

&lt;p&gt;​    M : Model 代表应用程序的数据&lt;/p&gt;

&lt;p&gt;​    V : View 通过界面展示应用程序的数据和其它界面元素&lt;/p&gt;

&lt;p&gt;​    C : Controller 处理应用程序的数据，以及处理用户的交互&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/SAPUI5/MVC.png&#34; alt=&#34;MVC&#34; /&gt;&lt;/p&gt;

&lt;p&gt;● Model &amp;amp; View : SAPUI5 有单向绑定和双向绑定两种。通过绑定，当 model 变更时，UI 自动更新。&lt;/p&gt;

&lt;p&gt;● Controlle &amp;amp;View : View 通知 Controller，或者 Controller使用API来修改 View。&lt;/p&gt;

&lt;p&gt;● Controller &amp;amp; Model : Model 通知 Controller或者 Controller 修改 Model。&lt;/p&gt;

&lt;p&gt;SAPUI5提供了JSView、XMLView、JSONView和HTMLView。主要使用XMLView 和 JSView。&lt;/p&gt;

&lt;h3 id=&#34;核心类库&#34;&gt;核心类库&lt;/h3&gt;

&lt;p&gt;​   查看&lt;code&gt;Resource&lt;/code&gt;版本：Cttl+Shift+Alt+P在对应的App界面或则LunchPad.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m:&lt;/code&gt;主要用于移动设备的响应式组件，并支持很多移动设备特性检测，比如检测touch等，此库下面List, Table等组件使用比较广泛，而且包含了下拉刷新的功能，非常完善，并自动适应不同尺寸平台&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.ui:&lt;/code&gt; UI库包含的组件是最为丰富的，主要用于适应桌面平台，同样可以支持响应式的设计，比如sap.ui.table等组件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.ui.core:&lt;/code&gt;核心功能：加载和管理所有的附加资源，并包含模型和渲染管理器，一个负责处理渲染视图和控制的单例，写入DOM&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.ui.layout:&lt;/code&gt; 构建视图中元素的特殊控件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.ui.vk:&lt;/code&gt; 包含3D模型的功能和控件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.ui.unified:&lt;/code&gt; 包含用于移动和桌面应用程序的附加控件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.ui.table:&lt;/code&gt; 不适用于手机屏幕，处理大量数据应用而构建的&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.ui.comp:&lt;/code&gt; 包含SmartField,SmartFilterBar,SmartTable,ValueHelpDialog等智能控件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.uxap:&lt;/code&gt; 包含更多控件，包括页面标题&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.ushell:&lt;/code&gt; 包含几个库包，含有所有统一的与shell服务相关的功能&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.ca:&lt;/code&gt; 是官方标准app的常用类库，如果在实际开发过程当中想要拓展标准应用，必须要了解此类库的一些特性，否则拓展起来会有很大问题。&lt;/p&gt;

&lt;h3 id=&#34;核心函数&#34;&gt;核心函数&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sap.ui.getCore()&lt;/code&gt; : 获取核心的实例&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.ui.getCore().byId(id)&lt;/code&gt; : 根据组件id获取其控制；可用于获取已经删除的组件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.ui.getCore().applyChanges()&lt;/code&gt; : 在系统运行前修改UI5组件属性&lt;/p&gt;

&lt;p&gt;&lt;code&gt;jQuery.sap.domById(id)&lt;/code&gt; : 根据ID获取HTML元素;如果UI5也存在该ID返回HTML最顶层的元素;和 document.getElementById 类似&lt;/p&gt;

&lt;p&gt;&lt;code&gt;jQuery.sap.byId(id)&lt;/code&gt; : 根据ID获取JQuery对象的DOM元素; $(,,#myId)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.MessageBox&lt;/code&gt; : SAPUI5风格对话框显示&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.URLHelper.redirect(&amp;quot;http://www.jd.com&amp;quot;, true);&lt;/code&gt;重定向&lt;/p&gt;

&lt;h3 id=&#34;常用组件&#34;&gt;常用组件&lt;/h3&gt;

&lt;h4 id=&#34;splitapp&#34;&gt;SplitApp&lt;/h4&gt;

&lt;p&gt;​    SplitApp : 这是一个Master Detail形式的结构，可以在移动，桌面不同尺寸的设备上自适应，也是大部分app需要采用的一种架构形式。&lt;/p&gt;

&lt;h4 id=&#34;list&#34;&gt;List&lt;/h4&gt;

&lt;p&gt;List : 列表在任何应用中是比较常见的，List在SAPUI5定义功能比较完善，支持分批加载数据，提高运行效率，支持下拉等功能，并提供给我们丰富的标准Item, 可以简单配置使用，更可以根据自身需求定义item。&lt;/p&gt;

&lt;p&gt;​   对于移动设备来说，出于性能考虑，不要超过100行。使用&lt;strong&gt;growing&lt;/strong&gt;特性可以加速内部的渲染。&lt;/p&gt;

&lt;p&gt;​   List控件继承自&lt;code&gt;sap.m.ListBase&lt;/code&gt;，ListBase的items聚合属性(类型：&lt;code&gt;sap.m.ListeItemBase[]&lt;/code&gt;) 设置行项目的模板。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;sap.m.List&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;new sap.m.List({items:{path:&amp;ldquo;/path&amp;rdquo;,template:oTemplate}});&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;new sap.m.List().bindItems({path:&amp;ldquo;/path&amp;rdquo;,template:oTemplate});&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sap.m.ObjectListItem&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ObjectListItem适用于显示行项目的信息，主要使用title属性进行标识，text、icon、atrributes和statuses等属性可以用于提供对象更多信息。继承自sap.m.ObjectListItem，可定义press事件对用户的点击做出回应。&lt;/p&gt;

&lt;h4 id=&#34;table&#34;&gt;Table&lt;/h4&gt;

&lt;p&gt;​    Table : 这是一个表单性质的的组件，支持响应式，很多是够我们做一个表单展示需要此控件的支持。自身也携带了丰富的property供我们选择。&lt;/p&gt;

&lt;h5 id=&#34;sap-ui-table-table&#34;&gt;sap.ui.table.Table&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;sap.ui.table.Table&lt;/p&gt;

&lt;p&gt;&lt;code&gt;oTable.setModel(oModel);&lt;/code&gt;实现Table与JSONModel的绑定，也就是View和Model的绑定。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;oTable.bindRows(&amp;quot;/Suppliers&amp;quot;);&lt;/code&gt;语句实现Table与JSON数据的绑定。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;width : sap.ui.core.CSSSize (default: auto)。表格的宽度可以是百分百，或者基于像素px。&lt;/p&gt;

&lt;p&gt;titel : 设置Table的标题 。&lt;/p&gt;

&lt;p&gt;visibleRowCount : int (default: 10)。默认显示10行，可以自定义显示的行数。&lt;/p&gt;

&lt;p&gt;firstVisibleRow : int (default: 0) 。默认为0，从第一行开始展示数据。&lt;/p&gt;

&lt;p&gt;selectionMode : sap.ui.table.SelectionMode (default: MultiToggle)。包括单行(sap.ui.table.SelectionMode.Single)、多行                                           (sap.ui.table.SelectionMode.MultiToggle)和不能选择行(sap.ui.table.SelectionMode.None)。&lt;/p&gt;

&lt;p&gt;editable : boolean (default: true)。默认可以编辑，如果只是显示，将此属性设置为false。&lt;/p&gt;

&lt;p&gt;columns : [ind1,ind2] 里面填充Table的列元素。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sap.ui.table.Column&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;width : 宽度(100px)。&lt;/p&gt;

&lt;p&gt;label : 设置标题栏。&lt;/p&gt;

&lt;p&gt;template : 设置单元格的显示模板。&lt;/p&gt;

&lt;p&gt;sortProperty : 设置排序针对的字段。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;sap-m-table&#34;&gt;sap.m.Table&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;sap.m.Table&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;继承自sap.m.ListBase，用于显示包含行和列的表格式数据。表格的列可以通过&lt;code&gt;columns&lt;/code&gt;聚合属性来设置，也可以使用&lt;code&gt;addColumn()&lt;/code&gt;方法来添加。每一列都是&lt;code&gt;sap.m.Column&lt;/code&gt;对象。&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;columns&lt;/code&gt;聚合属性和&lt;code&gt;items&lt;/code&gt;聚合属性，items属性实现的就是聚合绑定.。&lt;/p&gt;

&lt;p&gt;sap.m.Table的重要属性：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;columns:&lt;/code&gt;定义Table包含哪些列，类型是sap.m.Column数组。另外，sap.m.Table从sap.m.ListBase继承，所以可以直接使用sap.m.ListBase的属性。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;growing:&lt;/code&gt;设置Table显示的数据可以依据向model的请求增加行noDataText: 当Table没有数据的时候显示的文本，类型是string。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;items:&lt;/code&gt;sap.m.ListItemBase数组，sap.m.ListItemBase类定义了列表项(list item)的基本特征。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;sap.m.ColumnListItem:&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;sap.m.ColumnListItem&lt;/code&gt;用于创建&lt;code&gt;sap.m.Table&lt;/code&gt;的行，行中包含的&lt;code&gt;cells&lt;/code&gt;需要与&lt;code&gt;sap.m.Table&lt;/code&gt;的Columns匹配，顺序一致。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.Table().bindItems(&amp;quot;/modelData&amp;quot;,oCllumnListItem);&lt;/code&gt;绑定行&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.Table().bindAggregation(&amp;quot;items&amp;quot;,&amp;quot;/modelData&amp;quot;,oCollumnListItem);&lt;/code&gt;:聚合绑定。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;oColumnListItem.addCell();&lt;/code&gt;为Items添加元素。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.ColumnListItem&lt;/code&gt;的press属性设置为一个数组，这种方法能够保证在Controller中，this表示Controller本身，而不是某个控件。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;vAlign:&lt;/code&gt;行的垂直对齐：&lt;/p&gt;

&lt;p&gt;​  &lt;code&gt;sap.ui.core.VerticalAlign.Bottom:&lt;/code&gt;底部对齐&lt;/p&gt;

&lt;p&gt;​  &lt;code&gt;sap.ui.core.VerticalAlign.Inherit:&lt;/code&gt;从父控件继承&lt;/p&gt;

&lt;p&gt;​  &lt;code&gt;sap.ui.core.VerticalAlign.Middle:&lt;/code&gt;居中对齐&lt;/p&gt;

&lt;p&gt;​ &lt;code&gt;sap.ui.core.VerticalAlign.Top:&lt;/code&gt;顶部对齐&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;cells:&lt;/code&gt;行包含的cells，每一个cell都是&lt;code&gt;sap.ui.core.Control&lt;/code&gt;对象，从而开发人员可以根据需要选择合适的控件，灵活度很高。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt; &amp;lt;ObjectIdentifier text=&amp;quot;{ID}&amp;quot;&amp;gt;&amp;lt;/ObjectIdentifier&amp;gt; : cell元素。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;主题设置&#34;&gt;主题设置&lt;/h3&gt;

&lt;p&gt;​    SAPUI5 默认提供了一些主题，并在组件添加新的主题。&lt;/p&gt;

&lt;p&gt;​        - Blue crystal (常用)&lt;/p&gt;

&lt;p&gt;​        - Platium&lt;/p&gt;

&lt;p&gt;​        - Gold Reflection (常用)&lt;/p&gt;

&lt;p&gt;​        - High Contast Black&lt;/p&gt;

&lt;p&gt;​        - Belize (常用)    - …&lt;/p&gt;

&lt;p&gt;​    设置主题：&lt;/p&gt;

&lt;p&gt;​        1.在Header中设置 : &lt;code&gt;data-sap-ui-theme=&amp;quot;sap_bluecrystal&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​        2.在程序中设定样式 :&lt;code&gt;sap.ui.getCore().applyTheme(sThemeName, sThemeBaseUrl?)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;文件模块介绍&#34;&gt;文件模块介绍&lt;/h3&gt;

&lt;h4 id=&#34;index&#34;&gt;Index&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;&amp;lt;script id=&amp;quot;sap-ui-bootstrap&amp;quot;
        src=&amp;quot;https://openui5.hana.ondemand.com/resources/sap-ui-core.js&amp;quot;
        data-sap-ui-theme=&amp;quot;sap_belize&amp;quot;
        data-sap-ui-libs=&amp;quot;sap.m&amp;quot;
        data-sap-ui-compatVersion=&amp;quot;edge&amp;quot;
        data-sap-ui-preload=&amp;quot;async&amp;quot;
        data-sap-ui-bindingSyntax = &amp;quot;complex&amp;quot;
        data-sap-ui-resourceroots = &#39;{&amp;quot;sFileSourceName&amp;quot;:&amp;quot;oURL&amp;quot;}&#39;&amp;gt;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;​   src : 核心资源的加载路径。&lt;/p&gt;

&lt;p&gt;​   data-sap-ui-theme : 设置主题&lt;/p&gt;

&lt;p&gt;​   data-sap-ui-libs : 选择文件默认加载的库文件&lt;/p&gt;

&lt;p&gt;​   data-sap-ui-compatVersion : edge兼容模式，为了方便使用新功能&lt;/p&gt;

&lt;p&gt;​   data-sap-ui-preload : async 设置文件加载形式为异步加载&lt;/p&gt;

&lt;p&gt;​   data-sap-ui-bindingSyntax : 数据绑定的设置 complex复杂绑定，对绑定数据进行计算。&lt;/p&gt;

&lt;p&gt;​   data-sap-ui-resourceroots : 命名文件的根目录，声明资源文件位置&lt;/p&gt;

&lt;p&gt;​   data-sap-ui-onInit=&amp;ldquo;module:sNameSpace/index&amp;rdquo; : 定义初始化时加载的初始页面文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSP&#34;&gt;&amp;lt;script&amp;gt;
    sap.ui.localResources(&amp;quot;ui5mvc&amp;quot;);
    var app = new sap.m.App({initialPage:&amp;quot;idmain1&amp;quot;});
    var view = sap.ui.view({
        id:&amp;quot;idmain1&amp;quot;, 
        viewName:&amp;quot;ui5mvc.main&amp;quot;, 
        type:sap.ui.core.mvc.ViewType.JS});
    app.addPage(view);
    app.placeAt(&amp;quot;content&amp;quot;);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sap.ui.localResources(&amp;quot;filename&amp;quot;)&lt;/code&gt; : 将当前目录下的FILE文件夹注册为当前文件夹，程序会在该文件夹下查找&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;View和Controller代码。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;sap.m.App&lt;/code&gt; : 是SAP移动APP的root element,提供导航功能，并将一些header标签加到HTML页。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;sap.ui.view&lt;/code&gt; : 定义一个view,ID,name,type来指定显示的View。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​                                  &lt;code&gt;sap.ui.xmlview&lt;/code&gt;可直接定义xml类型View。View type:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sap.ui.core.mvc.ViewType.JS       &amp;ldquo;JS&amp;rdquo;&lt;/li&gt;
&lt;li&gt;sap.ui.core.mvc.ViewType.XML    &amp;ldquo;XML&amp;rdquo;&lt;/li&gt;
&lt;li&gt;sap.ui.core.mvc.ViewType.JSON    &amp;ldquo;JSON&amp;rdquo;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sap.ui.core.mvc.ViewType.HTML   &amp;ldquo;HTML&amp;rdquo;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;app.placeAt()&lt;/code&gt; : 该方法将控件放到指定的div中。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;view&#34;&gt;View&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;view.js&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;sap.ui.jsview(&amp;quot;ui5mvc.main&amp;quot;, {
    getControllerName : function() {
        return &amp;quot;ui5mvc.main&amp;quot;;
    },
    createContent : function(oController) {
        var oShell = new sap.ui.ux3.Shell();// Create Shell

        oShell.addWorksetItem(new sap.ui.ux3.NavigationItem({
            key : &amp;quot;btn&amp;quot;,
            text : &amp;quot;Button&amp;quot;
        }));// Add Navigation item

        oShell.addWorksetItem(new sap.ui.ux3.NavigationItem({
            key : &amp;quot;tf&amp;quot;,
            text : &amp;quot;Textfield&amp;quot;
        }));

        oShell.addWorksetItem(new sap.ui.ux3.NavigationItem({
            key : &amp;quot;xml&amp;quot;,
            text : &amp;quot;XMLView&amp;quot;
        }));

        var mContent = {}; // map holding shell content
        mContent.btn = new sap.ui.commons.Button({
            text : &amp;quot;Hello World&amp;quot;
        });

        mContent.tf = new sap.ui.commons.TextField();
        oShell.attachWorksetItemSelected(function(evt) {
            var key = evt.getParameter(&amp;quot;key&amp;quot;);
            oShell.setContent(mContent[key]);
        });// Add WorksetItem Selected event

        mContent.xml = sap.ui.view({
            viewName : &amp;quot;ui5mvc.XML&amp;quot;,
            type : sap.ui.core.mvc.ViewType.XML
        });
    
        oShell.setContent(mContent.btn);//initial content
        return oShell;
    }
 });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;getControllerName&lt;/code&gt;: 函数用于返回 controller name&lt;/p&gt;

&lt;p&gt;&lt;code&gt;createContent&lt;/code&gt;: 函数用于返回页面上要显示的元素&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;view.xml&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-XML&#34;&gt;&amp;lt;core:View xmlns:core=&amp;quot;sap.ui.core&amp;quot;
    xmlns:mvc=&amp;quot;sap.ui.core.mvc&amp;quot; xmlns=&amp;quot;sap.m&amp;quot; controllerName=&amp;quot;ui5mvc.XML&amp;quot;
    mlns:html=&amp;quot;http://www.w3.org/1999/xhtml&amp;quot;&amp;gt;
    &amp;lt;html:h1&amp;gt;My first XML-Header&amp;lt;/html:h1&amp;gt;
    &amp;lt;Panel&amp;gt;
        &amp;lt;Button press=&amp;quot;.sayHello&amp;quot; text=&amp;quot;Say Hello&amp;quot;&amp;gt;&amp;lt;/Button&amp;gt;
    &amp;lt;/Panel&amp;gt;
&amp;lt;/core:View&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;​       空的的namespace设定 : xmlns = &amp;ldquo;sap.m&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;​       命名的namespace设定 : xmlns:mvc = &amp;ldquo;sap.ui.core.mvc&amp;rdquo;. mvc标签指代&lt;code&gt;sap.ui.core.mvc&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;申明namespace: &lt;code&gt;xmlns:t=&amp;quot;sap.ui.table&amp;quot;&lt;/code&gt;。xml中就可以表示为&lt;code&gt;&amp;lt;t:Table&amp;gt; ... &amp;lt;/t:Table&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果属性是简单类型，可以直接作为atrribute的方式来申明，如Table的width属性、title属性&lt;/li&gt;
&lt;li&gt;如果属性是Aggregation和Association，则使用子标签，如Column的Label，是&lt;code&gt;sap.m.Label&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;绑定的语法稍有差异。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;视图模型可以包含分配给控件的任何配置选项，以绑定属性。&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;一个 ” . ”在格式化程序名称前面表示在当前视图的控制器中查找该函数&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;xmlView 聚合绑定&lt;/p&gt;

&lt;p&gt;​   1）xmlview中对需要动态显示的部分不作声明&lt;/p&gt;

&lt;p&gt;​   2）在controller中定义factory function，实现控件的绑定和动态加载。&lt;/p&gt;

&lt;h4 id=&#34;controller&#34;&gt;Controller&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;系统生成的文件&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;sap.ui.controller(&amp;quot;ui5mvc.XML&amp;quot;, {
// onInit: function() {
//      
// },

// onBeforeRendering: function() {
//
// },

// onAfterRendering: function() {
//
// },

// onExit: function() {
//
// }

sayHello : function() {
    sap.ui.commons.MessageBox.show(&amp;quot;Hello World&amp;quot;);
}
});
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;通过模块定义&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;sap.ui.define(
    [&amp;quot;Dependencies1&amp;quot;,&amp;quot;Dependencies2&amp;quot;,&amp;quot;formatter&amp;quot;],
    function(Controller,formatter){
    &amp;quot;use strict&amp;quot;;
        return Controller.extend(&amp;quot;ControllerName&amp;quot;,{
            formatter:formatter,
            
            onInit:function(){},
               onBeforeRendering:function(){},
               onAfterRendering:function(){},
               onExit:function(){}
        });
    }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;生命周期：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​           Start  &amp;ndash;&amp;gt;  视图和控制器被实例化  &amp;ndash;&amp;gt;  控制器被加载(存在控制器) &amp;ndash;&amp;gt;  onInit  &amp;ndash;&amp;gt;  onBeforeRendering  &amp;ndash;&amp;gt;&lt;/p&gt;

&lt;p&gt;​       视图被渲染  &amp;ndash;&amp;gt;  onAfterRendering  &amp;ndash;&amp;gt;  onExit  &amp;ndash;&amp;gt;  END(视图和控制器被销毁)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;onInit : 当视图被实例化并且其控件已经创建时调用。用于在显示前修改视图，绑定事件处理程序并执行其他一次性初始化任务。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;onExit : 视图退出时调用。用于释放资源并完成任务。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;onAfterRendering : 当视图被渲染时调用;是HTML的一部分。用于执行HTML的后续操作，SAPUI5控制在渲染后访问此钩子。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;onBeforeRendering : 在控制器视图重新呈现之前调用，不在第一次呈现之前调用。用于在其中调用第一个渲染前的钩子。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;控制器只是将加载的格式化程序函数存储在本地属性格式化程序中，以便能够在视图中访问它们。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;model&#34;&gt;Model&lt;/h4&gt;

&lt;p&gt;应用程序数据&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;客户端 JSON model、XML model、Resource model&lt;/li&gt;
&lt;li&gt;服务端 oData model&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;resource&#34;&gt;Resource&lt;/h4&gt;

&lt;p&gt;三种方法声明文件位置：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sap.ui.localResources()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​ sap.ui.localResources(&amp;ldquo;foldle.foldle&amp;rdquo;);&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;jQuery.sap.registerModulePath()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​ jQuery.sap.registerModulePath(sModuleNamePrefix, sURL);&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;bootstrap声明 : &lt;code&gt;data-sap-ui-resourceroots = &#39;{&amp;quot;sName&amp;quot;:&amp;quot;oURL&amp;quot;}&#39;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;变更位置后需要修改系统自动生成的文件名称。&lt;/p&gt;

&lt;p&gt;Component&lt;/p&gt;

&lt;p&gt;Component.js通过调用manifest.json的配置信息，完成初始化调用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;sap.ui.define([
        &amp;quot;sap/ui/core/UIComponent&amp;quot;,
        &amp;quot;sap/ui/model/resource/ResourceModel&amp;quot;,
        &amp;quot;sap/ui/model/json/JSONModel&amp;quot;
        
    ], function (UIComponent, ResourceModel, JSONModel) {
    &amp;quot;use strict&amp;quot;;

    return UIComponent.extend(&amp;quot;webapp.Component&amp;quot;, {
        //metadata
        metadata: {
            manifest: &amp;quot;json&amp;quot;
         },

        init : function () {
            // call the base component&#39;s init function
            UIComponent.prototype.init.apply(this, arguments);

            // create the views based on the url/hash
            this.getRouter().initialize();
        }
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;application-descriptor&#34;&gt;Application Descriptor&lt;/h4&gt;

&lt;p&gt;​   manifest.json配置应用程序的相关信息。被称为Application Descriptor。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;sap.app&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;包含特定于应用程序的属性&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ID(强制)：应用程序组件的命名空间，唯一的，必须与组件的空间名称对应&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;type：定义我们想要配置的内容，例如：应用程序&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;i18n：定义资源包文件的路径&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;title：应用程序资源包中引用的句柄语法中的应用程序标题&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;description：简短说明文本应用程序在应用程序资源包中引用的句柄语法中的作用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;applicationVersion：应用程序的版本，以便以后可以轻松更新应用程序&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;sap.ui&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;提供以下UI属性&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;technology：此值指定UI技术; 在我们的例子中，我们使用SAPUI5&lt;/li&gt;
&lt;li&gt;deviceTypes：告诉应用程序支持哪些设备：台式机，平板电脑，手机（默认情况下均为true）&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;sap.ui5&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;该 sap.ui5 namespace添加SAPUI5自动处理的SAPUI5特定配置参数。最重要的参数是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;rootView：如果指定此参数，组件将自动实例化视图并将其用作此组件的根&lt;/li&gt;
&lt;li&gt;dependencies：这里我们声明应用程序中使用的UI库&lt;/li&gt;
&lt;li&gt;models：在描述符的这一部分中，我们可以定义在应用程序启动时由SAPUI5自动实例化的模型。在这里，我们现在可以定义本地资源包。我们将模型“i18n”的名称定义为键，并按名称空间指定包文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;资源包文件&#34;&gt;资源包文件&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;sap.app设置资源包文件的路径和文件名。使用的相对于 &lt;code&gt;manifest.json&lt;/code&gt; 文件的相对路径。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;sap.app&amp;rdquo;: {
    &amp;ldquo;_version&amp;rdquo;: &amp;ldquo;1.1.0&amp;rdquo;,
    &amp;ldquo;id&amp;rdquo;: &amp;ldquo;resource&amp;rdquo;,
    &amp;ldquo;type&amp;rdquo;: &amp;ldquo;application&amp;rdquo;,
    &amp;ldquo;i18n&amp;rdquo;: &amp;ldquo;i18n/i18n.properties&amp;rdquo;,
    &amp;hellip;&lt;/p&gt;

&lt;p&gt;},&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;sap.ui5中models设置名称为 i18n 的 &lt;strong&gt;resource model&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;sap.ui5&amp;rdquo;: {&lt;br /&gt;
   &amp;hellip;
   &amp;ldquo;models&amp;rdquo;: {
       &amp;hellip;
       &amp;ldquo;i18n&amp;rdquo;: {
           &amp;ldquo;type&amp;rdquo;: &amp;ldquo;sap.ui.model.resource.ResourceModel&amp;rdquo;,
           &amp;ldquo;settings&amp;rdquo;: {
               &amp;ldquo;bundleName&amp;rdquo;: &amp;ldquo;webapp.i18n.i18n&amp;rdquo;
               }
     }&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;bundleName&lt;/code&gt; 后面是根据 index.html文件的 &lt;strong&gt;resource roots&lt;/strong&gt; 设置的相对路径。然后在代码中添加对 ResourceBundle 的依赖后，通过 &lt;code&gt;{i18n&amp;gt;xxx}&lt;/code&gt; 实现绑定。&lt;/p&gt;

&lt;h5 id=&#34;models&#34;&gt;Models&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;sap.app设置资源包文件的路径和文件名。使用的相对于 &lt;code&gt;manifest.json&lt;/code&gt; 文件的相对路径。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;   &amp;quot;sap.app&amp;quot;: {
       ...
       &amp;quot;dataSources&amp;quot;: {
           &amp;quot;mainService&amp;quot;: {
               &amp;quot;uri&amp;quot;: &amp;quot;./service/data.json&amp;quot;,
               &amp;quot;type&amp;quot;: &amp;quot;JSON&amp;quot;
           }
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;sap.ui5的&lt;code&gt;models&lt;/code&gt;没有指定名称的 model，当 view 中数据绑定时，没有给出前缀的时候，就参照到这个 model。使用sap.app中设置的dataSource.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;   &amp;quot;sap.ui5&amp;quot;: {
           ...
           &amp;quot;models&amp;quot;: {
               &amp;quot;&amp;quot;: {
                   &amp;quot;dataSource&amp;quot;: &amp;quot;mainService&amp;quot;
                },
           ...
           }
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;root-view&#34;&gt;Root View&lt;/h5&gt;

&lt;p&gt;​   Root view (启动即显示的 view)：类型为 xml，名称为 App。OpenUI5 在相应文件夹下面查找名为 &lt;code&gt;App.view.xml&lt;/code&gt; 文件并加载。通过这种方式，实现了 root view 的配置化.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;sap.ui5&amp;rdquo;: {
      &amp;ldquo;_version&amp;rdquo;: &amp;ldquo;1.1.0&amp;rdquo;,
      &amp;ldquo;rootView&amp;rdquo;: {
          &amp;ldquo;viewName&amp;rdquo;: &amp;ldquo;webapp.view.App&amp;rdquo;,
          &amp;ldquo;type&amp;rdquo;: &amp;ldquo;XML&amp;rdquo;
      }&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;​   启动流程 :&lt;/p&gt;

&lt;p&gt;​   1) &lt;code&gt;index.html&lt;/code&gt; 的 &lt;code&gt;ComponentContainer&lt;/code&gt; 根据 &lt;code&gt;name&lt;/code&gt; 或 &lt;code&gt;component&lt;/code&gt; 属性实例化 Component。&lt;/p&gt;

&lt;p&gt;​   2) Component 的 &lt;code&gt;metadata&lt;/code&gt; 指向设定的 &lt;code&gt;manifest.json&lt;/code&gt; 文件。&lt;/p&gt;

&lt;p&gt;​   3) &lt;code&gt;manifest.json&lt;/code&gt; 文件的 &lt;code&gt;sap.ui5&amp;gt;rootView&lt;/code&gt; 设定了启动时候加载并显示的 root view 为 &lt;code&gt;App.view.xml&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;​   4) App view 并不需要像之前文章介绍的内嵌 master view 和 detail view，而是由路由器根据路径在 pattern 中找匹配的模式，在 target 中找对应的 view 加载。&lt;/p&gt;

&lt;h5 id=&#34;routing设置&#34;&gt;Routing设置&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;&amp;quot;sap.ui5&amp;quot;: {
        ...
        &amp;quot;routing&amp;quot;: {
            &amp;quot;config&amp;quot;: {
                &amp;quot;routerClass&amp;quot;: &amp;quot;sap.m.routing.Router&amp;quot;,
                &amp;quot;viewType&amp;quot;: &amp;quot;XML&amp;quot;,
                &amp;quot;viewPath&amp;quot;: &amp;quot;webapp.view&amp;quot;,
                &amp;quot;controlId&amp;quot;: &amp;quot;app&amp;quot;,
                &amp;quot;controlAggregation&amp;quot;: &amp;quot;pages&amp;quot;,
                &amp;quot;bypassed&amp;quot;: {
                    &amp;quot;target&amp;quot;: &amp;quot;notFound&amp;quot;
                }
            },
            &amp;quot;routes&amp;quot;: [{
                &amp;quot;pattern&amp;quot;: &amp;quot;&amp;quot;,
                &amp;quot;name&amp;quot;: &amp;quot;master&amp;quot;,
                &amp;quot;target&amp;quot;: &amp;quot;master&amp;quot;
            },
            {
                &amp;quot;pattern&amp;quot;: &amp;quot;detail/{supplierPath}&amp;quot;,
                &amp;quot;name&amp;quot;: &amp;quot;detail&amp;quot;,
                &amp;quot;target&amp;quot;: &amp;quot;detail&amp;quot;
            }],
            &amp;quot;targets&amp;quot;: {
                &amp;quot;master&amp;quot;: {
                    &amp;quot;viewName&amp;quot;: &amp;quot;Master&amp;quot;,
                    &amp;quot;viewLevel&amp;quot;: 1
                },
                &amp;quot;detail&amp;quot;: {
                    &amp;quot;viewName&amp;quot;: &amp;quot;Detail&amp;quot;,
                    &amp;quot;viewLevel&amp;quot;: 2
                },
                &amp;quot;notFound&amp;quot;: {
                    &amp;quot;viewName&amp;quot;: &amp;quot;NotFound&amp;quot;,
                    &amp;quot;viewId&amp;quot;: &amp;quot;notFound&amp;quot;
                }
            }
        }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;多语言&#34;&gt;多语言&lt;/h4&gt;

&lt;p&gt;在 SAPUI5 中，通过两种方法来实现多语言.&lt;/p&gt;

&lt;p&gt;​   (1) SAPUI5 提供 Resource Model，Resource Model 读取资源包 (Resource Bundle) 并与 View 中的控件绑定。&lt;/p&gt;

&lt;p&gt;​   (2) 使用 jQuery.sap.resources 相关的 API 读取资源包。两种方法都需要资源包文件并且在配置中设置。&lt;/p&gt;

&lt;h5 id=&#34;语言代码&#34;&gt;语言代码&lt;/h5&gt;

&lt;p&gt;​   OpenUI5 对页面的显示，有一个 &lt;strong&gt;当前语言( Current Language )&lt;/strong&gt; 的概念，按照当前语言，读取相应的资源包文件，按当前语言显示。OpenUI5 按照如下顺序顺序(从高到低)，如果都没有找到，最后读取通用设置（比如 i18n.properties)。&lt;/p&gt;

&lt;p&gt;​   &lt;code&gt;sap.ui.getCore().getConfiguration().getLanguage()&lt;/code&gt; 获得当前语言。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;1) URL中的 locale 参数（即在 url 后面加上 &lt;code&gt;?sap-ui-language=en&lt;/code&gt; )&lt;/p&gt;

&lt;p&gt;2) 应用程序代码的 locale 设置，sap.ui.getCore().getConfiguration().applySettings({ language: &amp;lsquo;de&amp;rsquo;});&lt;/p&gt;

&lt;p&gt;3) Android 平台的用户代理字符串设置&lt;/p&gt;

&lt;p&gt;4) 浏览器的一般语言设置，可以用 window.navigator.language 查看&lt;/p&gt;

&lt;p&gt;5) 浏览器中用户语言配置。这个与浏览器相关，比如 IE 通过 window.navigator.userLanguage 查看。&lt;/p&gt;

&lt;p&gt;6) 浏览器语言配置。这个业余浏览器相关，比如 IE 通过 window.navigator.browserLanguage 查看&lt;/p&gt;

&lt;p&gt;7) OpenUI5中硬编码，默认为 en&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;资源包文件-1&#34;&gt;资源包文件&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;Java的属性文件，文件的扩展名总是.properties。文件中包含于语言相关的文本。&lt;/li&gt;
&lt;li&gt;文件名包括固定部分和语言相关部分。那么 i18n.properties 是默认的文件，i18n_zh_CN.properties 是中文简体的资源文件。&lt;/li&gt;
&lt;li&gt;资源包文件为扁平结构，不能嵌套。每一行要么是 key-value键值对 ，要么是 # 开头的注释。也可以可以空行。&lt;/li&gt;
&lt;li&gt;如果 Properties 文件的文本为 Unicode 字符，文件使用16进制的编码来存储，而不是明文。&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;resource-model&#34;&gt;Resource Model&lt;/h5&gt;

&lt;p&gt;​   使用 Resource Model 绑定数据需要三步：&lt;/p&gt;

&lt;p&gt;​   1) 添加资源包文件，将不同的语言放在不同的资源包文件中。&lt;code&gt;i18n.properties,i18n_zh_CN.properties&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​   2) 在 Component.js 文件中，创建 Resource model 的实例 。&lt;/p&gt;

&lt;p&gt;​   3) 在 View 中参照 Resource Model 中定义的 key。 &lt;code&gt;title=&amp;quot;{i18n&amp;gt;masterTitle}&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​    url 后面添加&lt;code&gt;?sap-ui-language=XXX&lt;/code&gt;，实现语言的切换。&lt;/p&gt;

&lt;h5 id=&#34;jquery-sap-resources&#34;&gt;jQuery.sap.resources&lt;/h5&gt;

&lt;p&gt;​   在代码中直接使用资源包的文本。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;var sLocale = sap.ui.getCore().getConfiguration().getLanguage();//获取当前语言
var oBd = jQuery.sap.resources({
    url: &amp;quot;i18n/i18n.properties&amp;quot;,
    locale: sLocale
})                                       //根据指定的 URL 和 Locale，创建一个新的资源包实例
var sMeg = oBd.getText(&amp;quot;key&amp;quot;,[sLocale]); //根据资源包文件的 key，获取与语言相关的 value。

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;layout设置&#34;&gt;Layout设置&lt;/h2&gt;

&lt;h3 id=&#34;多页面显示和跳转&#34;&gt;多页面显示和跳转&lt;/h3&gt;

&lt;p&gt;​   sap.m.App : 是一个全局对象，可以通过 app.to(sPageId) 跳转到另一个页面。&lt;/p&gt;

&lt;p&gt;​       to(sPageId, sTransitionName&lt;em&gt;?&lt;/em&gt;, oData&lt;em&gt;?&lt;/em&gt;, oTransitionParameters&lt;em&gt;?&lt;/em&gt;): [sap.m.NavContainer]&lt;/p&gt;

&lt;p&gt;​   app.back()则跳回到刚才的page：&lt;/p&gt;

&lt;p&gt;​       back(oBackData&lt;em&gt;?&lt;/em&gt;, oTransitionParameters&lt;em&gt;?&lt;/em&gt;): [sap.m.NavContainer]&lt;/p&gt;

&lt;p&gt;​   &lt;code&gt;sap.m.Page&lt;/code&gt;中，&lt;code&gt;showNavButton&lt;/code&gt;设置为&lt;code&gt;true&lt;/code&gt;，就会出现Navigation按钮，点击按钮的event hander通过Controller中&lt;code&gt;onNavPress&lt;/code&gt;函数来实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    var oDetailPage = new sap.m.Page({
        showNavButton: true,
        navButtonPress: [oController.onNavPress, oController],
        title: &amp;quot;供应商明细&amp;quot;,
        content: [oObjectHeader]
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;​   &lt;code&gt;sap.m.ColumnListItem&lt;/code&gt;的type必须为Navigation，否则不能实现跳转。&lt;code&gt;sap.m.ColumnListItem&lt;/code&gt;的press属性设置为一个数组，这种方法能够保证在Controller中，this表示Controller本身，而不是某个控件。&lt;/p&gt;

&lt;h3 id=&#34;布局类型&#34;&gt;布局类型&lt;/h3&gt;

&lt;p&gt;​   sap.ui.layout.HorizontalLayout() : 水平布局&lt;/p&gt;

&lt;p&gt;​   sap.ui.layout.VerticalLayout() : 垂直布局&lt;/p&gt;

&lt;p&gt;​   sap.ui.layout.Grid() : 表格式布局&lt;/p&gt;

&lt;h4 id=&#34;grid-layout&#34;&gt;Grid Layout&lt;/h4&gt;

&lt;p&gt;​   Grid Layout 控件负责将页面进行表格式布局，将页面分为 12 列，子控件从左至右排列。每个控件并不是占一列，OpenUI5 根据屏幕的大小，将屏幕分为 4 种，分别是&lt;code&gt;XL: extra large 、 L: large、M: medium、S: small&lt;/code&gt;。XL的如 PC 机的大桌面，L的如 PC 的桌面，M的比如平板，S的比如手机。默认情况下，每个控件在 XL 桌面上占 3 列，在 L 桌面上占 3 列，在 M 桌面上占 6 列，在 S 桌面上占 12 列。OpenUI5 用一个字符串表示为&lt;code&gt;XL3 L3 M6 S12&lt;/code&gt;，通过 default Span 属性来设置。&lt;/p&gt;

&lt;p&gt;​    当屏幕的尺寸变更的时候，OpenUI5 检测到尺寸的变化，根据上面的 4 个分类对控件的位置进行调整，从而实现所谓的自适应。&lt;/p&gt;

&lt;p&gt;​    Grid layout 控件宽度 (Width)，可以基于像素，或者基于页面宽度的相对比例。控件之间的间距可以通过 vSpacing 和 hSpacing 属性进行设置。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.ui.layout&lt;/code&gt; : 该function可以对Layout页面布局进行设置。&lt;/p&gt;

&lt;p&gt;​       &lt;code&gt;new sap.ui.layout.Grid({ content: [ a1,b1,c1,d1] }).placeAt(&amp;quot;content&amp;quot;);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​    将各个空间放到Layout.Grid中，然后将该Grid放到页面指定位置上。&lt;/p&gt;

&lt;h3 id=&#34;layoutdata-属性&#34;&gt;LayoutData 属性&lt;/h3&gt;

&lt;p&gt;​      &lt;code&gt;sap.ui.core.Element&lt;/code&gt; 类定义了&lt;code&gt;layoutData&lt;/code&gt; 属性、&lt;code&gt;getLayoutData()&lt;/code&gt; 方法和&lt;code&gt;setLayoutData()&lt;/code&gt; 方法。控件都是 &lt;code&gt;sap.ui.core.Element&lt;/code&gt; 类的间接子类，从而控件都可以利用这些属性和方法设定这个控件在页面中如何定位。&lt;code&gt;setLayoutData()&lt;/code&gt; 方法的参数是&lt;code&gt;sap.ui.core.LayoutData&lt;/code&gt; 对象。 Grid 布局时&lt;code&gt;layoutData&lt;/code&gt; 我们可以用&lt;code&gt;sap.ui.core.LayoutData&lt;/code&gt; 类的子类 &lt;code&gt;sap.ui.layout.GridData&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSP&#34;&gt;var oLabel2 = new sap.m.Label({
   text : &amp;quot;XXXXXXXXXXXXXXXXXXX&amp;quot;,
   layoutData : new sap.ui.layout.GridData({
     span : &amp;quot;XL12 L12 M12 S12&amp;quot;       //通过该设置让该元素独占屏幕元素的一整行
   })
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;margin-classes&#34;&gt;Margin Classes&lt;/h4&gt;

&lt;p&gt;​   在class属性中设置了四种标准的大小: tiny-8px、small-16px、medium-32px、large-48px， Begin is left and End is right。&lt;/p&gt;

&lt;p&gt;在 div 的 class 属性中添加对应的属性值来解决边距问题。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Full Margins : all around control&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;sapUiTinyMargin&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sapUiSmallMargin&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sapUiMediumMargin&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sapUiLargeMargin&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Single-sided margins : class中只能设定一个边框距离&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;sapUixxxxMarginTop&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sapUixxxxMarginBottom&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sapUixxxxMarginBegin&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sapUixxxxMarginEnd&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Two-Sided Margins : 两个方向&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;sapUiTinyMarginBeginEnd&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sapUiTinyMarginTopBottom&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Responsive Margins : margins depending on the screen width&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;sapUiResponsiveMargin&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;Panel headerText=&#34;{i18n&gt;helloPanelTitle}&amp;rdquo;
      class=&amp;ldquo;sapUiResponsiveMargin&amp;rdquo;
      width=&amp;ldquo;auto&amp;rdquo;&amp;gt;
&lt;/Panel&gt;&lt;/p&gt;

&lt;p&gt;&lt;body class=&#34;sapUiBody sapUiResponsiveMargin&#34; role=&#34;application&#34;&gt;&lt;/p&gt;

&lt;p&gt;​      &lt;div id=&#34;content&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;/body&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;100%宽度控制&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果控件包含有&lt;code&gt;width&lt;/code&gt;属性，设置该属性为&lt;code&gt;width=auto&lt;/code&gt;.如果没有该属性，可以添加 sapUiForceWidthAuto属性到控件的class.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;移除Margins&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sapUiNoMarginTop&lt;/li&gt;
&lt;li&gt;sapUiNoMarginBottom&lt;/li&gt;
&lt;li&gt;sapUiNoMarginBegin&lt;/li&gt;
&lt;li&gt;sapUiNoMarginEnd
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;自定义css和主题颜色&#34;&gt;自定义CSS和主题颜色&lt;/h4&gt;

&lt;p&gt;​   不要在自定义CSS中指定颜色，而是使用标准的主题依赖类。&lt;/p&gt;

&lt;h3 id=&#34;对象组件显示&#34;&gt;对象组件显示&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;组件&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;sap.m.ObjectIdentifier:&lt;/code&gt; 用于需要对操作对象进行明确区分的时候，使用这个组件进行显示。强调的是标识。                title属性是主要标识，text属性是补充，如果titleActive为true，则标题用颜色标识.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.ObjectNumber:&lt;/code&gt; 显示数字,能根据不同的状态提供颜色区分。有四种state: Warning, Error, Success,Default.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.ObjectMarker:&lt;/code&gt; 以图标的方式显示预定义的几种类型，可以绑定press事件。包括 [Flagged、Favorite、Draft&lt;/p&gt;

&lt;p&gt;、Locked、LockedBy、Unsaved、UnsavedBy].&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.ObjectAttribute:&lt;/code&gt; 显示对象，并提供普通和active两种状态，active状态可与事件绑定。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.ObjectStatus:&lt;/code&gt; 显示对象的文本，并且根据状态不同，文本以不同的颜色区分。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.ObjectHeader:&lt;/code&gt; 显示对象，包括标识和附加的信息，图标等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;dialogs-and-fragments&#34;&gt;Dialogs and Fragments&lt;/h2&gt;

&lt;h3 id=&#34;fragments&#34;&gt;Fragments&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;片段是一个轻量级的Ui部分，它只是一组重用控件的容器。包含一到多个控件，不需要控制器。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;定义并调用已存在的 Fragments : &amp;ldquo;sap/ui/core/Fragment&amp;rdquo;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1) 定义xxx.fragment.xml&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;   &amp;lt;core:FragmentDefinition xmlns=&amp;quot;sap.m&amp;quot; xmlns:core=&amp;quot;sap.ui.core&amp;quot;&amp;gt;
    &amp;lt;Dialog id=&amp;quot;helloDialog&amp;quot; title=&amp;quot;Hello {/recipient/name}&amp;quot;&amp;gt;
        &amp;lt;content&amp;gt;
            &amp;lt;core:Icon src=&amp;quot;sap-icon://hello-world&amp;quot; size=&amp;quot;80px&amp;quot; class=&amp;quot;sapUiMediumMargin&amp;quot;&amp;gt;                   &amp;lt;/core:Icon&amp;gt;
        &amp;lt;/content&amp;gt;
        &amp;lt;beginButton&amp;gt;
            &amp;lt;Button text=&amp;quot;{i18n&amp;gt;dialogCloseButtonText}&amp;quot; press=&amp;quot;.onCloseDialog&amp;quot;&amp;gt;&amp;lt;/Button&amp;gt;
        &amp;lt;/beginButton&amp;gt;
    &amp;lt;/Dialog&amp;gt;
   &amp;lt;/core:FragmentDefinition&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;   // create dialog lazily
   if (!this.byId(&amp;quot;helloDialog&amp;quot;)) {  //如果id为helloDialog的Dialog不存在
    // load asynchronous XML fragment
    Fragment.load({
        id: oView.getId(),
        name: &amp;quot;sap.ui.demo.walkthrough.view.HelloDialog&amp;quot;,
             controller:this    //函数的回调
    }).then(function (oDialog) {
        // connect dialog to the root view of this component (models, lifecycle)
        oView.addDependent(oDialog);
        oDialog.open();
    });
   } else {
    this.byId(&amp;quot;helloDialog&amp;quot;).open();
   },
      
   onCloseDialog:function(){
       this.byId(&amp;quot;helloDialog&amp;quot;).close();
   }
   
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;始终使用addDependent方法将对话框连接到视图的生命周期管理和数据绑定，即使它未添加到其UI树中。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果片段中的对话框尚不存在，则通过使用以下方法调用sap.ui.xmlfragment方法来实例化片段&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;回调open方法&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;dialog&#34;&gt;Dialog&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;不属于特定视图，不能将其定义为视图，这意味着必须在控制器代码中的某处实例化对话框。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重用&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1) 定义单独的控制来实现Dialog的创建 HelloDialog.js&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;   sap.ui.define([
        &amp;quot;sap/ui/base/ManagedObject&amp;quot;, //实现该类
        &amp;quot;sap/ui/core/Fragment&amp;quot;
    ],
    function (ManagedObject, Fragment) {
        &amp;quot;use strict&amp;quot;;
   
    return ManagedObject.extend(&amp;quot;SAPUI5.Walkthrough.controller.HelloDialog&amp;quot;, {
        constructor: function (oView) { //oView参数用于关联当前视图到对话框.
            this._oView = oView;
        },
   
        exit: function () {
            delete this._oView();
        },
   
        open: function () {
            var oView = this._oView;
   
            //create dialog lazily
            if (!oView.byId(&amp;quot;helloDialog&amp;quot;)) {
                var oFragmentController = {
                    onCloseDialog: function () {
                        oView.byId(&amp;quot;helloDialog&amp;quot;).close();
                    }
                };
                //load asynchronous XML fragment
                Fragment.load({
                    id: oView.getId(),
                    name: &amp;quot;SAPUI5.Walkthrough.view.HelloDialog&amp;quot;,
                    controller: oFragmentController
                }).then(function (oDialog) {
                    //connect dialog to the root view of this component (models,lifecycle)
                    oView.addDependent(oDialog);
                    oDialog.open();
                });
            } else {
                oView.byId(&amp;quot;helloDialog&amp;quot;).open();
            }
        }
    });
   });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2) 在Component.js文件中声明该控件为私有属性,并封装其方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;   sap.ui.define([
    &amp;quot;sap/ui/core/UIComponent&amp;quot;,
    &amp;quot;sap/ui/Device&amp;quot;,
    &amp;quot;SAPUI5/Walkthrough/model/models&amp;quot;,
    &amp;quot;sap/ui/model/json/JSONModel&amp;quot;,
    &amp;quot;./controller/HelloDialog&amp;quot;
   ], function (UIComponent, Device, models,JSONModel,HelloDialog) {
    &amp;quot;use strict&amp;quot;;
   
    return UIComponent.extend(&amp;quot;SAPUI5.Walkthrough.Component&amp;quot;, {
   
        metadata: {
            manifest: &amp;quot;json&amp;quot;
        },
   
        /**
         * The component is initialized by UI5 automatically during the startup of the app and calls the init method once.
         * @public
         * @override
         */
        init: function () {
            // call the base component&#39;s init function
            UIComponent.prototype.init.apply(this, arguments);
   
            // enable routing
            this.getRouter().initialize();
   
            // set the device model
            this.setModel(models.createDeviceModel(), &amp;quot;device&amp;quot;);
   
            //set dialog
            this._helloDialog = new HelloDialog(this.getRootControl());
        },
        
        exit:function(){
            this._helloDialog.destory();
            delete this._helloDialog;
        },
        
        openHelloDialog:function(){
            this._helloDialog.open();
        }
    });
   });
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;在按钮事件中通过&lt;code&gt;this.getOwnerComponent().openHelloDialog()&lt;/code&gt;调用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;onOpenDialog方法现在通过调用辅助方法getOwnerComponent来访问其组件。当调用重用对象的open方法时，我们传入当前视图以将其连接到对话框。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Attention&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;将跨多个控制器使用的所有资产放在单独的模块中&lt;/p&gt;

&lt;h2 id=&#34;icons&#34;&gt;Icons&lt;/h2&gt;

&lt;p&gt;sap.ui.core.Icon&lt;/p&gt;

&lt;h2 id=&#34;数据类型和操作&#34;&gt;数据类型和操作&lt;/h2&gt;

&lt;h3 id=&#34;基本数据类型&#34;&gt;基本数据类型&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;​ sap.ui.model.type.Integer(oFormatOptions?, oConstraints?):支持minimum,maximum&lt;/p&gt;

&lt;p&gt;​ sap.ui.model.type.Float(oFormatOptions?, oConstraints?):&lt;code&gt;decimalSeparator&lt;/code&gt;定义小数位的分隔符&lt;/p&gt;

&lt;p&gt;​ sap.ui.model.type.String(&amp;hellip;&amp;hellip;&amp;hellip;)&lt;/p&gt;

&lt;p&gt;​ sap.ui.model.type.Boolean&lt;/p&gt;

&lt;p&gt;​ sap.ui.model.type.Date : ui5支持原数据为JavaScript和原数据为String的日期数据进行格式输出&lt;/p&gt;

&lt;p&gt;​ sap.ui.model.type.Time : Time也支持原数据为Time类型或者字符串类型&lt;/p&gt;

&lt;p&gt;​ sap.ui.model.type.DateTime&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;属性设置&#34;&gt;属性设置&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;尽可能使用数据类型而不是自定义格式化程序。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;   number=&amp;quot;{
    parts: [{path: &#39;invoice&amp;gt;ExtendedPrice&#39;}, {path: &#39;view&amp;gt;/currency&#39;}],
    type: &#39;sap.ui.model.type.Currency&#39;,
    formatOptions: {
        showMeasure: false
    }
   }&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;计算字段绑定(parts)：它允许将来自不同模型的多个属性绑定到控件的单个属性。&lt;/li&gt;
&lt;li&gt;控件的属性是数字，从两个不同模型检索的绑定属性（“部件”）invoice&amp;gt; ExtendedPrice和view&amp;gt; / currency。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;Expression Binding 仅使用表达式绑定进行简单的计算。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;numberState=&amp;quot;{= ${invoice&amp;gt;ExtendedPrice} &amp;gt; 50 ? &#39;Error&#39; : &#39;Success&#39; }&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;数据校验&#34;&gt;数据校验&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;基本使用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​    sap.ui.core.message.MessageManager();&lt;/p&gt;

&lt;p&gt;​    registerObject(oObject,bHandelValidation) : 第一个参数是ManagedObject对象的实例，第二个参数是boolean类型变量，为true时执行数据校验。&lt;/p&gt;

&lt;p&gt;​    attachValidationError(this,function(){}) : 控件都有该方法，用于校验失败时的处理。&lt;/p&gt;

&lt;p&gt;​    attachValidationSuccess(this,function(){}) : 用于校验成功时的处理。&lt;/p&gt;

&lt;p&gt;ValueState 种类:setValueState()&lt;/p&gt;

&lt;p&gt;​    sap.ui.core.ValueState.Error&lt;/p&gt;

&lt;p&gt;​    sap.ui.core.ValueState.None&lt;/p&gt;

&lt;p&gt;​    sap.ui.core.ValueState.Success&lt;/p&gt;

&lt;p&gt;​    sap.ui.core.ValueState.Warning&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;集中处理数据校验:&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;sap.ui.core.Core也可添加attachValidationError().&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;自定义数据类型校验:&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;sap.ui.model.SimpleType.extend()自定义数据类型，可以使用formatValue(),parseValue(),validateValue()实现自定义的校验规则和提示消息。&lt;/p&gt;

&lt;p&gt;抛出异常信息：throw new sap.ui.model.ValidationException(&amp;ldquo;Message&amp;rdquo;);&lt;/p&gt;

&lt;p&gt;截取异常消息，使用该类型的控件通过&lt;code&gt;oEvent.getParameter(&amp;quot;message&amp;quot;)&lt;/code&gt;获取该错误消息。&lt;/p&gt;

&lt;h3 id=&#34;formart设置&#34;&gt;Formart设置&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;在Constructor或绑定方法中定义formatter (绑定单个控件)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;var oText = new sap.m.Text({
        text:{ formatter:function(sValue){
                        return sValue &amp;amp;&amp;amp; sValue.toUpperCase();
                }
        }
     });&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在Controller中定义formatter (更灵活，可重复调用)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;Text text=&#34;{path: &#39;/productname&#39;, formatter: &#39;.toUpper&#39;}&#34;/&gt;&lt;/p&gt;

&lt;p&gt;其中&lt;code&gt;.toUpper&lt;/code&gt; 前面的&lt;code&gt;.&lt;/code&gt;表示当前Controller方法。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在专门模块中定义formatter&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;单独定义formatter在Controller中引入该文件。并在view中调用。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;自定义数据类型中设置formatter&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;搜索与过滤&#34;&gt;搜索与过滤&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;添加搜索框并绑定事件 &lt;code&gt;sap.m.SearchField&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;   &amp;lt;List id=&amp;quot;invoiceList&amp;quot; items=&amp;quot;{invoice&amp;gt;/Invoices}&amp;quot;&amp;gt;
   &amp;lt;headerToolbar&amp;gt;
      &amp;lt;Toolbar&amp;gt;
         &amp;lt;Title text=&amp;quot;{i18n&amp;gt;invoiceListTitle}&amp;quot;/&amp;gt;
         &amp;lt;ToolbarSpacer/&amp;gt;
         &amp;lt;SearchField width=&amp;quot;50%&amp;quot; search=&amp;quot;.onFilterInvoices&amp;quot;/&amp;gt;
      &amp;lt;/Toolbar&amp;gt;
   &amp;lt;/headerToolbar&amp;gt;
      &amp;lt;items&amp;gt;
        &amp;lt;ObjectListItem&amp;gt;
            ,,,,,,
        &amp;lt;/ObjectListItem&amp;gt; 
      &amp;lt;/items&amp;gt;
   &amp;lt;/List&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;事件定义并实现过滤&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;filter对象将保留我们对filter操作的配置。&lt;strong&gt;new sap.ui.model.Filter(vFilterInfo, vOperator?, vValue1?, vValue2?)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;FilterOperator是我们需要的帮助器类型，以指定过滤器，范围。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;   new Filter({
         path: &amp;quot;Price&amp;quot;,
         operator: FilterOperator.BT,
         value1: 11.0,
         value2: 23.0
       });
       
   new Filter({
       filters: [
         ...
         new Filter({
           path: &#39;Quantity&#39;,
           operator: FilterOperator.LT,
           value1: 20
         }),
         new Filter({
           path: &#39;Price&#39;,
           operator: FilterOperator.GT,
           value1: 14.0
         })
         ...
       ],
       and: true|false
     })
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;   onFilterInvoices : function (oEvent) {
    // build filter array
    var aFilter = [];
    var sQuery = oEvent.getParameter(&amp;quot;query&amp;quot;); //&amp;quot;query&amp;quot; 获取搜索字段
    if (sQuery) {
        aFilter.push(new Filter(&amp;quot;ProductName&amp;quot;, FilterOperator.Contains, sQuery)); //添加过滤条件
    }
   
    // filter binding
    var oList = this.byId(&amp;quot;invoiceList&amp;quot;);     //获取List对象
    var oBinding = oList.getBinding(&amp;quot;items&amp;quot;); //获取绑定的items
    oBinding.filter(aFilter);              //根据过滤条件过滤items数据
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;排序与分组&#34;&gt;排序与分组&lt;/h3&gt;

&lt;p&gt;​       &lt;code&gt;new sap.ui.model.Sorter(sPath, bDescending?, vGroup?, fnComparator?)&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;items=&amp;ldquo;{path:&amp;lsquo;invoice&amp;gt;/Invoices&amp;rsquo; sorter:{path:&amp;lsquo;ProductName&amp;rsquo;}}&amp;rdquo;  //默认是升序ascending,可以添加属性descending : true.&lt;/li&gt;
&lt;li&gt;items=&amp;ldquo;{path:&amp;lsquo;invoice&amp;gt;/Invoices&amp;rsquo; sorter:{path:&amp;lsquo;ProductName&amp;rsquo;,group:true}}&amp;rdquo;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;私有函数和变量&#34;&gt;私有函数和变量&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;私有函数和变量应始终以下划线开头。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;消息设置&#34;&gt;消息设置&lt;/h2&gt;

&lt;h3 id=&#34;sap-m-messagebox&#34;&gt;sap.m.MessageBox&lt;/h3&gt;

&lt;p&gt;​    SAPUI5 提供的对话框，可以显示信息、警告、错误等等。MessageBox 类是静态类，在使用之前必须执行 &lt;code&gt;jQuery.sap.require(&amp;quot;sap.m.MessageBox&amp;quot;)&lt;/code&gt; 语句 SAPUI5 包含 jQuery 包，&lt;code&gt;jQuery.sap.require(vModuleName)&lt;/code&gt; 方法的作用是加载指定的模块并且执行，这样 MessageBox 的 show() 方法才能运行。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;sap.m.MessageBox.alert(vMessage, mOptions*?*)&lt;/code&gt;对话框显示消息，有一个OK按钮（“确定”），没有图标&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.MessageBox.confirm(vMessage, mOptions*?*)&lt;/code&gt; 确认对话框，询问是否确定，有一个OK按钮和Cancel按钮，一个问号的图标。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.MessageBox.error(vMessage, mOptions*?*)&lt;/code&gt; 显示错误对话框，带有错误图标和关闭按钮Displays an error dialog with the given message, an ERROR icon, a CLOSE button。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.MessageBox.information(vMessage, mOptions*?*)&lt;/code&gt; 消息对话框，带有INFO图标和OK按钮。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.MessageBox.show(vMessage, mOptions*?*)&lt;/code&gt; 显示对话框，类型为sap.m.DialogType.Message，图标和按钮由开发人员自行定义，相对灵活一些。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.MessageBox.success(vMessage, mOptions*?*)&lt;/code&gt; 显示成功对话框，带有SUCCESS图标和OK按钮。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.MessageBox.warning(vMessage, mOptions*?*)&lt;/code&gt; 显示警告消息，带有WARNING图标和OK按钮。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.MessageToast.show()&lt;/code&gt;对用户操作提供一种简单的反馈，并且经过一段时间后自动消失，除非用户将鼠标放在消息上面。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;模块化&#34;&gt;模块化&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;如何加载模块&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;jQuery.sap.declare(sModuleName,bCreateNamespace)&lt;/code&gt;申明一个模块，以确保模块存在。这个语句必须出现在 模块代码（也就是代码文件)的第一句。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;jQuery.sap.require(vModuleName)&lt;/code&gt;确保当前代码继续之前，所指定的模块被加载和执行。如果所需要的模块没有被加载，将会被同步加载和执行，如果已经加载，就忽略。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.ui.define(sModuleName,aDependencies,vFactory,bExport)&lt;/code&gt;定义module，异步加载依赖模块,sap.ui.define()定义的模块具有全局命名空间。2:定义依赖 3:继承工厂函数。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.ui.require()&lt;/code&gt;异步加载依赖的模块，不具有全局命名空间。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;使用模块方法实现Controller&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;   sap.ui.define(
    [&amp;quot;Dependencies1&amp;quot;,&amp;quot;Dependencies2&amp;quot;],
    function(Controller){
    &amp;quot;use strict&amp;quot;;
        return Controller.extend(&amp;quot;ControllerName&amp;quot;,{
            onInit:function(){},
                  onBeforeRendering:function(){},
                  onAfterRendering:function(){},
                  onExit:function(){}
        });
    }
   );
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;参数1 : 不定义，便于对模块进行访问&lt;/li&gt;
&lt;li&gt;参数2 : 指定依赖的模块，可指定多个&lt;/li&gt;
&lt;li&gt;参数3 : 定义工厂函数，实现Controller功能&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;model-binding&#34;&gt;Model Binding&lt;/h2&gt;

&lt;h3 id=&#34;单数据绑定&#34;&gt;单数据绑定&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;使用数据绑定前，需要先实例化Model.构造函数获取实例的URL或则数据本身作为第一个参数。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​    JSON-Model:&lt;/p&gt;

&lt;p&gt;​        &lt;code&gt;var oModel = new sap.ui.model.json.JSONModel(dataUrlOrData);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​    XML-Model:&lt;/p&gt;

&lt;p&gt;​        &lt;code&gt;var oModel = new sap.ui.model.xml.XMLModel(dataUrlOrData);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​    OData-Model:&lt;/p&gt;

&lt;p&gt;​        &lt;code&gt;var oModel = new sap.ui.model.odata.ODataModel(dataUrl[,userJSON,user,pass]);&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;给Model设置值&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;oModel.setData(data);  绑定定义的数据&lt;/p&gt;

&lt;p&gt;oModel.loadData(&amp;ldquo;models/suppliers.json&amp;rdquo;); 从文件中读取数据绑定&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;将Model分配给Core或则其他的控制器（setModel）方法。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Global model:&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​        &lt;code&gt;sap.ui.getCore().setModel(oModel)&lt;/code&gt; : 这样oModel对整个应用程序可见&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Bind a model to a view&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​       &lt;code&gt;var oView = sap.ui.view({type:sap.ui.core.mvc.ViewType.JS,viewName:&amp;quot;text.view&amp;quot;})&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​     &lt;code&gt;oView.setModel(oModel);&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Bind a model to a specific control&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​        &lt;code&gt;var oTable = sap.ui.getCore().byId(&amp;quot;table&amp;quot;);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​        &lt;code&gt;oTable.setModel(oModel);&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Model属性绑定方法（{ } curly braces，bindProperty()）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​    控件的大多数属性都可以绑定到模型属性。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;bindProperty  method: [extend : sap.ui.base.ManagedObject]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​        &lt;code&gt;oControl.bindProperty(&amp;quot;sName&amp;quot;,&amp;quot;oBindingInfo&amp;quot;);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​            oBindingInfo attributes : path、model、formatter等&lt;/p&gt;

&lt;p&gt;​                path : 指定绑定的数据路径&lt;/p&gt;

&lt;p&gt;​                model : sap.ui.model.BindingMode.OneWay、sap.ui.model.BindingMode.TwoWay&lt;/p&gt;

&lt;p&gt;​                formatter :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;花括号:{ }
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​        &lt;code&gt;var oControl = new sap.ui.commons.TextView({controlProperty:&amp;quot;{/modelProperty}&amp;quot;});&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;alternatively：
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​        &lt;code&gt;var oControl = new sap.ui.commons.TextView({controlProperty:{path:&amp;quot;/modelProperty&amp;quot;}});&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Model属性的获取。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;oModel.getProperty(&amp;ldquo;/sName&amp;rdquo;);    根据JSON数据属性名获取对应的值&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;多数据绑定&#34;&gt;多数据绑定&lt;/h3&gt;

&lt;p&gt;​    用于绑定集合数据，如绑定多行数据到一个表格中。使用模板:所有行都用同样的方法显示数据。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用模板:所有行都用同样的方法显示数据&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;var oItemTemplate = new sap.ui.core.ListItem({text:&amp;quot;{aggrProperty}&amp;quot;});
var oComboBox = new sap.ui.commons.ComboBox({
  items:{path:&amp;quot;/modelAggregation&amp;quot;, template: oItemTemplate}
});
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;bindAggregation():&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​        &lt;code&gt;oComboBox.bindAggregation(&amp;quot;items&amp;quot;,&amp;quot;/modelAggregation&amp;quot;,oItemTemplate);&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;工厂函数实现聚合绑定&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;oTable.bindAggregation(&amp;ldquo;items&amp;rdquo;,&amp;ldquo;/modelData&amp;rdquo;,function(sId,oContext){&lt;/p&gt;

&lt;p&gt;​ return oColumnListItem; //通过工厂函数，定义数据并返回&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;h3 id=&#34;元素绑定&#34;&gt;元素绑定&lt;/h3&gt;

&lt;p&gt;​   元素绑定指根据上下文(binding context)使用相对绑定的方式绑定到model数据的某一具体对象。尤其适用于&lt;strong&gt;主从数据显示(master-detail data)&lt;/strong&gt;的情况。&lt;/p&gt;

&lt;p&gt;​   sap.m.List(sId?, mSettings?) : List控件适用于显示行项目，所有类型都可以。&lt;/p&gt;

&lt;p&gt;​   sap.m.ObjectListItem(sId?, mSettings?) : 适用于显示行项目的信息，主要使用&lt;strong&gt;title&lt;/strong&gt;属性进行标识，text、icon、atrributes和statuses等属性可以用于提供对象更多信息。&lt;/p&gt;

&lt;p&gt;​   sap.m.Panel().bindElement({path:sPath}) : 将显示的明细与Model绑定。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;左边是一个List控件，右边在Panel中放置几个控件组合。当选择左边某个产品的时候，右边相应显示该产品的信息。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;oEvent.getSource().getBindingContext()&lt;/code&gt;获取绑定的项，再使用&lt;code&gt;getPath()&lt;/code&gt;方法得到path路径，然后设置右边的detailPanel与这个路径绑定。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Model 中detail包含多条数据的情况，点击 一个header,显示多个行项目，可以通过&lt;code&gt;sap.ui.model.Filter()&lt;/code&gt;的方法实现。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;绑定点击事件,&lt;code&gt;oSupTable.attachRowSelectionChange(fuction(oEvent()))&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;通过&lt;code&gt;var oRowContext = oEvent.getParameter(&amp;quot;rowContext&amp;quot;)&lt;/code&gt;获取行的上下文。如果选中第一行，rowContext就是constructor {oModel: 指定Model, sPath: &amp;ldquo;数据第一行地址&amp;rdquo;}。&lt;/p&gt;

&lt;p&gt;然后通过&lt;code&gt;var sSelectedId = oModel.getProperty(&amp;quot;id&amp;quot;, oRowContext)&lt;/code&gt;;就能获取到所选择行的id数据。&lt;/p&gt;

&lt;p&gt;通过 &lt;code&gt;var oBinding = oPrdTable.getBinding()&lt;/code&gt;;获取对应详细数据的绑定。&lt;/p&gt;

&lt;p&gt;定义过滤规则，var oF = new sap.ui.model.Filter({path:&amp;ldquo;key index&amp;rdquo;,oprator: new sap.ui.model.FilterOperator.BT,value1:value&amp;hellip;})。&lt;/p&gt;

&lt;p&gt;使用过滤规则，oBinding.filter(oF);&lt;/p&gt;

&lt;h3 id=&#34;绝对绑定和相对绑定&#34;&gt;绝对绑定和相对绑定&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;绝对绑定&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;将value属性绑定到json model根目录下对应的字段title/attr。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;相对绑定&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;相对绑定尤其适用于布局(layout)控件或者容器控件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当父控件的绑定路径设置后，子控件可以基于这个路径使用相对路径。&lt;/p&gt;

&lt;h2 id=&#34;routing导航&#34;&gt;Routing导航&lt;/h2&gt;

&lt;p&gt;​   Openui5 的 routing 基于模式 ( pattern )，使用 &lt;code&gt;#&lt;/code&gt; 符号表示不同的路径 ( route )，导航通过路径的改变来实现。&lt;/p&gt;

&lt;h3 id=&#34;pattern-表达式&#34;&gt;Pattern 表达式&lt;/h3&gt;

&lt;p&gt;Openui5 一共有 5 种 pattern表达式:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;硬编码模式&lt;/strong&gt; : 页面之间根据模式导航，没有参数传递，比如 product/settings 表示导航到产品配置。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;路径含有必输参数模式&lt;/strong&gt; : 模式中 大括号({}) 包含的部分表示参数必须输入。比如 product/{id} 表示导航到产品某一 id，比如 product/5 表示 id 为 5 的产品，id 为必输。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;路径含有可选参数模式&lt;/strong&gt; : 模式中 冒号 包含的部分为必输参数。比如 product/{id}/detail/:detailId:，detailId 为可选参数。product/5/detail 以及 product/3/detail/2 都能与此模式匹配。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;路径含有查询参数模式&lt;/strong&gt; : 查询参数 ( query parameter ) 在问号之后。比如 product{?query}，query 这个参数为必输项。product:?query: 中的 query 这个参数为可选参数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;**通配参数模式 **: 以星号结尾的参数是通配参数，通配参数将根据模式尽可能匹配。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;导航调用&#34;&gt;导航调用&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;父导航&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1) 跳转到Detail view子导航&lt;/p&gt;

&lt;p&gt;2) 向Detail view传递一个参数，参数为当前点击的路径，Detail获取该路径完成数据绑定&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;var oRouter = UIComponent.getRouterFor(this);获取当前的router&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;var oItem = oEvent.getSource();获取点击所在的行&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;oItem.getBindingContext().getPath();获取点击的路径，String类型（/Sup/0）路径传到Detail&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;oRouter.navTo(&amp;ldquo;detail&amp;rdquo;,{supplierPath:encodeURIComponent(sPath)});方法不能包含&lt;code&gt;/&lt;/code&gt;所以使用 &lt;code&gt;encodeURIComponent()&lt;/code&gt; 函数编码，在Detail controller 中用&lt;code&gt;decodeURIComponent()&lt;/code&gt;函数解码。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;子导航&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1) 获取 Master view 传递的路径，根据此路径完成 element binding。比如当 Master view 传过来 &lt;code&gt;/Suppliers/0&lt;/code&gt;，则与第一条数据绑定;&lt;/p&gt;

&lt;p&gt;2) 根据页面之间的关系，当点击 &lt;strong&gt;返回&lt;/strong&gt; 按钮时，返回到上一个页面。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;var oRouter = UIComponent.getRouterFor(this);&lt;/code&gt;获取当前Router&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;oRouter.getRoute(&amp;quot;detail&amp;quot;).attachPatternMatched(this._onObjectMatched, this);&lt;/code&gt;，当模式匹配时，附加事件处理器为 &lt;code&gt;_onObjectMatched&lt;/code&gt;。然后在 &lt;code&gt;_onObjectMatched&lt;/code&gt; 中获取 Master view 传递的路径并绑定数据。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt; _onObjectMatched: function (oEvent) {           
     var sPath = decodeURIComponent(
             oEvent.getParameter(&amp;quot;arguments&amp;quot;).supplierPath);
     this.getView().bindElement({path: sPath});
 }   
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;当用户点击导航按钮，判断是否有上一个路径 ( previous hash )，如果有就返回上一个路径，否则跳转到 Master view:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt; onNavPress: function() {
     var oHistory = History.getInstance();
     var sPreviousHash = oHistory.getPreviousHash();
         
     if (sPreviousHash != undefined){
         window.history.go(-1);
     }else{
         var oRouter = UIComponent.getRouterFor(this);
         oRouter.navTo(&amp;quot;master&amp;quot;,{}, true);
     }
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;mock-server&#34;&gt;mock server&lt;/h2&gt;

&lt;p&gt;​   在开发过程中，通过使用模拟服务器的方法方便测试，SAPUI5将模拟服务器称为mock server.mock server的基本功能是模拟oData数据的提供者，截获应用程序对服务器端的http或https请求，并传回模拟请求的回应，可以降低与真实后端的耦合。&lt;/p&gt;

&lt;h1 id=&#34;系统配置和功能块&#34;&gt;系统配置和功能块&lt;/h1&gt;

&lt;h2 id=&#34;sap-netweaver-gateway&#34;&gt;SAP NetWeaver Gateway&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;SAP NetWeaver Gateway 是一种技术，它提供了一种基于市场标准将设备，环境和平台连接到 SAP 软件的简单方法。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;任何SAP业务套件都是无中断的&lt;/p&gt;

&lt;p&gt;易于开发简单的API,不需要任何工具知识&lt;/p&gt;

&lt;p&gt;基于REST,oData。允许使用功能任何编程语言或模型连接到SAP应用程序&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;将SAP NetWeaver Gateway 连接到 SAP Business Suite&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1) 将后端服务器配置为信任系统 : SM59&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/SAPUI5/1559703243928.png&#34; alt=&#34;1559703243928&#34; /&gt;&lt;/p&gt;

&lt;p&gt;​                &lt;img src=&#34;https://coldinfire.github.io/images/SAPUI5/1559712968906.png&#34; alt=&#34;1559712968906&#34; /&gt;&lt;/p&gt;

&lt;p&gt;2) SMT1&lt;/p&gt;

&lt;p&gt;​                &lt;img src=&#34;https://coldinfire.github.io/images/SAPUI5/1559713194355.png&#34; alt=&#34;1559713194355&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;SAP NetWeaver Gateway部署选项&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1) 中央枢纽部署 : 后端系统的开发&lt;/p&gt;

&lt;p&gt;​    在此类部署选项中，中央 UI 附加组件，特定于产品的 UI 附加组件和 SAP NetWeaver 网关包含在 ABAP 前端服务器中。后端服务器包含业务逻辑和后端数据。开发在 ABAP 后端系统中进行。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;它需要单独的 SAP NetWeaver Gateway 系统&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;它允许在没有后端开发授权的情况下更改 UI。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;它为所有 UI 问题提供单点维护。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;它为 Fiori Apps 的主题和品牌提供了中心位置。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;它提供对后端系统的单点访问。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;由于无法直接访问后端系统，因此增强了安全性。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;直接本地访问元数据（DDIC）和业务数据以及轻松重用数据。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2) 中央集线器的部署&lt;/p&gt;

&lt;p&gt;​    如果必须在后端系统上执行开发，或者在 7.40 之前的版本中执行开发，则使用此选项。如果不允许在&lt;strong&gt;后端&lt;/strong&gt;部署 Add-On &lt;strong&gt;IW_BEP&lt;/strong&gt;。在这种情况下，开发人员仅限于可通过后端 RFC 访问的接口。&lt;/p&gt;

&lt;p&gt;​    开发在 Gateway 集线器系统中进行，并且不触及 Business Suite 后端系统。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;无法直接访问&lt;strong&gt;元数据（DDIC）&lt;/strong&gt;和业务数据。因此，数据的重用是有限的。&lt;/li&gt;
&lt;li&gt;无法远程使用 GENIL 对象。&lt;/li&gt;
&lt;li&gt;在此配置中，访问仅限于远程启用的接口，如 RFC 模块，BAPI 等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;odata-开放数据协议&#34;&gt;oData(开放数据协议)&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;概述: OData 用于定义构建和使用 RESTful API 所需的最佳实践&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;OData 提供扩展功能，以满足 RESTful API 的任何自定义需求。&lt;/li&gt;
&lt;li&gt;REST 代表 Representational State Transfer。&lt;/li&gt;
&lt;li&gt;它依赖于无状态，客户端 - 服务器，可缓存的通信协议。几乎在所有情况下，都使用 HTTP 协议。&lt;/li&gt;
&lt;li&gt;REST 被定义为用于设计网络应用程序的体系结构样式。&lt;/li&gt;
&lt;li&gt;OData 可帮助您在构建 RESTful API 时专注于业务逻辑，而无需担心定义请求和响应头，状态代码，HTTP 方法，URL 约定，媒体类型，有效负载格式和查询选项等的方法。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;oData服务生命周期&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;OData 服务生命周期包括 OData 服务的范围。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;激活 OData 服务。&lt;/li&gt;
&lt;li&gt;维护 OData 服务。&lt;/li&gt;
&lt;li&gt;维护模型和服务，直至清理元数据缓存。&lt;/li&gt;
&lt;li&gt;RESTful 应用程序使用 HTTP 请求发布数据以创建或更新，读取数据和删除数据。REST 对所有四个 CRUD（创建 / 读取 / 更新 / 删除）操作使用 HTTP。&lt;/li&gt;
&lt;li&gt;REST 是 RPC（远程过程调用）和 Web 服务等机制的轻量级替代方法。
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;oData设置&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在manifest.json中配置服务器：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;   &amp;quot;sap.app&amp;quot;: {
    ...
    &amp;quot;ach&amp;quot;: &amp;quot;CA-UI5-DOC&amp;quot;,
    &amp;quot;dataSources&amp;quot;: {
      &amp;quot;invoiceRemote&amp;quot;: {
        &amp;quot;uri&amp;quot;: &amp;quot;https://services.odata.org/V2/Northwind/Northwind.svc/&amp;quot;,
        &amp;quot;type&amp;quot;: &amp;quot;OData&amp;quot;,
        &amp;quot;settings&amp;quot;: {
          &amp;quot;odataVersion&amp;quot;: &amp;quot;2.0&amp;quot;
        }
      }
    }
    &amp;quot;sap.ui5&amp;quot;: {
    ...
    &amp;quot;models&amp;quot;: {
      ...
      &amp;quot;invoice&amp;quot;: {
        &amp;quot;dataSource&amp;quot;: &amp;quot;invoiceRemote&amp;quot;
      }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;sap-fiori-launchpad&#34;&gt;SAP Fiori Launchpad&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;关于 SAP Fiori Launchpad 的要点如下。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;基于 Web 的入口点，可跨平台和设备使用 SAP Business 应用程序。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;作为 I HTML 客户端的开箱即用思想提供。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用主题，搜索集成，自定义等功能为最终用户提供高生产率。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为使用多种设备类型的最终用户提供单一入口点。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>MM 主要数据创建</title>
      <link>https://coldinfire.github.io/2019/MMMasterData/</link>
      <pubDate>Thu, 14 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/MMMasterData/</guid>
      <description>

&lt;h3 id=&#34;enterprise-struture&#34;&gt;Enterprise Struture&lt;/h3&gt;

&lt;p&gt;1.Define Company : OX15&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SPRO -&amp;gt; IMG -&amp;gt;Enterprise Structure -&amp;gt; Definition -&amp;gt; Financial Account -&amp;gt; Define Company&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/MMMasterData/1.png&#34; alt=&#34;Define Company&#34; /&gt;
&lt;img src=&#34;https://coldinfire.github.io/images/MMMasterData/2.png&#34; alt=&#34;Details&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1.Enter company&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;2.Enter company name&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;3.Update address&lt;/li&gt;
&lt;li&gt;4.Enter country code of company&lt;/li&gt;
&lt;li&gt;5.Enter language key&lt;/li&gt;
&lt;li&gt;6.Enter local currency&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2.Define Company Code : OX02&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SPRO -&amp;gt; IMG -&amp;gt;Enterprise Structure -&amp;gt; Definition -&amp;gt; Financial Account -&amp;gt; Edit,Copy,Delete Company Code
&lt;img src=&#34;https://coldinfire.github.io/images/MMMasterData/3.png&#34; alt=&#34;Company Code&#34; /&gt;
&lt;img src=&#34;https://coldinfire.github.io/images/MMMasterData/4.png&#34; alt=&#34;Details&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3.Assign Company Code to Company : OX16&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SPRO -&amp;gt; IMG -&amp;gt;Enterprise Structure -&amp;gt; Definition -&amp;gt; Financial Account -&amp;gt; Assign Company Code To Company&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/MMMasterData/5.png&#34; alt=&#34;Assign Demo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;4.Define Plant : OX10&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SPRO -&amp;gt; IMG -&amp;gt;Enterprise Structure -&amp;gt; Definition -&amp;gt; Logistics -&amp;gt;General -&amp;gt; Define plant&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/MMMasterData/6.png&#34; alt=&#34;Define Plant&#34; /&gt;&lt;/p&gt;

&lt;p&gt;5.Assign Plant to Company Code : OX18&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SPRO -&amp;gt; IMG -&amp;gt;Enterprise Structure -&amp;gt; Assignment -&amp;gt; Logistics -&amp;gt; AssignPlant to Company Code&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/MMMasterData/7.png&#34; alt=&#34;Assign&#34; /&gt;&lt;/p&gt;

&lt;p&gt;6.Maintain Storage Locations : OX09&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SPRO -&amp;gt; IMG -&amp;gt;Enterprise Structure -&amp;gt; Definition -&amp;gt; Material Mast -&amp;gt; Maintain storage Location&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/MMMasterData/8.png&#34; alt=&#34;Storage Location&#34; /&gt;&lt;/p&gt;

&lt;p&gt;7.Maintain Purchase Organization : OX08&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SPRO -&amp;gt; IMG -&amp;gt;Enterprice Structure -&amp;gt; Definition -&amp;gt; Material Mast -&amp;gt; Maintain Purchasing Org&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/MMMasterData/9.png&#34; alt=&#34;Purchase Org&#34; /&gt;&lt;/p&gt;

&lt;p&gt;8.Create Purchase groups : OME4&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SPRO -&amp;gt; IMG -&amp;gt;MM -&amp;gt; Purchasing -&amp;gt; Create Purchasing Groups&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/MMMasterData/10.png&#34; alt=&#34;Purchasing Groups&#34; /&gt;&lt;/p&gt;

&lt;p&gt;9.Assign Purchasing org to Company Code : OX01&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SPRO -&amp;gt; IMG -&amp;gt; Enterprice Structure -&amp;gt; Assign -&amp;gt; Material Mast  -&amp;gt; Assign Purchase Org to Company Code
&lt;img src=&#34;https://coldinfire.github.io/images/MMMasterData/11.png&#34; alt=&#34;Assign&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;10.Assign Purchasing organization to reference purchasing org&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SPRO -&amp;gt; IMG -&amp;gt; Enterprice Structure -&amp;gt; Assign -&amp;gt; Material Mast -&amp;gt; Assign Purchase Org to RPO&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;11.Assign Purchase Org to Plant : OX17&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SPRO -&amp;gt; IMG -&amp;gt; Enterprice Structure -&amp;gt;Assignment -&amp;gt; Material Mast -&amp;gt; Assign PO to Plant&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/MMMasterData/12.png&#34; alt=&#34;Org To Plant&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;master-data&#34;&gt;Master Data&lt;/h3&gt;

&lt;p&gt;1.物料主数据视图：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;包含：常规，采购，销售，库存， 计划，属性，备注等视图维护。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2.Split Valuation configuration (定义全球估价类型) : OMWC&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SPRO -&amp;gt; IMG -&amp;gt; MM -&amp;gt; valuation and account assign -&amp;gt; split valuation -&amp;gt;config split valuation&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一个屏幕（Global Types）&lt;/p&gt;

&lt;p&gt;第二个屏幕（创建新的估价类型 Valuation Types：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;Valuation type:识别估价类型的关键
Ext.PO : 是否允许外部采购订单（0：不允许，1：允许，提示警告，2：允许）
Int.PO  : 是否允许内部订单（0：不允许，1：允许，提示警告，2：允许）
Acct cat : 账户参考必填字段。选择合适的值）
     （创建新的估价类别： Valuation category :
        Def ext.procure:默认外部采购
        ext.procurement mand ： 复选框勾选则无法在PO级别更改评估类型
        Def in-house:
        val.type automatic: 复选框用于拆分评估和批次管理
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.Create Material Group ： OMSF&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SPRO -&amp;gt; Logistic general -&amp;gt; MM -&amp;gt; Settings for Key Fields -&amp;gt; Define Material Group&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;物料组：是物料统计分组的标识，属于无组织机构级别，它在采购信息记录、采购订单等中使用。在创建采购订单时， 当输入物料编号，物料组就自动被带出。物料组用于内部管理，分类较细。用户可以通过物料组获取整个采购状况及当前库存的标准SAP报表。&lt;/p&gt;

&lt;p&gt;3.Create Material Types ： OMS2&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SPRO -&amp;gt; Logistic general -&amp;gt; MM -&amp;gt; Basic Settings -&amp;gt; Material Types&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;物料类型用来控制视图的范围，也用来控制物料的计价方式以及物料是否能够用于库存管理。也是SAP报表和分析涉及的重要对象。作为物料统计和分类的标准之一。如需新建物料类型，不能采用新建条目，只能采用复制方法，具体步骤是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;1&gt;参考已有的物料类型进行复制，但不要修改条目细节的属性值；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;2&gt;对新建的物料类型进行修改，以其符合自身需求。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;  新建物料类型后，需要维护编码范围；维护数量/价值更新；字段状态维护。
  字段参考：为字段状态服务的分组码
  项目类别组：设定默认的项目类别组，用于销售项目类别确认、计划类别确认、交货项目类别确认
  账户分类参考：设计会计视图的可应用的评估类，与自动记账相关
  用户部门：根据业务需求选择部门内部，外部采购订单：根据业务要求选择值
  计价：
  价格控制：选择适用
  关联科目：从列表中选择，检查输入评估类是否允许维护物料主记录中的会计数据
  库存项目：不是库存项目，值更新；具有值的库存项目，数量更新和值更新
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.Define industry Sectors ： OMS3&lt;/p&gt;

&lt;p&gt;Industry sectors , industry desc , Field Reference.&lt;/p&gt;

&lt;p&gt;5.Maintain company codes for material management&lt;/p&gt;

&lt;p&gt;SPRO &amp;gt; Logistics &amp;gt; General &amp;gt; MM &amp;gt; Basic settings &amp;gt; Maintain company code for MM&lt;/p&gt;

&lt;p&gt;CoCD,Company Name,Year,等字段信息更新保存。&lt;/p&gt;

&lt;p&gt;6.Define MRP Controllers&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SPRO &amp;gt; IMG &amp;gt; Production &amp;gt; MRP &amp;gt; Master Data &amp;gt; Define MRP Controllers(Plant,MRP Controller, Tel)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SAP MRP are planned for each plant and every plant has its own MRP data.&lt;/p&gt;

&lt;p&gt;7.Create,Change,Display Material : MM01/MM02/MM03&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SPRO &amp;gt; Logistics &amp;gt; MMt &amp;gt; MMa &amp;gt; Material &amp;gt; Create general&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;8.Create Purchasing info records : ME11/ME12/ME13&lt;/p&gt;

&lt;p&gt;为不同的采购类型创建采购信息记录，例如标准、分包、管道、寄售。用于将供应商和物料在工厂级别或则采购组织数据作为主数据存储。&lt;/p&gt;

&lt;h4 id=&#34;info-record&#34;&gt;Info Record&lt;/h4&gt;

&lt;p&gt;总账科目确认：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;按物料级别设置科目：手动输入的科目&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;按仓库设置总账科目：仓库定义中的科目&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;按物料组设置总账科目：物料组定义中的科目&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>MM 采购</title>
      <link>https://coldinfire.github.io/2019/MMDetail2/</link>
      <pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/MMDetail2/</guid>
      <description>

&lt;h2 id=&#34;库存采购基础&#34;&gt;库存采购基础&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/MM/Buy.png&#34; alt=&#34;采购环境&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;采购流程&#34;&gt;采购流程：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;1. MRP &amp;amp; Purch.Req (Determination of reqmts)（确认需求）&lt;/li&gt;
&lt;li&gt;2. Source determination (购买方式和货源)&lt;/li&gt;
&lt;li&gt;3. Vendor selection （跟哪个供应商买）&lt;/li&gt;
&lt;li&gt;4. Request for Quotation (要求报价)&lt;/li&gt;
&lt;li&gt;5. Purchase Requisition (采购申请)&lt;/li&gt;
&lt;li&gt;6. PO processing （下采购订单）&lt;/li&gt;
&lt;li&gt;7. PO monitoring （订单跟踪）&lt;/li&gt;
&lt;li&gt;8. Goods receipt （收货）&lt;/li&gt;
&lt;li&gt;9. Invoice verfication （发票校验）&lt;/li&gt;
&lt;li&gt;10. Payment processing （付钱）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;MRP：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用预计的制造生产计划来确定所需材料以及何时需要信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;供应商选择：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从报价中比较选择供应商。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;报价请求：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;要求潜在供应商提交材料或服务报价。Quatation 包含供应商的条款和条件。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;采购申请：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;物料使用部门提出的队某种物料的需求&lt;/li&gt;
&lt;li&gt;可以由系统自动生成 (MRP) 或手工生成&lt;/li&gt;
&lt;li&gt;公司内部谁用文件&lt;/li&gt;
&lt;li&gt;可以没有供应商、没有价格，只有评估价值&lt;/li&gt;
&lt;li&gt;可以自动或手动地转化为采购订单&lt;/li&gt;
&lt;li&gt;交货指示&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;采购订单：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PO 是供应商在特定条件下提供某些材料或服务的正式请求。&lt;/li&gt;
&lt;li&gt;询价 / 报价：第一次购买的物料，为一种库存物料创建一张采购订单&lt;/li&gt;
&lt;li&gt;采购订单处理：参考采购订单输入一张物料接收，评估自动生成的各个凭证&lt;/li&gt;
&lt;li&gt;收货：输入与采购订单相关的收据，同时进行价格及质量检查&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;检查供应商发票：核实在发票过账基础上创建的财务会计凭证，验证其可信程度&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;询价报价&#34;&gt;询价报价&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;询价单 / 报价单：ME41/ME47 &lt;RFQ&gt;&lt;/li&gt;
&lt;li&gt;打印询价单：ME9A&lt;/li&gt;
&lt;li&gt;价格对比：ME49&lt;/li&gt;
&lt;li&gt;信息清单：ME11&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;确定购买需求&lt;/li&gt;
&lt;li&gt;确定货源的供应&lt;/li&gt;
&lt;li&gt;向选定的多个供应商发送询价单（物料价格，物料数量，送货时间，等等）&lt;/li&gt;
&lt;li&gt;根据供应商返回的报价单挑选合适的 (报价单处理：输入价格和条件，应用价格比较列表比较报价单)&lt;/li&gt;
&lt;li&gt;参照报价单创建采购订单&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;采购信息记录和价格决定：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1）手工输入价钱&lt;/p&gt;

&lt;p&gt;2）如果手工没有输入，系统找 Info record，如果信息记录中有合适的价钱，采用 Info record 价格。&lt;/p&gt;

&lt;p&gt;3 ）没有Info record价格，最后采用 PO 价钱，也可以不从最后的 PO 带入价格。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;配额协议&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;货源清单 (Source List)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;信息记录 (Info record)&lt;/strong&gt;：ME11（手工输入，报价单，采购订单，框架协议更新）
：一个物料在某个供应商那里，卖多少钱，有什么特殊条件等信息的存储。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;价格条件：&lt;/strong&gt;
报价价格、采购订单、信息记录、框架协议会 （用到价格条件类型）&lt;/p&gt;

&lt;p&gt;市场价：对个供应商的价格平均值，查询市场价 &lt;MEKH&gt;&lt;/p&gt;

&lt;p&gt;采购订单：将采购订单发送给供应商《同时发送给生产的工厂》产生采购凭证&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;价钱条件：ME12
手工创建采购订单：ME21N       
跟踪采购订单：ME23N
采购订单订单查询：ME2L
一般数据：供应商数据、原始数据、订购单位等
价格和条件：总价格、折扣、运费、关税、其他
控制数据：交付时间、最小数量、容差
文本：采购订单文本、Int.信息记录备注
统计：价格历史记录、采购订单统计、改变历史记录. . . . . 

订单结构：
    PR Header : 采购订单编号、供应商、货币、付款期限、采购订单日期
    PR Item : 物料编号、短文本、发货日期、采购订单数量、采购订单价格、分类
    科目设置对象：
        A：资产    K：成本中心    P：项目    F：订单(生产，考虑)    C：销售订单    其他
无物料的采购订单：
    采购订单中不输入物料，只输入描述
    可以收获，但是必须是直接消耗，没有库存管理
    适用于低值品的采购           
采购合同   &amp;lt;联系、集成、自动&amp;gt;   采购订单
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;自动采购：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;主数据和合同,资源清单&lt;/li&gt;
&lt;li&gt;物料需求计划(MRP)&lt;/li&gt;
&lt;li&gt;自动生成采购单&lt;/li&gt;
&lt;li&gt;发送通知和物料接收&lt;/li&gt;
&lt;li&gt;评估收货结算(ERS)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/MM/PRecord.png&#34; alt=&#34;采购订单的自动生成&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;收货：事务代码 《MIGO》&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;供应商根据采购订单将货物发送到指定地区，以及发票&lt;/li&gt;
&lt;li&gt;工厂在收货地点进行收货&lt;/li&gt;
&lt;li&gt;收货时同时产生物料凭证和会计凭证 创建物料凭证：MB03&lt;/li&gt;
&lt;li&gt;货物会收到指定的 Location &amp;lt;货物移动凭证&amp;gt;&lt;/li&gt;
&lt;li&gt;移动类型：仓库收货 &lt;101&gt;、退货发运 &amp;lt; 122&amp;gt;&amp;hellip; &amp;hellip;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;收货后：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;会更新物料主数据的工厂库存视图 (库存查看 MMBE, MB52)&lt;/li&gt;
&lt;li&gt;物料凭证，会计凭证产生&lt;/li&gt;
&lt;li&gt;自动触发启用 QM/WM&lt;/li&gt;
&lt;li&gt;采购订单历史数据更新&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/MM/GR.png&#34; alt=&#34;收货实现&#34; /&gt;
&lt;img src=&#34;https://coldinfire.github.io/images/MM/proof.png&#34; alt=&#34;凭证产生&#34; /&gt;
&lt;strong&gt;发票校验：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;主数据、发票、采购订单、物料凭证综合数据进行发票校验&lt;/li&gt;
&lt;li&gt;根据校验的结果生产发票凭证 &amp;lt;发票校验科目&amp;gt;&lt;/li&gt;
&lt;li&gt;记账过账处理&lt;/li&gt;
&lt;li&gt;根据发票凭证触发付款程序&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/MM/invoice1.png&#34; alt=&#34;发票检验&#34; /&gt;
&lt;img src=&#34;https://coldinfire.github.io/images/MM/invoice2.png&#34; alt=&#34;凭证产生&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;记账过账：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;根据采购订单、物料凭证、发票信息进行记账&lt;/li&gt;
&lt;li&gt;发票过账时，会创建一张会计凭证。各项目将被发送到相应的科目。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>MM Material Master</title>
      <link>https://coldinfire.github.io/2019/MMDetail1/</link>
      <pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/MMDetail1/</guid>
      <description>

&lt;h2 id=&#34;企业组织结构&#34;&gt;企业组织结构&lt;/h2&gt;

&lt;h3 id=&#34;整体架构&#34;&gt;整体架构&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;集团：是 R/3 系统里的一个商业的组织层次。有自己的数据、主记录及各种报表。从业务角度看，集团当作各个实体的组合。&lt;/li&gt;
&lt;li&gt;公司代码：一个公司代码代表一个独立的会计实体。每个公司代码都有它自己得到资产负债表和损益表。&lt;/li&gt;
&lt;li&gt;工厂：是公司内的组织单元，生产产品、提供服务或销售产品，工厂可以是（制造厂、仓库中转中心、 区域销售办公司、公司总部）。&lt;/li&gt;
&lt;li&gt;仓储地点：是工厂内存放不同类型物料的组织单位，如：材料仓，成品仓，材损仓。&lt;/li&gt;
&lt;li&gt;采购组织：是负责为一个或多个工厂工厂采购物料和提供服务及与供应商协商价格和供货条款的主旨单位。价格条件在采购组织层次设置。如果一个采购组织为多个工厂采购，则价格在各个工厂都有效。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;采购组：是采购组织的进一步细分，负责日常的采购活动，一个采购组也可以为多个采购组织工作。&lt;/p&gt;

&lt;h4 id=&#34;集团-公司代码-工厂&#34;&gt;集团 / 公司代码 / 工厂&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/MM/Client1.png&#34; alt=&#34;架构关系&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;公司代码-工厂-库存地点&#34;&gt;公司代码 / 工厂 / 库存地点&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/MM/Client2.png&#34; alt=&#34;架构关系&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;物料主数据&#34;&gt;物料主数据&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;MM01：创建&lt;/li&gt;
&lt;li&gt;MM02：修改&lt;/li&gt;
&lt;li&gt;MM03：显示&lt;/li&gt;
&lt;li&gt;MM06：立即删除标记，Material的删除分两个层次， 一个是加Delete
flag material,但号码还存在， 但强制使用还是可以的， 所以建议使用Status来控制，将所有的状态都block住。&lt;/li&gt;
&lt;li&gt;MM17：批量维护物料主数据内容&lt;/li&gt;
&lt;li&gt;MM50：物料视图扩充&lt;/li&gt;
&lt;li&gt;MM60：物料清单&lt;/li&gt;
&lt;li&gt;MMAM：配置物料类型&lt;/li&gt;
&lt;li&gt;MMD1：MRP文档创建&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;主要信息&#34;&gt;主要信息:&lt;/h4&gt;

&lt;p&gt;描述性信息：描述，尺寸，体积等&lt;/p&gt;

&lt;p&gt;控制性信息：MRP类型，价格控制，采购组等&lt;/p&gt;

&lt;p&gt;物料主数据：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;General:           Material Number、Description、Base Unit Of Measure、Technical&lt;/li&gt;
&lt;li&gt;Plan Specific：MRP type、Planned delivery time、Purchasing group、Batch indicator&lt;/li&gt;
&lt;li&gt;Valuation：     Valuation price、Valuation procedure、Valuated quantity&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;物料主数据录入&#34;&gt;物料主数据录入&lt;/h4&gt;

&lt;p&gt;必要数据：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;物料编码：物料编码用来唯一地识别有关物料主记录，用户可在物料管理客户化修改中设置长度并记录物料编码的模式。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;号码范围： （Group、Material type、Number Ranges）
外部给号，内部给号范围的限制；允不允许外部给号，需要设置Group中包不包含外部Number range；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/MM/MM_NR.png&#34; alt=&#34;定义Number Ranger&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;行业领域：根据不同的行业领域，决定有哪些与行业相关的数据可以显示；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;物料类型：按照物料在公司的不同用途，将物料分为不同类型；决定财务和仓库管理的特性。例如：可将物料分为原材料、半成品、成品、服务。贸易型货物或内部、外部拥有的空容器等各种类型。可做如下控制：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;定义哪个部门可维护物料数据&lt;/li&gt;
&lt;li&gt;定义采购类型&lt;/li&gt;
&lt;li&gt;在相关的工厂中定义库存管理类型，例如，可通过物料类型定义更新哪些数据，但价值不变&lt;/li&gt;
&lt;li&gt;是自动过帐定义的一个因素，财务参照物料类型确定库存科目&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;标准物料类型：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Detail&lt;/th&gt;
&lt;th&gt;Detail&lt;/th&gt;
&lt;th&gt;Detail&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;成品（FERT）：Finished Product&lt;/td&gt;
&lt;td&gt;备品备件（ERSA）：Spare Parts&lt;/td&gt;
&lt;td&gt;可反复利用包装（LEIH）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;半成品（HALB）：Semifinished Product&lt;/td&gt;
&lt;td&gt;贸易货物（HAWA）：Trading Goods&lt;/td&gt;
&lt;td&gt;未估价物料(UNBW)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;原材料（ROH）：Raw materials&lt;/td&gt;
&lt;td&gt;包装物料（VERP）：Packaging&lt;/td&gt;
&lt;td&gt;管线物料（PIPE）：Pipeline materials&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;物料类型设置：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SPRO：SAP后台配置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/MM/MM_material_type1.png&#34; alt=&#34;Material Types&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;详细信息&amp;mdash;&amp;gt;User departments（决定哪些部门需要维护）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/MM/MM_material_type.png&#34; alt=&#34;Material Types Control&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;External no.
assignment w/o check, 如果选中就代表，建立Material 并且外部给号的时候， 不会去检查是否符合External no range。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;控制数量/价值更新：决定数量和价值的更新（客户供料：只会做数量更新，不会做价钱更新&amp;lt;不属于本公司&amp;gt;）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/MM/MM_material_type2.png&#34; alt=&#34;Material Types Control&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;控制内/外部采购订单：决定是不是自己生产的（影响采购类型），这两个配置主要作用于 MRP2 中的 “采购类型” 字段&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0：不允许&lt;/li&gt;
&lt;li&gt;1：允许外部采购，但是会有警告&lt;/li&gt;
&lt;li&gt;2：允许外部采购&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/MM/MM_material_type3.png&#34; alt=&#34;Material Types Control&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;决定使用哪个G/L Account：
过账时的总账分类账&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/MM/MM_material_type4.png&#34; alt=&#34;Material Types Control&#34; /&gt;&lt;/p&gt;

&lt;p&gt;更改物料类型：满足以下条件并使用TCode：&lt;strong&gt;&lt;em&gt;MMAM&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;没有库存;没有预留;没有采购文档（PR，PO，协议，合同）可以更改&lt;/li&gt;
&lt;li&gt;新的物料类型和旧的物料类型有相同的G/L Account；有相同的数量/价值更新&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;物料状态定义：控制该物料可以做什么和不可以做什么&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SPRO&lt;img src=&#34;https://coldinfire.github.io/images/MM/MM_MS1.png&#34; alt=&#34;Material Status&#34; /&gt;&lt;/li&gt;
&lt;li&gt;定义&lt;img src=&#34;https://coldinfire.github.io/images/MM/MM_MS2.png&#34; alt=&#34;Material Status&#34; /&gt;&lt;/li&gt;
&lt;li&gt;设置&lt;img src=&#34;https://coldinfire.github.io/images/MM/MM_MS3.png&#34; alt=&#34;Material Status&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;视图设置：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;物料主数据记录中的数据是集合在不同的视图中；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;公司所有部门都需要使用物料主数据，因此在不同的部门会有不同的物料主数据视图。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;视图结构：&lt;img src=&#34;https://coldinfire.github.io/images/MM/MMMain.png&#34; alt=&#34;视图&#34; /&gt;&lt;/p&gt;

&lt;p&gt;视图默认值设置：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通过缺省值设置默认Industry sector&lt;/li&gt;
&lt;li&gt;通过缺省值设置默认View&lt;/li&gt;
&lt;li&gt;通过缺省值设置默认Organization level，可从其他工厂复制&lt;/li&gt;
&lt;li&gt;通过复制其他的物料号&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;数据屏幕：可以分为以下三层数据结构&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;初始级别：设置初始化必需数据&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;主体工作级别：主要的数据设置&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;辅助数据级别：在主数据级别外进行额外的信息补充&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/MM/MMScreen.png&#34; alt=&#34;数据屏幕&#34; /&gt;&lt;/p&gt;

&lt;p&gt;字段控制：控制前台字段的显示状态&lt;/p&gt;

&lt;p&gt;​   给字段组分配字段；通过组别的方式进行设置字段的显示状态：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/MM/MM_FS.png&#34; alt=&#34;组别类型&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/MM/MM_FS2.png&#34; alt=&#34;各组别定义&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/MM/MM_FS1.png&#34; alt=&#34;各组别定义&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;多个因素的优先级：

&lt;ul&gt;
&lt;li&gt;Hide&lt;/li&gt;
&lt;li&gt;Display&lt;/li&gt;
&lt;li&gt;Required entry field&lt;/li&gt;
&lt;li&gt;Option entry field&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;视图选择&#34;&gt;视图选择&lt;/h4&gt;

&lt;p&gt;​   &lt;strong&gt;Basic Data1:一般属于物料描述等属性，属于集团类别。&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;单位：基本单位，订单单位，转换因子（附加数据中有计量单位的设定，
计量单位组：预先定义好单位转换 &amp;lt;通过后台设置关键字 设置计量单位组中进行设置的&amp;gt;）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;计量单位(计量单位组)
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/MM/MM_DUMG.png&#34; alt=&#34;计量单位组定义&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;物料组：对物料进行分组，便于分析；不同的物料组决定过账时的G/L Account&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;旧物料号： 便于查找旧系统数据&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;部门：Division (1) 影响 SD/FI 两个模块 (2) 无值将导致销售无法生成订单，单价录入，报告书等&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;实验室 / 办公室：描述信息没有特殊描述&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;产品组：根据公司产品分组，不填写销售无法生成订单&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;毛重、净重：报关使用,创建SO的时候，重量会被自动带出&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;附加数据：通过附加数据来维护不同语言环境的物料描述&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;凭证数据、内部批注


&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;MRP1：MRP控制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   MRP 类型、MRP 控制者、批量（在 PP 中会使用到的）&lt;/p&gt;

&lt;p&gt;​   MRP 组：&lt;/p&gt;

&lt;p&gt;​   MRP 类型：（固定值 &lt;strong&gt;PD&lt;/strong&gt;）&lt;/p&gt;

&lt;p&gt;​   MRP 控制者：谁来负责该MRP控制&lt;/p&gt;

&lt;p&gt;​   批量大小：（固定值 &lt;strong&gt;EX&lt;/strong&gt;）&lt;/p&gt;

&lt;p&gt;​   MRP参数文件：MMD1创建&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MRP2：影响 MRP 运算&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;采购类型：内部生产或则外部采购&lt;/p&gt;

&lt;p&gt;特殊采购类型：有偿加工必填 &lt;31&gt;, 无偿加工品必填 &amp;lt; 30&amp;gt;
外部采购&lt;/p&gt;

&lt;p&gt;仓储地点：物料存储仓库&lt;/p&gt;

&lt;p&gt;计划边际码：采购品须填写准确日期，影响 MRP 运输&lt;/p&gt;

&lt;p&gt;计划交货时间：进口件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MRP3：可用性检查（02）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   策略组：内部生产品必填，固定值&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MRP4:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   选择方法：内部生产品必填，固定值&lt;/p&gt;

&lt;p&gt;​   重复生产：内部生产品必填，固定值&lt;/p&gt;

&lt;p&gt;​   重复生产参数 文件：内部生产品必填，固定值&lt;/p&gt;

&lt;p&gt;​   工厂数据 / 存储：&lt;/p&gt;

&lt;p&gt;​   存储条件：关系到销售出库&lt;/p&gt;

&lt;p&gt;​   End Item：直买直卖的物品必须勾选&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;会计 1：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;评估类、价格控制、价格单位、标准价格&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​   评估分类：影响会计计算，必须准确&lt;/p&gt;

&lt;p&gt;​   价格确定：系统自动存在，没有时必须输入&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;成本 1：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   勾选物料来源：`&lt;/p&gt;

&lt;h4 id=&#34;2-消耗型物料&#34;&gt;2.消耗型物料&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;办公材料 &amp;lt;成本中心&amp;gt;&lt;/li&gt;
&lt;li&gt;计算机系统 &amp;lt; 固定资产 &amp;gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;1&gt; 消耗型物料时直接为了一个科目设置对象而购买的物料 (不需要办理入库和出库手续)&lt;/p&gt;

&lt;p&gt;&lt;2&gt; 库存管理未被执行&lt;/p&gt;

&lt;p&gt;&lt;3&gt; 系统会自动更新有物料主记录的消耗型物料&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;          库存物料            《=》              消耗型物料
    输入要求的物料编号                     可以输入物料编号，但不是必须的
    无科目设置类别                         强制科目设置类别
    过账到库存科目                         过账到消耗科目
    在物料主记录中更新数量和价值            消耗品更新（只使用于物料主记录中的物料）、移动平均价格被调整
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;非库存物料（NLAG）: 有一定采购频率、是有物料主数据，但不做库存管理的物料。（价值，数量）。

&lt;ul&gt;
&lt;li&gt;使用该物料类型（NLAG）的物料，创建采购订单需要指定账户分类（如 K 等）；根据采购订单收货时，直接财务上消耗记账。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;未评估物料（UNBW) : 做数量管理，不做价值管理

&lt;ul&gt;
&lt;li&gt;使用该物料类型（UNBW）的物料，创建采购订单需要指定账户分类（如 K 等）；根据采购订单收货时，直接财务消耗记账，更新库存数量；消耗时，只记录库存数量减少。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;3-bom&#34;&gt;3.BOM&lt;/h4&gt;

&lt;p&gt;BOM：物料清单 (零件结构表)，将产品的原材料、零配件、组件予以拆解，并将各单位项材料依材料编号、名称、
规格、基本单位、单位用量、产品损耗等依制造流程的顺序记录下来，排列为一个清单，就是 BOM。&lt;/p&gt;

&lt;h4 id=&#34;4-mrp&#34;&gt;4.MRP&lt;/h4&gt;

&lt;p&gt;MRP：物料需求计划，利用生产日程表（MPS）、零件结构表（BOM）、库存报表、已订购未交货订单等等
各种相关资料，经正确计算而得出各种物料零件的变量需求，提出各种新的订购或修正各种以开出订购
的物料管理技术。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/MM/MRP.png&#34; alt=&#34;MRP原理&#34; /&gt;
&lt;img src=&#34;https://coldinfire.github.io/images/MM/MRP2.png&#34; alt=&#34;MRP&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MRP元素缩写&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Detail&lt;/th&gt;
&lt;th&gt;Detail&lt;/th&gt;
&lt;th&gt;Detail&lt;/th&gt;
&lt;th&gt;Detail&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SimReq：简单需求&lt;/td&gt;
&lt;td&gt;BR：流程订单&lt;/td&gt;
&lt;td&gt;PrdOrd：生产订单&lt;/td&gt;
&lt;td&gt;BtchSt：批量库存&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AR：相关预订&lt;/td&gt;
&lt;td&gt;OrdRes：订单需求&lt;/td&gt;
&lt;td&gt;PMOrdr：PM 订单&lt;/td&gt;
&lt;td&gt;CStock  客户库存&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;BA：采购申请&lt;/td&gt;
&lt;td&gt;PurRqs：采购申请&lt;/td&gt;
&lt;td&gt;FE：生产订单&lt;/td&gt;
&lt;td&gt;DD：有效外日期&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;BB：提供物料转包商需求&lt;/td&gt;
&lt;td&gt;SubReq：外协请求&lt;/td&gt;
&lt;td&gt;IH：维护订单&lt;/td&gt;
&lt;td&gt;E1：分包合同采购&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;BE：订单项目计划行&lt;/td&gt;
&lt;td&gt;PrcOrd：处理订单&lt;/td&gt;
&lt;td&gt;CH：批库存&lt;/td&gt;
&lt;td&gt;FH：计划时界末&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;BP：总需求计划&lt;/td&gt;
&lt;td&gt;OI-SL：采购订单&lt;/td&gt;
&lt;td&gt;KB：单独客户库存&lt;/td&gt;
&lt;td&gt;JI：JIT 提取/JIT：JIT 调用&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>MM Summary</title>
      <link>https://coldinfire.github.io/2019/MMSummary/</link>
      <pubDate>Thu, 07 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/MMSummary/</guid>
      <description>

&lt;h3 id=&#34;mm概要&#34;&gt;MM概要&lt;/h3&gt;

&lt;h4 id=&#34;业务&#34;&gt;业务&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;(采购询价 ME41 / 报价 ME47 录入、ME49 报价比较)&amp;mdash;-&amp;gt; 采购申请 (PR)&amp;mdash;-&amp;gt; 采购订单 (PO)&amp;mdash;-&amp;gt; 发送采购单给供应商 &amp;lt; ME9F&amp;gt;&amp;mdash;-&amp;gt; 采购收货 (产生物料凭证)&amp;mdash;-&amp;gt; 发票校验 (产生会计凭证)&amp;mdash;-&amp;gt; 应付&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;买物料（Purchasing、Invoicing）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;基本数据管理：物料、供应商、采购信息、货源、配额、批次数据&lt;/li&gt;
&lt;li&gt;采购管理：采购申请、货源确定、采购批准、采购订单处理、订单跟踪、采购货物接收&lt;/li&gt;
&lt;li&gt;采购发票校验：订单、收货单、发票数量、金额匹配&lt;/li&gt;
&lt;li&gt;库存管理：库存事务处理、库存状态控制、库存分析与评估&lt;/li&gt;
&lt;li&gt;仓库管理：数量整理&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;业务流程&#34;&gt;业务流程&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;SAP 物流相关模块中，工厂是最重要的组织结构，隶属于公司代码，并且包括了和物流管理相关的最多的控制参数。这里首先创建一个工厂。&lt;/li&gt;
&lt;li&gt;创建工厂下面的 3 个库存地点：仓库、生产、运输。&lt;/li&gt;
&lt;li&gt;创建采购组织，再创建两个采购组：原材料和运营供应、贸易商品
（注意：此时采购组织以及采购组和公司代码没有任何联系，采购组织和采购组也并没有联系，实际上，采购组在 client 层次，client 下的任何公司，任何工厂都可以使用这个采购组）；&lt;/li&gt;
&lt;li&gt;定义与工厂相关的两个 MRP 控制者，分别控制自制品计划和贸易商品的计划。&lt;/li&gt;
&lt;li&gt;将创建的工厂分配给公司代码。&lt;/li&gt;
&lt;li&gt;分配采购组织到公司代码。&lt;/li&gt;
&lt;li&gt;分配工厂到采购组织。SAP 系统 SAP 中的一个采购组织可以同时负责几个工厂的采购。&lt;/li&gt;
&lt;li&gt;定义物料组：0001 原材料、0002 产成品和 0003 贸易商品。在维护主数据的时候，需要分配物料组。&lt;/li&gt;
&lt;li&gt;定义计划边际码。这个操作满足这样一种情况：公司除了正常的采购和生产时间，还规定在操作、产前、产后和订单下达各阶段预留一天的缓冲时间。这样的规则被定义在 “计划边际码” 中。&lt;/li&gt;
&lt;li&gt;工厂中有很多控制参数。如在库存管理中，对库存物料可以通过预留号进行预留，比如预留给生产订单或者销售订单。设定该工厂对于库存的预留允许比计划日期提前一个月使用，同时过期一个月以内的预留仍然可以使用。&lt;/li&gt;
&lt;li&gt;维护和库存相关的工厂参数 - 自动创建物料的库存地点视图。只有某个视图被定义了，才可以对这个物料进行某项操作。&lt;/li&gt;
&lt;li&gt;由于公司收到的发票大多是 17% 的增值税发票，因此这里我们可以把它设为缺省值，方便发票校验。因此我们可以在此处维护税务代码的缺省值。&lt;/li&gt;
&lt;li&gt;物料管理在 SAP 中只能开当月的账，或者至多当月或者上个月的账，而且开账只允许一个月一个月往后开，因此一开始我们要设定一个初始期间。
一般初始期间设为上线前的那个月，如 12 月上线，就设定初始日期为 11 月，在 11 月中导入期末库存余额。&lt;/li&gt;
&lt;li&gt;维护和物料需求计划相关的工厂参数。这部分涉及的参数很多，首先可以采用先复制之前的，再更改不适用的参数。&lt;/li&gt;
&lt;li&gt;此处激活物料需求计划 MRP 这项功能，通过后台的配置实现。&lt;/li&gt;
&lt;li&gt;此处定义计划运行的号码范围。运行物料需求计划会产生很多凭证，比如计划订单、非独立需求等，这些凭证都有它们的编号范围。
在 13 步复制 0001 的时候，这些编号范围都已经复制了，这里只需要进行检查。&lt;/li&gt;
&lt;li&gt;物料类型是定义物料主数据的最重要的一个参数。它决定了各类物料主数据需要维护哪些信息和参数，物料主数据的编号范围等。
公司决定使用 SAP 标准的物料类型：HAWA 贸易商品、ROH 原材料、FERT 产成品。&lt;/li&gt;
&lt;li&gt;定义评估控制，激活按 “评估分组代码” 来定义科目，这样可以当集团公司有很多工厂时候，而它们的记账规则又是一样，不用一个一个的进行维护，而是将工厂集合成组统一来定义记账规则。&lt;/li&gt;
&lt;li&gt;将之前定义的工厂归入我们的 CN01 评估分组代码，这样以后该集团增加工厂时候，只需要把它分配给 CN01 就可以了，而不必再定义一套记账规则。&lt;/li&gt;
&lt;li&gt;除了工厂，另一个决定不同的会计科目的因素是物料本身，此处我们在物料主数据中定义一个 “评估类” 参数，通过 “评估类” 来决定会计科目。
本处我们使用标准评估类：3000 原材料、3100 贸易商品、7920 成品。&lt;/li&gt;
&lt;li&gt;这时可以进行原材料主数据的录入了（MMRL）。填入相应的采购组、物料组 MRP 控制者、计划边际码等。&lt;/li&gt;
&lt;li&gt;随后新建贸易商品主数据 MMH1。&lt;/li&gt;
&lt;li&gt;新建生产成品主数据 MMF1。&lt;/li&gt;
&lt;li&gt;创建完各种物料后，可以在 MM60 中显示物料主记录清单。&lt;/li&gt;
&lt;li&gt;创建供应商的采购数据 MK01。创建的时候要填采购组织，账户组，账户组是在 FI 的时候创建的。
供应商的采购数据是和具体的采购组织相关的，也就是说不同的采购组织向同一个供应商采购，可以有不同的规定。&lt;/li&gt;
&lt;li&gt;新建采购信息记录 ME11。采购信息记录包括信息如标准订单数量，净价，几天内交货，由哪个采购组负责等。
保存这样的数据，可以方便实际采购时候参照使用。&lt;/li&gt;
&lt;li&gt;设置 SAP 中最为重要的集成配置之一，即物料移动在 SAP 中如何自动找到会计科目完成自动记账。&lt;/li&gt;
&lt;li&gt;将存货科目设置为只能自动记账，在 FS00 中实现。&lt;/li&gt;
&lt;li&gt;SAP 在处理采购订单时，会检查采购订单中的价格和物料主数据的成本价格差异有多大，同时也会检查采购订单中的现金折扣是否可接受。
如果差异超过一定的荣差，系统会发出警告消息或者错误信息。
不同的容差检查存放在 “容差码” 中，容差码 “PE” 是检查价格的，“SE” 是检查现金折扣的。这里复制 0001 公司的采购价格差异的容差限制。&lt;/li&gt;
&lt;li&gt;SAP 允许采购订单定价数量单位和采购订单数量单位有所不同。比如采购订单数量是按件，但定价是按斤。
这种情况下，收货的时候，两种单位的数量都要输入。在收货的时候，系统会检查定价数量和采购订单中的差异。
这里通过复制 0001 的方式建立公司的收货容差限制。&lt;/li&gt;
&lt;li&gt;SAP 系统在发票校验的时候会做大量检查，如果校验不通过发票就会被冻结。这里复制 0110 的容差检查。&lt;/li&gt;
&lt;li&gt;维护公司的项目全额检查。&lt;/li&gt;
&lt;li&gt;在 MD03 中运行物料需求计划，MD04 可以显示库存 / 需求清单。（MD05 显示 MRP 清单）。&lt;/li&gt;
&lt;li&gt;这里计划部门手动创建采购申请（ME51N）。根据采购申请，采购部门需要向供应商采购（ME21N）。&lt;/li&gt;
&lt;li&gt;进行采购收货（MIGO）。（MB03 显示凭证；显示库存 MMBE）&lt;/li&gt;
&lt;li&gt;供应商采购发票随后到达，在 MIRO 中输入发票，由于发票比采购订单原定的日期提前到达，并超过了荣差，所以发票被冻结了。&lt;/li&gt;
&lt;li&gt;被冻结的发票可以经过相关管理人员检查后手工下达，这里我们下达 35 步被冻结的发票。事物码 MRBR。&lt;/li&gt;
&lt;li&gt;在 MIR4 中显示发票和会计凭证。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;mm常用透明表&#34;&gt;MM常用透明表&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Table&lt;/th&gt;
&lt;th&gt;Desc&lt;/th&gt;
&lt;th&gt;Table&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Desc&lt;/th&gt;
&lt;th&gt;Table&lt;/th&gt;
&lt;th&gt;Desc&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;MARA&lt;/td&gt;
&lt;td&gt;物料主数据&lt;/td&gt;
&lt;td&gt;MARC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;物料工厂(在途库存)&lt;/td&gt;
&lt;td&gt;MSKA&lt;/td&gt;
&lt;td&gt;销售订单库存&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;MAKT&lt;/td&gt;
&lt;td&gt;物料描述&lt;/td&gt;
&lt;td&gt;MARD&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;物料库存(当前库存)&lt;/td&gt;
&lt;td&gt;T001L&lt;/td&gt;
&lt;td&gt;工厂库位关系&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;MARM&lt;/td&gt;
&lt;td&gt;物料的计量单位&lt;/td&gt;
&lt;td&gt;MARDH&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;历史库存&lt;/td&gt;
&lt;td&gt;T001W&lt;/td&gt;
&lt;td&gt;工厂表&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;MBEW&lt;/td&gt;
&lt;td&gt;物料评估/价格&lt;/td&gt;
&lt;td&gt;MSKU&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;第三方库存表&lt;/td&gt;
&lt;td&gt;RKPF&lt;/td&gt;
&lt;td&gt;预留抬头&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;MKPF&lt;/td&gt;
&lt;td&gt;物料凭证抬头&lt;/td&gt;
&lt;td&gt;EKKO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;采购订单抬头&lt;/td&gt;
&lt;td&gt;EINE&lt;/td&gt;
&lt;td&gt;Purchasing Org&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;MSEG&lt;/td&gt;
&lt;td&gt;物料凭证明细&lt;/td&gt;
&lt;td&gt;EKPO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;采购订单明细&lt;/td&gt;
&lt;td&gt;EINA&lt;/td&gt;
&lt;td&gt;Info record(G_data)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;MVKE&lt;/td&gt;
&lt;td&gt;物料的销售数据&lt;/td&gt;
&lt;td&gt;EBAN&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;采购申请抬头&lt;/td&gt;
&lt;td&gt;MAST&lt;/td&gt;
&lt;td&gt;物料到BOM link&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;MVVE&lt;/td&gt;
&lt;td&gt;物料的销售数据&lt;/td&gt;
&lt;td&gt;EBKN&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;采购申请明细&lt;/td&gt;
&lt;td&gt;MVER&lt;/td&gt;
&lt;td&gt;物料消耗&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T023&lt;/td&gt;
&lt;td&gt;物料类型&lt;/td&gt;
&lt;td&gt;LFA1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;供应商主数据&lt;/td&gt;
&lt;td&gt;T161T&lt;/td&gt;
&lt;td&gt;采购订单类型文本&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T024&lt;/td&gt;
&lt;td&gt;采购组&lt;/td&gt;
&lt;td&gt;LFB1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Vendor master&lt;/td&gt;
&lt;td&gt;EKET&lt;/td&gt;
&lt;td&gt;安排协议交付时间表&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T157H&lt;/td&gt;
&lt;td&gt;移动类型帮助文档&lt;/td&gt;
&lt;td&gt;RESB&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;保留/依赖 要求&lt;/td&gt;
&lt;td&gt;EKKN&lt;/td&gt;
&lt;td&gt;采购订单账号分配&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;NRIV&lt;/td&gt;
&lt;td&gt;数字范围间隔&lt;/td&gt;
&lt;td&gt;EKBE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;历史采购订单&lt;/td&gt;
&lt;td&gt;EKAB&lt;/td&gt;
&lt;td&gt;发布文档&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ISEG&lt;/td&gt;
&lt;td&gt;实物盘存凭证项目&lt;/td&gt;
&lt;td&gt;A501&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;冻结购买价格。&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;IKPF&lt;/td&gt;
&lt;td&gt;实物盘存凭证抬头&lt;/td&gt;
&lt;td&gt;USR21&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;SAP所有用户信息&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;mm配置&#34;&gt;MM配置&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;1. 创建工厂、公司代码                    22. 批量导入物料主数据（BAPI）
2. 创建库存地点                         23. 创建供应商
3. 创建采购组织                         24. 创建采购信息记录（Info Recode）
4. 创建采购组                           25. 维护物料管理的自动记账
5. MRP Controller                      26. 将存货科目设置为只能自动记账
6. 分配工厂到公司                       27. 设置采购价格差异容差限制
7. 分配采购组织到公司                    28. 设置收货的容差限制
8. 分配工厂到采购组织                    29. 设置发票冻结的容差限制
9. 定义物料                             30. 激活项目金额检查
10. 定义计划边界码                      31. 运行MRP
11. 物料管理设置-库存预留                32. 创建采购申请
12. 自动创建库存地点                    33. 创建采购订单
13. 税务代码缺省值                      34. 采购订单收货
14. 物料管理的初始期间                  35. 采购发票输入
15. 物料需求计划相关的参数维护           36. 发票冻结
16. 激活物料需求计划                    37. 在MIR4中显示发票和会计凭证
17. 检查MRP相关参数维护(主要看01范围)
18. 定义物料类型的属性
19. 定义评估控制方式
20. 定义评估分组
21. 定义评估类
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fi配置&#34;&gt;FI配置&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;1. 创建会计科目表   (A999账目表)
2. 定义会计年度变式 (正常记账期间12、特殊期间4)
3. 创建信贷控制范围
4. 依据以上信息维护公司参数
5. 定义科目账户组合编号范围、
6. 定义公司字段状态变式
7. 把字段状态分配到公司代码
8. 定义预留收益科目
9. FS00科目批量导入 （LSMW）
10. 赋值凭证号码范围到公司代码
11. 定义记账期间变式
12. 把记账期间变式分配给公司代码
13. 拷贝设置记账期间
14. 为科目过账定义容差组
15. 输入总账凭证，显示科目余额
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>SAP memory使用</title>
      <link>https://coldinfire.github.io/2019/ABAPMemory/</link>
      <pubDate>Mon, 04 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/ABAPMemory/</guid>
      <description>

&lt;h3 id=&#34;sap-memory和abap-memory&#34;&gt;SAP memory和ABAP memory&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用的语句不同&lt;/p&gt;

&lt;p&gt;SAP memory使用SET/GET parameters；&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SPA：SET PARAMETER ID &amp;lsquo;MAT&amp;rsquo; FIELD p_matnr.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;GPA：GET PARAMETER ID &amp;lsquo;MAT&amp;rsquo; FIELD p_matnr.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ABAP Memory使用EXPORT 和IMPORT :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;EXPORT p_matnr = p_matnr TO MEMORY ID &amp;lsquo;ZTESTMAT&amp;rsquo;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;IMPORT p_matnr = p_matnr FROM MEMORY ID &amp;lsquo;ZTESTMAT&amp;rsquo;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;FREE MEMORY ID &amp;lsquo;ZTESTMAT&amp;rsquo;.         清空指定的ABAPmemory&lt;/p&gt;

&lt;p&gt;FREE MEMORY.                                    清空externalsession内的所有ABAPmemory&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;共享范围不同&lt;/p&gt;

&lt;p&gt;SAP memory用于所有external session间.&lt;/p&gt;

&lt;p&gt;ABAP memory用于同一个external session的internal session间。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;作用范围不同（就是生存期）&lt;/p&gt;

&lt;p&gt;SAP memory在登陆到退出这期间一直有效。&lt;/p&gt;

&lt;p&gt;ABAP memory只在同一个session(window) 内有效。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Dialog获取SAPMemory方式&lt;/p&gt;

&lt;p&gt;在dialog 屏幕上建一个input field, 然后Parameter ID属性与&amp;rsquo;SAP_MMR&amp;rsquo;绑定,并打上2个勾。&lt;/p&gt;

&lt;p&gt;Set Parameter: 允许将屏幕值返回给SAP Memory (类似于执行SET PARAMETER ID语句)&lt;/p&gt;

&lt;p&gt;Get Parameter: 允许读取SAP Memory的值并默认显示(类似于执行GET PARAMETER ID语句).&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>
