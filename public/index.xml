<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Small Fire`s Blog on Small Fire`s Blog</title>
    <link>https://coldinfire.github.io/</link>
    <description>Recent content in Small Fire`s Blog on Small Fire`s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 21 Dec 2019 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://coldinfire.github.io/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Books</title>
      <link>https://coldinfire.github.io/books/</link>
      <pubDate>Thu, 15 Jun 2017 23:39:47 +0800</pubDate>
      
      <guid>https://coldinfire.github.io/books/</guid>
      <description>

&lt;h3 id=&#34;开卷有益&#34;&gt;开卷有益&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Number&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;th&gt;State&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;img width=200/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img width=500/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img width=500/&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://book.douban.com/subject/1084336/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;小王子&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://book.douban.com/subject/1023045/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;我们仨&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;孩子你慢些走&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://book.douban.com/subject/1008145/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;围城&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://book.douban.com/subject/5346110/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;穷查理宝典&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;🕐&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://book.douban.com/subject/3533221/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;非暴力沟通&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://book.douban.com/subject/1056295/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;人性的弱点&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;🕐&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://book.douban.com/subject/20427187/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;看见&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://coldinfire.github.io/about/</link>
      <pubDate>Thu, 15 Jun 2017 23:39:47 +0800</pubDate>
      
      <guid>https://coldinfire.github.io/about/</guid>
      <description>&lt;p&gt;这个人很懒，什么都没留下&amp;hellip;&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABAP BTE增强使用</title>
      <link>https://coldinfire.github.io/2019/ABAP_BTE/</link>
      <pubDate>Sat, 21 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/ABAP_BTE/</guid>
      <description>

&lt;h3 id=&#34;配置bte&#34;&gt;配置BTE&lt;/h3&gt;

&lt;p&gt;Tcode：FIBF&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/ABAP/BTE1.png&#34; alt=&#34;BTE&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/ABAP/BTE3.png&#34; alt=&#34;Add entries&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/ABAP/BTE2.png&#34; alt=&#34;BTE&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/ABAP/BTE4.png&#34; alt=&#34;BTE&#34; /&gt;&lt;/p&gt;

&lt;p&gt;BTE查找技巧：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;BTE 技巧：
  1）在 FM：`BF_FUNCTIONS_FIND`，设断点，然后查看 CALL FUNCTION &#39;BF_FUNCTIONS_READ&#39; 里面的变量，可以查看这个流程，会触发那些 event，以及那些 customerFM，这样就可以在相应的 EVENT 开发对应的 ZFM。
  2）查找对应合适的 BTE：运行事务码 XD02，查找到对应的程序为 SAPMF02D，在此程序中搜索字符串 “OPEN_FI_PERFORM”，可以找到此程序中的所有用到的 BTE。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;​&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title> CS12 ALV的增强 </title>
      <link>https://coldinfire.github.io/2019/BOM_Enhance/</link>
      <pubDate>Tue, 19 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/BOM_Enhance/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Tcode：CS12的执行程序查看&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/ABAP/BOM_Enhance1.png&#34; alt=&#34;CS12&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，最终执行的程序是RCS12001，因此可以在该程序中查找增强。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/ABAP/BOM_Enhance2.png&#34; alt=&#34;RCS12001&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;执行的程序：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;RCS11001 Display BOM Level by Level&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;RCS12001 Display Multilevel BOM&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;RCS13001 Summarized BOM - Multilevel&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;User Exits:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;PCSD0001：Applications development R/3 BOMS&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PCSD0002： BOMs: Customer fields in item&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PCSD0003： BOMs: Customer fields in header&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PCSD0004： BOM comparison&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PCSD0005 BOMs: component check for material items&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PCSD0006： Mass changes user exit&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PCSD0007： Check changes in STKO&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PCSD0008： WBS BOM: Customer-specific explosion for creating&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PCSD0009： Order/WBS BOM, determine URL page&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PCSD0010： Order/WBS BOM, determine explosion date&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PCSD0011： Knowledge-based order BOM, parallel update&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PCSD0012： Customer - Mat. number/mat. number during material exchange&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PCSD0013： Customer-specific processing of an explosion for BOM browser&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PCSD0014： Knowledge-Based Order BOM: Status&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SAP JCO连接</title>
      <link>https://coldinfire.github.io/2019/SAP_JCO/</link>
      <pubDate>Wed, 13 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/SAP_JCO/</guid>
      <description>

&lt;h4 id=&#34;sap-jco简介&#34;&gt;SAP JCO简介&lt;/h4&gt;

&lt;p&gt;​   为了在R/3系统和JAVA平台之间进行实时的交换数据。SAP提供了一套高效的基于RFC的ABAP和JAVA进程间通讯组件：SAP JAV Connector.&lt;/p&gt;

&lt;p&gt;​   Jco库提供了可以直接在JAVA程序中使用的API.该API通过JNI调用部署在客户端的SAP的RFC库。&lt;/p&gt;

&lt;h4 id=&#34;安装与配置&#34;&gt;安装与配置&lt;/h4&gt;

&lt;p&gt;​   下载Jco库的jar包。然后解压，将文件librfc32.dll的文件复制到目录system32下面。这个文件就是SAP的RFC协议实现。然后确保CLASSPATH环境下包含文件sapjco.jar所在的目录。该jar包中包含有在JAVA程序中需要直接调用的类和接口。&lt;/p&gt;

&lt;h4 id=&#34;建立连接&#34;&gt;建立连接&lt;/h4&gt;

&lt;p&gt;​   类JCO是Jco库中最主要的一个入口，提供了很多静态方法。其中有一系列重载的createClient方法可以用来创建于SAP系统的连接信息。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;直接输入参数&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;  import com.sap.mw.jco.*;
  JCO.Client myCont = JCO.createClient(&amp;quot;000&amp;quot;,        //SAP Client
                                       &amp;quot;UserName&amp;quot;,   //userid
                                       &amp;quot;PassWord&amp;quot;,   //password
                                       &amp;quot;EN&amp;quot;,         //Language
                                       &amp;quot;ClientIP&amp;quot;,   //application server host name
                                       &amp;quot;ClientID&amp;quot;)   //system number
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;使用JAVA 配置文件&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;  Properties properties = new Properties();
  properties.put(&amp;quot;jco.client.ashost&amp;quot;,&amp;quot;HostIP&amp;quot;);
  properties.put(&amp;quot;jco.client.client&amp;quot;,&amp;quot;client&amp;quot;);
  properties.put(&amp;quot;jco.client.user&amp;quot;,&amp;quot;user&amp;quot;);
  properties.put(&amp;quot;jco.client.passwd&amp;quot;,&amp;quot;passwd&amp;quot;);
  properties.put(&amp;quot;jco.client.sysnr&amp;quot;,&amp;quot;00&amp;quot;);
  properties.put(&amp;quot;jco.client.lange&amp;quot;,&amp;quot;EN&amp;quot;);
  
  JCO.Client myCont = JCO.createClient(properties);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;​   建立从当前JAVA进程到SAP服务器的连接:  &lt;code&gt;this.myCont.connect();&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​   获取连接状态：&lt;code&gt;if( myCont != null &amp;amp;&amp;amp; myCont.isAlive())&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&#34;连接池&#34;&gt;连接池&lt;/h5&gt;

&lt;p&gt;​   Jco库支持以连接池的形式重用已经创建的连接。需要调用JCO类的静态方法addClientPool即可创建一个连接池，并可以在参数中指定连接池的名字和允许同时激活的最大连接数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;public static final String POOL_NAME = &amp;quot;JCO_Pool&amp;quot;;
public static int max_cont = 3;

JCO.Pool pool = JCO.getClientPoolManager().getPool(POOL_NAME);
if(poo == null){
   Properties properties = new Properties();
    ... read properties file ...
   JCO.addClientPool(POOL_NAME,max_cont,properties);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取连接：&lt;code&gt;myCont = JCO.getClient(POOL_NAME);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;释放连接：&lt;code&gt;JCO.releaseClient(myCont);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;移除连接池：&lt;code&gt;JCO.removeClientPool(POOL_NAME);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;移除连接池会导致其中所有的活动连接被迫强行关闭，必须在确保连接池中所有的连接都不在被使用时才能执行该操作。&lt;/p&gt;

&lt;h4 id=&#34;调用function-models&#34;&gt;调用Function Models&lt;/h4&gt;

&lt;p&gt;​   Jco库使用RFC的方式来调用ABAP中的函数，所以被调用的函数必须已经勾选&amp;rdquo;Remote-enabled&amp;rdquo;属性。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一步：创建JCO.Repository类的对象，获取所有ABAP函数的元数据。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;JCO.Repository myRepository = new JCO.Repository(&amp;quot;Repository&amp;quot;,myCont/POOL_NAME);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;构造函数有两个参数，第一个是可以任意指定的名字；第二个是当前使用的连接。可以指定连接池名字，Jco库会自动从该连接池获取连接&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第二步：通过该实例获取函数的信息。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;  String strFunc = &amp;quot;BAPI_Name&amp;quot;;
  IFunctionTemplate ft =  myRepository.getFunctionTemplate(strFunc.toUpperCase());
  JCO.Function function = ft.getFunction();
  
  //Get a client form the pool
  JCO.Clietn client = JCO.getClient(pool);
  
  //Set up scalar parameter
  JCO.ParameterList input = function.getImportParameterList();
  input.setValue(10,&amp;quot;MAX_ROWS&amp;quot;);
  
  //Set up structure parameter
  JCO.Structure sFrom = input.getStructure(&amp;quot;STRUC_NAME&amp;quot;);
  sFrom.seValue(&amp;quot;Value&amp;quot;,&amp;quot;FIELD_NAME&amp;quot;);
  input.setValue(sFrom,&amp;quot;STRUC_NAME&amp;quot;);
  
  //Set up table parameter
  JCO.Table table = function.getTableParameterList().getTable(&amp;quot;TABLE_NAME&amp;quot;);
  table.appendRow();
  table.setRow(0);
  talbe.setValue(&amp;quot;Value&amp;quot;,&amp;quot;FIELD_NAME&amp;quot;);
  ....
  table.appendRow();
  table.setRow(n);
  table.setValue(&amp;quot;Value&amp;quot;,&amp;quot;FIELD_NAME&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第三步：执行&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;JCO.Client client = JCO.getClient(POOL_NAME); client.execute(function);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;myCont.execute(funtion);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第四步：关闭连接&lt;code&gt;myCont.disconnect();&lt;/code&gt;或则&lt;code&gt;JCO.releaseClient(myCont)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第五步：获取输出参数&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;  // GET export structure
  JCO.Structure struct = function.getExportParameterList.getStructure(&amp;quot;RETURN&amp;quot;);
  
  //GET table parameter
  JCO.Table table = function.getTableParameterList().getTable(&amp;quot;TABLE_NAME&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;异常处理&#34;&gt;异常处理&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;JCO.AbapException：ABAP函数执行过程中出现异常，在JAVA进程中触发该异常。&lt;/li&gt;
&lt;li&gt;JCO.ConversionException：当执行参数的get,set方法时，如果在Java类型和ABAP类型间转换失败，会触发该异常。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;调试&#34;&gt;调试&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;激活Jco的ABAP调试功能：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  JCO.Pool pool = JCO.getClientPoolManage().getPool(POOL_NAME);
  pool.setAbapDebug(true);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在ABAP程序内设置外部断点。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;并设置Debugging里设置External Debugging的Users为设置的外部名。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;data-type&#34;&gt;DATA TYPE&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ABAP Type&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;JAVA Data Type&lt;/th&gt;
&lt;th&gt;JCo Type Code&lt;/th&gt;
&lt;th&gt;JCo Access Method&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;1-byte integer&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;JCO.TYPE_INT1&lt;/td&gt;
&lt;td&gt;int getInt()&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;s&lt;/td&gt;
&lt;td&gt;2-byte integer&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;JCO.TYPE_INT2&lt;/td&gt;
&lt;td&gt;int getInt()&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;td&gt;4-byte integer&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;JCO.TYPE_INT&lt;/td&gt;
&lt;td&gt;int getInt()&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;Character&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;JCO.TYPE_CHAR&lt;/td&gt;
&lt;td&gt;String getString()&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;Numerical Character&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;JCO.TYPE_NUM&lt;/td&gt;
&lt;td&gt;String getString()&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;P&lt;/td&gt;
&lt;td&gt;Binary Coded Decimal&lt;/td&gt;
&lt;td&gt;BigDecimal&lt;/td&gt;
&lt;td&gt;JCO.TYPE_BCD&lt;/td&gt;
&lt;td&gt;BigDecimal getBigDecimal()&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;D&lt;/td&gt;
&lt;td&gt;Date&lt;/td&gt;
&lt;td&gt;Date&lt;/td&gt;
&lt;td&gt;JCO.TYPE_DATE&lt;/td&gt;
&lt;td&gt;Date getDate()&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;Time&lt;/td&gt;
&lt;td&gt;Date&lt;/td&gt;
&lt;td&gt;JCO.TYPE_TIME&lt;/td&gt;
&lt;td&gt;Date getTime()&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;JCO.TYPE_FLOAT&lt;/td&gt;
&lt;td&gt;double getDouble()&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;Raw data&lt;/td&gt;
&lt;td&gt;bytes[]&lt;/td&gt;
&lt;td&gt;JCO.TYPE_BYTE&lt;/td&gt;
&lt;td&gt;byte[] getByteArray()&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;g&lt;/td&gt;
&lt;td&gt;String(variable-length)&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;JCO.TYPE_STRING&lt;/td&gt;
&lt;td&gt;String getString()&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;y&lt;/td&gt;
&lt;td&gt;Raw data&lt;/td&gt;
&lt;td&gt;byte[]&lt;/td&gt;
&lt;td&gt;JCO.TYPE_XSTRING&lt;/td&gt;
&lt;td&gt;byte[] getByteArray()&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;jco-table-method&#34;&gt;JCO Table method&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;JCO.Table Method&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;int getNumRows()&lt;/td&gt;
&lt;td&gt;Returns teh number of rows&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;void setRow(int pos)&lt;/td&gt;
&lt;td&gt;Sets the current row pointer&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;int getRow()&lt;/td&gt;
&lt;td&gt;Returns the current row pointer&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;void firstRow()&lt;/td&gt;
&lt;td&gt;Moves to the first row&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;void firstRow()&lt;/td&gt;
&lt;td&gt;Moves to the last row&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;boolean nextRow()&lt;/td&gt;
&lt;td&gt;Moves to the next row&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;boolean previousRow(0)&lt;/td&gt;
&lt;td&gt;Moves to the previous row&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;void appendRow()&lt;/td&gt;
&lt;td&gt;Adds one row at the end of the table&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;void appendRow(int num_rows)&lt;/td&gt;
&lt;td&gt;Adds multiple rows at the end of table&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;void deleteAllRows()&lt;/td&gt;
&lt;td&gt;Deletes all table rows&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;void deleteRow()&lt;/td&gt;
&lt;td&gt;Delete the current row&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;void deleteRow(int pos)&lt;/td&gt;
&lt;td&gt;Deletes the specified row&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;void insertRow(int pos)&lt;/td&gt;
&lt;td&gt;Inserts a row at the specified position&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>ABAP 科学计数法问题</title>
      <link>https://coldinfire.github.io/2019/ABAP_NumberQAS/</link>
      <pubDate>Sun, 20 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/ABAP_NumberQAS/</guid>
      <description>

&lt;h4 id=&#34;科学计数法转换数字&#34;&gt;科学计数法转换数字&lt;/h4&gt;

&lt;p&gt;​   ABAP 函数 &lt;code&gt;QSS0_FLTP_TO_CHAR_CONVERSION&lt;/code&gt;，能将 SAP 系统内的科学计数法显示的数字转换成一般数字。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;DATA: l_result TYPE qsollwerte,
       l_value TYPE char16.
       
CALL FUNCTION &#39;QSS0_FLTP_TO_CHAR_CONVERSION&#39;
  EXPORTING
    i_number_of_digits  = 2
    i_fltp_value        = l_result
  IMPORTING
    e_char_field        = l_value
           .
  CONDENSE l_value.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;数字千分位的转换处理&#34;&gt;数字千分位的转换处理&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;DATA: p_value type p,
       l_value TYPE char16.

CALL FUNCTION &#39;HRCM_STRING_TO_AMOUNT_CONVERT&#39;
  EXPORTING
    string            = l_value
    decimal_separator  = &#39;.&#39;
  IMPORTING
    betrg                     = p_value
  EXCEPTIONS
    convert_error             = 1
    OTHERS                    = 2
           .
IF sy-subrc = 1.
   CALL FUNCTION &#39;HRCM_STRING_TO_AMOUNT_CONVERT&#39;
     EXPORTING
       string            = l_value
       decimal_separator = &#39;,&#39;
     IMPORTING
       betrg             = p_value
     EXCEPTIONS
       convert_error     = 1
       OTHERS            = 2.
ENDIF.


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;既要有千分位又要把符号提前的情况:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;*&amp;amp;---------------------------------------------------------------------*
*&amp;amp;      Form  NUMTOSTR
*&amp;amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&amp;gt;VALUE      text
*      --&amp;gt;(ZNUM)     text
*      --&amp;gt;VALUE      text
*      --&amp;gt;(ZSTR)     text
*----------------------------------------------------------------------*
FORM  numtostr CHANGING  p_is_result_amount
                         ``p_is_result_amount_h
                         ``p_is_result_total
                         ``p_is_result_total_h.
  ``DATA : zclen TYPE i,
  ``n TYPE i,
  ``zcstr(30) TYPE c,
  ``zcstr2(30) TYPE c,
  ``zctemp(3) TYPE c,
  ``zflag(1) TYPE c VALUE ``&#39;.&#39;``,
  ``zflag2 TYPE i VALUE 0,
  ``zcdec(30) TYPE c, &amp;quot;记录小数部分.
  ``znum(30),
  ``znum_h(30),
  ``ztotal(30),
  ``ztotal_h(30).
  ``&amp;quot;zstr = ``&#39;&#39;``.
  ``znum = is_result-amount.
  ``znum_h = is_result-amount_h.
  ``ztotal = is_result-total.
  ``ztotal_h = is_result-total_h.
  ``CLEAR: is_result-amount,is_result-amount_h,is_result-total,is_result-total_h.
*---------------------------------------------------------------------------------------------*1
  ``IF znum &amp;lt;&amp;gt; 0.
    ``IF znum &amp;lt;= -1000.
      ``zflag2 = 1.
      ``znum = znum * ( -1 ).
    ``ENDIF.
    ``IF znum &amp;gt;= 1000.
      ``zcstr = znum.
* 压缩字符串，去除前面的空格。
      ``CONDENSE zcstr NO-GAPS.
* 分离整数与小数，好单独处理整数。
      ``SPLIT zcstr AT zflag INTO zcstr zcdec.
      ``zclen = ``strlen``( zcstr ).
* 在循环中从右面在每三位的前面加上一个逗号。
      ``WHILE zclen &amp;gt; 3.
        ``n = zclen - 3.
        ``zctemp = zcstr+n(3).
        ``IF NOT zcstr2 IS INITIAL.
          ``CONCATENATE zctemp zcstr2 INTO zcstr2 SEPARATED BY ``&#39;,&#39;``.
        ``ELSE.
          ``zcstr2 = zctemp.
        ``ENDIF.
        ``zclen = zclen - 3.
      ``ENDWHILE.
* 将不剩下的不足三位数加到前面
      ``CONCATENATE zcstr+0(zclen) zcstr2 INTO zcstr2 SEPARATED BY ``&#39;,&#39;``.
      ``IF zflag2 = 1.
        ``CONCATENATE ``&#39;-&#39;` `zcstr2 INTO zcstr2.
      ``ENDIF.
      ``CLEAR zcstr.
* 将处理过的整数与小数连接起来。
      ``IF ``strlen``( zcdec ) &amp;gt; 1.
        ``CONCATENATE zcstr2 zcdec INTO zcstr SEPARATED BY zflag.
      ``ELSE.
        ``CONCATENATE zcdec ``&#39;00&#39;` `INTO zcdec.
        ``CONCATENATE zcstr2 zcdec  INTO zcstr SEPARATED BY zflag.
      ``ENDIF.
* 将值返回
      ``is_result-amount = zcstr.
    ``ELSE.
      ``is_result-amount = znum.
    ``ENDIF.
  ``ENDIF.
  ``CLEAR: zflag2,zcstr,zcdec,zclen,zctemp,zcstr2,n.
ENDFORM
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;计算数学表达式的方法&#34;&gt;计算数学表达式的方法&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;FORM cacule_value  USING    p_wf_formula TYPE string
                            p_source  TYPE string
                            p_js_processor TYPE REF TO cl_java_script
                   CHANGING p_value .
  DATA:molecule TYPE string,
     denominator TYPE string,
     denominator_source TYPE string,
     denominator_value  TYPE rr_szntr,
     l_result TYPE qsollwerte,
     l_value TYPE char16.

  IF p_wf_formula CS &#39;/&#39;.
    CLEAR:molecule,denominator.
    SPLIT p_wf_formula AT &#39;/&#39; INTO molecule denominator.
    CONCATENATE
    &#39;var string = &#39; denominator &#39;;&#39;
    &#39;function Set_String()                          &#39;
    &#39;  { string = eval(string);                     &#39;
    &#39;  }                                            &#39;
    &#39;Set_String();                                  &#39;
    &#39;string;                                        &#39;
      INTO denominator_source SEPARATED BY cl_abap_char_utilities=&amp;gt;cr_lf.
    denominator_value = js_processor-&amp;gt;evaluate( denominator_source ).
    IF denominator_value = 0.
      p_value = 0.
    ELSE.
      CONCATENATE
      &#39;var string = &#39; p_wf_formula &#39;;&#39;
      &#39;function Set_String()                          &#39;
      &#39;  { string = eval(string);                     &#39;
      &#39;  }                                            &#39;
      &#39;Set_String();                                  &#39;
      &#39;string;                                        &#39;
        INTO p_source SEPARATED BY cl_abap_char_utilities=&amp;gt;cr_lf.
      l_result = js_processor-&amp;gt;evaluate( p_source ).
*      p_value = js_processor-&amp;gt;evaluate( p_source ).

      CALL FUNCTION &#39;QSS0_FLTP_TO_CHAR_CONVERSION&#39;
        EXPORTING
          i_number_of_digits             = 2
          i_fltp_value                   = l_result
*         I_VALUE_NOT_INITIAL_FLAG       = &#39;X&#39;
*         I_SCREEN_FIELDLENGTH           = 16
       IMPORTING
         e_char_field                   = l_value
                .
      CONDENSE l_value.

      CALL FUNCTION &#39;HRCM_STRING_TO_AMOUNT_CONVERT&#39;
        EXPORTING
          string                    = l_value
         decimal_separator         = &#39;.&#39;
*         THOUSANDS_SEPARATOR       =
*         WAERS                     = &#39; &#39;
       IMPORTING
         betrg                     = p_value
       EXCEPTIONS
         convert_error             = 1
         OTHERS                    = 2
                .
      IF sy-subrc = 1.
        CALL FUNCTION &#39;HRCM_STRING_TO_AMOUNT_CONVERT&#39;
          EXPORTING
            string            = l_value
            decimal_separator = &#39;,&#39;
          IMPORTING
            betrg             = p_value
          EXCEPTIONS
            convert_error     = 1
            OTHERS            = 2.
      ENDIF.

    ENDIF.
  ELSE.
    CONCATENATE
      &#39;var string = &#39; p_wf_formula &#39;;&#39;
      &#39;function Set_String()                          &#39;
      &#39;  { string = eval(string);                     &#39;
      &#39;  }                                            &#39;
      &#39;Set_String();                                  &#39;
      &#39;string;                                        &#39;
        INTO p_source SEPARATED BY cl_abap_char_utilities=&amp;gt;cr_lf.
    p_value = js_processor-&amp;gt;evaluate( p_source ).
  ENDIF.
ENDFORM.                    &amp;quot; CACULE_VALUE
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>SO10创建标准文本</title>
      <link>https://coldinfire.github.io/2019/ABAP_SO10/</link>
      <pubDate>Fri, 18 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/ABAP_SO10/</guid>
      <description>&lt;p&gt;通过 Tcode SO10 可以创建标准文本：&lt;/p&gt;

&lt;p&gt;​   &lt;img src=&#34;https://coldinfire.github.io/images/ABAP/SO10.png&#34; alt=&#34;SO10&#34; /&gt;&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;p&gt;通过占位符替换长文本：&lt;/p&gt;

&lt;p&gt;​   &lt;img src=&#34;https://coldinfire.github.io/images/ABAP/SO10_1.png&#34; alt=&#34;SO10 Symbol&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;DATA lv_name TYPE thead-tdname.
DATA lv_langu LIKE sy-langu VALUE &#39;EN&#39;.
DATA lt_line TYPE STANDARD TABLE OF tline WITH HEADER LINE.
DATA lv_count TYPE i.
lv_name = &#39;Z_TEST&#39;.
&amp;quot;read text from SO10
  CALL FUNCTION &#39;READ_TEXT&#39;
  EXPORTING
    client                  = sy-mandt
    id                      = &#39;ST&#39;
    language                = lv_langu
    name                    = lv_name
    object                  = &#39;TEXT&#39;
  TABLES
    lines                   = lt_line
  EXCEPTIONS
    id                      = 1
    language                = 2
    name                    = 3
    not_found               = 4
    object                  = 5
    reference_check         = 6
    wrong_access_to_archive = 7
    OTHERS                  = 8.
  IF sy-subrc EQ 0 .
&amp;quot;initialize the text symbols
  CALL FUNCTION &#39;INIT_TEXTSYMBOL&#39;.
&amp;quot;set dynamic text symbol
  CALL FUNCTION &#39;SET_TEXTSYMBOL&#39;
    EXPORTING
      name    = &#39;&amp;amp;l_aa&amp;amp;&#39;
      value   = &#39;输入需要替换的内容&#39;
      replace = &#39;X&#39;.
  DESCRIBE TABLE lt_line LINES lv_count.
&amp;quot;replace all text symbol in your long text
  CALL FUNCTION &#39;REPLACE_TEXTSYMBOL&#39;
    EXPORTING
      endline   = lv_count
      startline = 1
    TABLES
      lines     = lt_line.
ENDIF.
LOOP AT lt_line.
  WRITE:/ lt_line-tdline.
ENDLOOP.
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>IDoc操作</title>
      <link>https://coldinfire.github.io/2019/ABAP_IDoc/</link>
      <pubDate>Sun, 22 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/ABAP_IDoc/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://www.baidusap.com/abap/ale_edi_idoc/782&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;idoc&#34;&gt;IDoc&lt;/h3&gt;

&lt;h4 id=&#34;1-idoc简介&#34;&gt;1.IDoc简介&lt;/h4&gt;

&lt;p&gt;IDoc:是基于文档，用作异步传输数据的载体，类似于XML;使用功能场景：假设 1040 和 1020 是同一个集团下两个不同子公司的 SAP 系统，1040 需要将其采购订单信息及时发送给 1020，可以使用IDoc传输。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;IDOC 的整个配置，涉及了远程连接、ALE、消息控制、tRFC 等技术的集成&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;IDoc支持异步、同步、可以收集一定数量的包后发送，最重要的是，IDOC有完整的监控系统和错误处理机制。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;IDoc支持SAP系统集团之间，SAP-CRM/SRM/PI等之间，SAP-第三方系统之间的集成&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过系统预定义IDOC类型，可以自动收集IDoc，挂JOB定时发送，也可以配置消息控制。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;数据段是IDoc结构组件，是IDoc构成的单元;有Segment type：数据段类型与Segment.definition：数据段定义&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;:Segment type名称与SAP版本无关，以&amp;rdquo;E1/Z1&amp;rdquo;开头&lt;/li&gt;
&lt;li&gt;:Segment definition名称与SAP版本有关，外部系统确定数据段版本的关键；以&amp;rdquo;E2/Z2&amp;rdquo;开头+版本号
访问IDoc中具体某个字段时，需要通过Segment type。&lt;/li&gt;
&lt;li&gt;IDoc包含多个Segment,每个Segment内包含有多个字段&lt;/li&gt;
&lt;li&gt;Segment类似于XML的节点以及节点属性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;IDoc特性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IDoc 包含有三种类型的记录：一条控制记录，一个或多个数据记录，一个或多个状态记录&lt;/li&gt;
&lt;li&gt;IDoc type：IDoc 结构，不同的 SAP 业务对象对应不同的 IDoc 类型（一个或多个）。&lt;/li&gt;
&lt;li&gt;IDoc 类型中定义了数据段（Segment）以及数据段的层级和次序。定义节点间的相互逻辑关系。&lt;/li&gt;
&lt;li&gt;标准 SAP 系统提供的 IDoc 类型称为基本类型（Basic type），该类型可以通过 IDoc 扩展（Extention）进行调整，即在 SAP IDoc 类型结构的基础上增加新的数据段或者在数据段中增加新字段。&lt;/li&gt;
&lt;li&gt;IDoc Basic Type: 是承载数据的一个类型，可以认为是一个数据结构。Basic Type 由 Segment 构成，有点类似于 XML 的格式。每个 Segment 指定了一些字段，在这些字段里面可以输入一些限定的数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;2-包含组件&#34;&gt;2.包含组件&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ALE（Application Link and Enabling）是 SAP 专门为 SAP 与 SAP 之间所设计的整合中间件，多用于同一个企业中不同 SAP 系统之间的数据交换，通过 IDoc 格式的数据创建分布式系统 。分布式数据交换提供了可靠安全的通讯机制。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;EDI（Electronic Document Interchange，电子数据交换）其实就是采用标准格式的电子数据，用于在通讯网络中在业务伙伴间交换业务文档所用。按相同的排列放置数据到一个数据文档中，并按相同的排列解析此文档以得到所需的内容。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;IDoc（Intermediate Document，中转文档）是 SAP 提供的系统整合专用的数据 / 消息格式，它通过 ALE 方式来进行交换，IDoc 提供了 EDI 的支持，可以认为 IDoc 是 EDI 的一个实现。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;3-idoc发送接收流程&#34;&gt;3.IDoc发送接收流程&lt;/h4&gt;

&lt;p&gt;外发过程（Outbound process：OP）:处理数据集并发出消息&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;应用文档被创建&lt;/li&gt;
&lt;li&gt;IDoc 生成&lt;/li&gt;
&lt;li&gt;IDoc 从 SAP 传送到操作系统&lt;/li&gt;
&lt;li&gt;IDoc 被转换成 EDI 标准格式&lt;/li&gt;
&lt;li&gt;EDI 文件被传送到业务伙伴处（所以业务伙伴可以没有 SAP，因为 EDI 是个标准）&lt;/li&gt;
&lt;li&gt;EDI 子系统将传送的状态回报给 SAP&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接收过程（Inbound process：IP）：接收消息并处理&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;EDI 文档被接收&lt;/li&gt;
&lt;li&gt;EDI 文档被转换成 IDoc&lt;/li&gt;
&lt;li&gt;IDoc 传送到 SAP 层&lt;/li&gt;
&lt;li&gt;应用文档在 SAP 中创建&lt;/li&gt;
&lt;li&gt;应用文档现在可供浏览了&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;4-idoc流程步骤及tcode&#34;&gt;4.IDoc流程步骤及TCode&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;    外发配置(OP)   					   接收配置(IP)
WE31:创建IDOC所需要的字段                        WE31:开发Segment Type
WE30:开发IDOC基本类型和扩展，把Segment分配给IDOC   WE81：开发Message Type
WE81：开发Message Type
WE82:Message Type和IDoc Type绑定                WE82:Message Type和IDoc Type绑定
BD64:添加视图模型，添加消息类型配置伙伴参数    BD64:增加消息类型
WE20:配置发送系统出站信息                     WE20:配置接收系统入站信息
SE38:编写发送程序                            SE37:编写接收接口
WE14:若为黄灯，手动发送                       WE57:分配IDOC类型给处理函数
BD51:配置进站函数模块属性
WE42:配置进站处理代码
WE02:IDOC发送信息检查
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;5-process-code处理代码设定&#34;&gt;5.Process Code处理代码设定&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;WE41,WE42,WE40,WE64&lt;/li&gt;
&lt;li&gt;处理代码用于确定数据写入 IDoc 或从 IDoc 读取的处理方式，处理代码对应具体的功能模块或者工作流。入站和出站处理的伙伴参数中都可以指定处理代码&lt;/li&gt;
&lt;li&gt;Outbound Process Code: 出站的处理代码。其实就是具体的一个操作流程。在得到了 Output Type，确定了 IDoc Basic Type 以后，需要从 Output Type 提供的所有数据里面，按 IDoc Basic Type 组合出 IDoc 来，即给 IDoc Basic Type 赋值。&lt;/li&gt;
&lt;li&gt;Inbound Process Code: 进站的处理代码。就是接收到一个 IDoc 以后，根据 Message Type 来确定要怎么处理这个 IDoc。&lt;/li&gt;
&lt;li&gt;程序的思路就是，把每个 IDOC 结点按字符串形式逐个添加，而字符串的添加次序自然也体现了 IDOC 结点间的逻辑关系。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;6-端口-port-we21&#34;&gt;6.端口（Port）：WE21&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;端口用于外发流程，它判断 EDI 子系统程序名称、IDoc 文件传送到操作系统的目录，IDoc 文件名和 RFC 目的地&lt;/li&gt;
&lt;li&gt;端口，指定这个 IDoc 的接收方，可以是任何其他系统，也可以发到当前的 SAP 当前的 Client。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;7-rfc目的地-sm59&#34;&gt;7.RFC目的地：SM59&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;用于定义到远程系统通讯连接的特性以及需要调用何种功能&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;8-partnr-profile-we20&#34;&gt;8.Partnr Profile：WE20&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Partnr:对口的合作伙伴&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Partner Profile：是Partner的一些参数，分为OP和IP.它们是为了让系统知道怎么去处理 Outbound/Inbound 的事件.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Partner Profile 指定在外发过程中所用的各类组件（业务伙伴号、IDoc 类型、信息类型、端口、处理码等），通讯方式（异步或同步）以及当错误时通知何人&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;9-message-type&#34;&gt;9.Message Type&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;用于消息类型的处理，就是告诉 Inbound 一方，我这个 IDoc 是用来做什么的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;WE81， 创建Message type&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;WE82，连接 Message type和 IDOC type&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;10-idoc类型定义的相关函数&#34;&gt;10.IDoc类型定义的相关函数&lt;/h4&gt;

&lt;p&gt;函数组 EDIM 中的 SAP 内部功能模块用于操作 IDoc 基本类型和扩展：OBJECT代指所操作的队象，既IDOCTYPE或EXTTYPE.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;[OBJECT]_CREATE&lt;/li&gt;
&lt;li&gt;[OBJECT]_UPDATE&lt;/li&gt;
&lt;li&gt;[OBJECT]_READ&lt;/li&gt;
&lt;li&gt;[OBJECT]_DELETE&lt;/li&gt;
&lt;li&gt;[OBJECT]_CLOSE&lt;/li&gt;
&lt;li&gt;[OBJECT]_UNCLOSE&lt;/li&gt;
&lt;li&gt;[OBJECT]_EXISTENCE_CHECK&lt;/li&gt;
&lt;li&gt;[OBJECT]_INTEGRITY_CHECK&lt;/li&gt;
&lt;li&gt;[OBJECT]_TRANSPORT&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;函数组EDIJ中的SAP内部功能模块用于操作IDoc数据段&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SEGMENT_CREATE&lt;/li&gt;
&lt;li&gt;SEGMENT_MODIFY&lt;/li&gt;
&lt;li&gt;SEGMENT_DELETE&lt;/li&gt;
&lt;li&gt;SEGMENT_INITION_DELETE&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;11-idoc常用tcode&#34;&gt;11.IDoc常用TCode&lt;/h4&gt;

&lt;p&gt;SAP 提供了一个事务码列出的基本上所有的 IDoc 相关的事务码&lt;code&gt;WEDI&lt;/code&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;/BD87&lt;/th&gt;
&lt;th&gt;/WE18&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;/SUIM&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/SM58&lt;/td&gt;
&lt;td&gt;/WE19&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;/GS03&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/WE09&lt;/td&gt;
&lt;td&gt;/WE20&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;/BDLS&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>ABAP字符串处理</title>
      <link>https://coldinfire.github.io/2019/ABAP_String/</link>
      <pubDate>Wed, 18 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/ABAP_String/</guid>
      <description>&lt;p&gt;​       字符串的处理在程序中的使用十分常见，在这里结合自己日常的使用对ABAP的字符串常用操作进行总结，以便后续使用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.获取字符串长度&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;var1  = strlen(str);&lt;/code&gt;将str作为字符数据处理，计算出其字符长度&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;  DATA: l_len type i,
        str1(20) VALUE &#39;1234&#39;.
    l_len = strlen(str1).
  WRITE: / len.  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.拼接字符串&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CONCATENATE &amp;lt;str1&amp;gt; ... &amp;lt;strn&amp;gt; into &amp;lt;var&amp;gt; [SEPARATED BY &amp;lt;s&amp;gt;][RESPECTING BLANKS]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将多个字符串拼接到指定的变量Var中，注意Var的长度&lt;/li&gt;
&lt;li&gt;C,D,N,T类型的前导空格会保留，尾部空格会去掉，对String类型的所有空格都会保留&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[SEPARATED BY &amp;lt;s&amp;gt;]&lt;/code&gt;:根据该间隔符号(S)进行拼接(SPACE)&lt;/li&gt;
&lt;li&gt;respecting：针对C,D,N,T数据，表示尾部空格会保留&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3.压缩字符串&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CONDENCE &amp;lt;str&amp;gt; [NO-GAPS]&lt;/code&gt;:去除字段str中的前后空格，并将字段中多个空格使用一个空格替换；如果加上NO-GAPS则去除所有空格。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;4.截取字符串&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;subtext = str+0(4)：从最左边取出4个字符&lt;/li&gt;
&lt;li&gt;subtext = str+2(4)：从第2个字符开始取出4个字符&lt;/li&gt;
&lt;li&gt;str+0(1) = &amp;lsquo;X&amp;rsquo;：变更指定位置的值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;5.查找字符串&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SEARCH &amp;lt;var&amp;gt; FOR &amp;lt;str&amp;gt; &amp;lt;options&amp;gt;.&lt;/code&gt;:在var中搜索子字符串，成功SY-SUBRC=0&lt;/li&gt;
&lt;li&gt;str:可以使用正则表达式，也可以使用普通字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;6.替换字符串&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;REPLACE &amp;lt;str1&amp;gt; WITH &amp;lt;str2&amp;gt; INTO &amp;lt;var&amp;gt; [LENGTH &amp;lt;l&amp;gt;].&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将str1在var中的字段替换为str2&lt;/li&gt;
&lt;li&gt;如果指定长度，则只将str1中指定长度的字符替换为str2中的内容&lt;/li&gt;
&lt;li&gt;如果替换后内容总长度超过var定义的长度，会出现截断现象&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;7.移动字符串内容&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;SHIFT &amp;lt;var&amp;gt; [BY &amp;lt;n&amp;gt; PLACES] [&amp;lt;mode&amp;gt;].&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将var移动n个位置，&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;MODE:LEFT(默认),RIGHT,CIRCULAR&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;SHIFT &amp;lt;var&amp;gt; LEFT DELETING LEADING &amp;lt;str&amp;gt;.&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;SHIFT &amp;lt;var&amp;gt; RIGHT DELETING TRAILING &amp;lt;str&amp;gt;.&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果左边第一个字符串或则右边第一个字符串出现在str中，将var移动相应的位置&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;8.比较字符串&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;判断是否包含特定值&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IF field CN &amp;lsquo;0123456789&amp;rsquo;.&lt;/li&gt;
&lt;li&gt;IF field CN &amp;lsquo;ABCDEFG*&amp;rsquo;&lt;/li&gt;
&lt;li&gt;IF field CN &amp;lsquo;abcdefg*&amp;rsquo;&lt;/li&gt;
&lt;li&gt;IF field CN &amp;lsquo;/&amp;rsquo; &amp;hellip;..&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;CN：Contains Not Only (包含，不仅包含)&lt;/strong&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;&lt;strong&gt;CO：Contains Only（仅包含）&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;CS：Contains String (包含字符串)&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;NS：Contains No String (不包含字符串)&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;NP：No Pattern （不包含记号）&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;NA：Contains Not Only(不包含任何)&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;CA：Contains Any（包含任何）&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;CP：Covers Pattern (包含记号)&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;9.&lt;strong&gt;拆分字符串&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;​   SPLIT dobj AT sep INTO {res1 res2&amp;hellip;&amp;hellip;resn}. ：将字符串的值分配给具体变量&lt;/p&gt;

&lt;p&gt;​   SPLIT s_source AT sep INTO TABLE itab：将字符串的值分配给一内表。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10.大小写转换：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   TRANSLATE c TO UPPER|LOWER CASE.：将字符串转换为大|小写&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;11.字符前拼接空格&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   在Grid ALV上也显示空格：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;IF &amp;lt;fw_output&amp;gt;-name2+0(1) eq space AND &amp;lt;fw_output&amp;gt;-name2 IS NOT INITIAL.
  h_white = cl_abap_conv_in_ce=&amp;gt;uccpi( 160 ).
  REPLACE ALL OCCURRENCES OF REGEX &#39;\s&#39; IN &amp;lt;fw_output&amp;gt;-name2 WITH h_white.
ENDIF.
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>SQVI-创建一张简易的报表</title>
      <link>https://coldinfire.github.io/2019/SAP_SQVI/</link>
      <pubDate>Wed, 28 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/SAP_SQVI/</guid>
      <description>&lt;p&gt;SAP提供的SQVI功能，用以快速自定义一个自己需要的报表。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建，并选择数据源为：表连接，然后插入需要查数的表，接着将表的主键进行连接&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;完成所有表的插入后，点击返回按钮，系统将进入报表显示及筛选字段的选择界面，将报表需要显示的字段筛选出来&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;完成报表中字段的选择后，点击“选择字段”。我们知道，每一个报表都需要筛选界面，在“选择字段”中，就是用于我们添加筛选界面的筛选字段。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;“筛选字段”与“报表显示字段”选择完毕后，我们可以点击执行，创建并展示出这一报表。我们可以根据实际业务，输入筛选条件，并查出需要的数据。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>生产订单标准BAPI</title>
      <link>https://coldinfire.github.io/2019/SAP_PO_BAPI/</link>
      <pubDate>Wed, 28 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/SAP_PO_BAPI/</guid>
      <description>

&lt;h3 id=&#34;创建po&#34;&gt;创建PO&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;*&amp;amp;---------------------------------------------------------------------*
*&amp;amp;      Form  FRM_ORDER_CREATE
*&amp;amp;---------------------------------------------------------------------*
*----------------------------------------------------------------------*
&amp;quot;--&amp;gt;  p1        text
&amp;quot;&amp;lt;--  p2        text
*----------------------------------------------------------------------*
  FORM frm_order_create .
  DATA: ls_upload LIKE LINE OF gt_upload,
        ls_style  TYPE lvc_s_styl,
        lv_index  LIKE sy-tabix.
  DATA: ls_order  TYPE bapi_pp_order_create,
        ls_return TYPE bapiret2,
        lv_ordnum TYPE bapi_order_key-order_number,
        lv_ordtyp TYPE bapi_order_copy-order_type.
  LOOP AT gt_upload INTO ls_upload WHERE ztype EQ space AND box EQ &#39;X&#39;.
    lv_index = sy-tabix.
    CLEAR: ls_order, ls_return, lv_ordnum, lv_ordtyp, ls_style.
    IF ls_upload-externind EQ &#39;X&#39;.
      ls_order-order_number = ls_upload-aufnr.
    ENDIF.
    ls_order-material = ls_upload-plnbez.
    ls_order-plant = ls_upload-dwerk.
    ls_order-planning_plant = ls_upload-dwerk.
    ls_order-order_type = ls_upload-dauat.
    ls_order-quantity = ls_upload-gamng.
    ls_order-quantity_uom = ls_upload-gmein.
    ls_order-basic_start_date = ls_upload-gstps.
    ls_order-basic_start_time = ls_upload-gsuzs.
    ls_order-basic_end_date = ls_upload-gltps.
    ls_order-basic_end_time  = ls_upload-gluzs.
    ls_order-unloading_point = ls_upload-ablad.
    ls_order-sequence_number = ls_upload-cy_seqnr.
    IF ls_upload-verid NE space.
      ls_order-prod_version = ls_upload-verid.
    ENDIF.
    IF ls_upload-lgort NE space.
      ls_order-storage_location = ls_upload-lgort.
    ENDIF.
    CALL FUNCTION &#39;BAPI_PRODORD_CREATE&#39;
      EXPORTING
        orderdata    = ls_order
      IMPORTING
        return       = ls_return
        order_number = lv_ordnum
        order_type   = lv_ordtyp.
    IF lv_ordnum NE space.
      CALL FUNCTION &#39;BAPI_TRANSACTION_COMMIT&#39;
        EXPORTING
          wait = &#39;X&#39;.
      CLEAR: ls_upload-fstyle, ls_upload-fstyle[].
      ls_style-style = cl_gui_alv_grid=&amp;gt;mc_style_disabled.
      INSERT ls_style INTO TABLE ls_upload-fstyle.
      ls_upload-aufnr = lv_ordnum.
      ls_upload-ztype = &#39;S&#39;.
      ls_upload-message = &#39;Update successfully&#39;.
    ELSE.
      ls_upload-ztype = ls_return-type.
      CALL FUNCTION &#39;BAPI_TRANSACTION_ROLLBACK&#39;.
    ENDIF.
    IF ls_return-type NE space.
      APPEND ls_return TO ls_upload-retmsg.
    ENDIF.
    IF ls_upload-ztype = &#39;E&#39; .
      ls_upload-zcol = &#39;C610&#39; .
    ENDIF .
    MODIFY gt_upload FROM ls_upload INDEX lv_index.
  ENDLOOP.
  ENDFORM.                    &amp;quot; FRM_ORDER_CREATE
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;修改po&#34;&gt;修改PO&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;*&amp;amp;---------------------------------------------------------------------*
*&amp;amp;      Form  frm_order_change
*&amp;amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM frm_order_change.
  DATA: ls_upload LIKE LINE OF gt_upload,
        ls_style  TYPE lvc_s_styl,
        lv_index  LIKE sy-tabix.

  DATA: ls_order  TYPE bapi_pp_order_change,
        ls_orderx TYPE bapi_pp_order_changex,
        ls_return TYPE bapiret2,
        lv_ordnum TYPE bapi_order_key-order_number,
        lv_ordtyp TYPE bapi_order_copy-order_type.

  LOOP AT gt_upload INTO ls_upload WHERE
                                       box EQ &#39;X&#39;.

    lv_index = sy-tabix.
    CLEAR: ls_order, ls_return, lv_ordnum, lv_ordtyp, ls_style, ls_orderx.

    ls_order-quantity = ls_upload-gamng.
    ls_order-quantity_uom = ls_upload-gmein.
    ls_order-basic_start_date = ls_upload-gstps.

    ls_upload-gltps = ls_upload-gstps + ls_upload-nlfzt .
    ls_order-basic_end_date = ls_upload-gltps .
    ls_order-unloading_point = ls_upload-ablad.
    ls_order-sequence_number = ls_upload-cy_seqnr.
    ls_order-prod_version = ls_upload-verid.
    ls_order-storage_location = ls_upload-lgort.
*    ls_order-TERKZ

    ls_orderx-quantity = &#39;X&#39;.
    ls_orderx-basic_start_date = &#39;X&#39;.
    ls_orderx-basic_end_date = &#39;X&#39;.
    ls_orderx-sequence_number = &#39;X&#39;.
    ls_orderx-unloading_point = &#39;X&#39;.
    ls_orderx-storage_location = &#39;X&#39;.
    ls_orderx-prod_version = &#39;X&#39;.

    CALL FUNCTION &#39;BAPI_PRODORD_CHANGE&#39;
      EXPORTING
        number     = ls_upload-aufnr
        orderdata  = ls_order
        orderdatax = ls_orderx
      IMPORTING
        return     = ls_return.

    IF ls_return-type EQ &#39;S&#39; OR ls_return-type EQ space.
      CALL FUNCTION &#39;BAPI_TRANSACTION_COMMIT&#39;
        EXPORTING
          wait = &#39;X&#39;.

      CLEAR: ls_upload-fstyle, ls_upload-fstyle[].
      ls_style-style = cl_gui_alv_grid=&amp;gt;mc_style_disabled.
      INSERT ls_style INTO TABLE ls_upload-fstyle.
      ls_upload-ztype = &#39;S&#39;.

      ls_upload-id = c_green.
      ls_upload-message = &#39;Updated successfully&#39;.
    ELSE.
      ls_upload-ztype = ls_return-type.
      ls_upload-id = c_red.
      ls_upload-message = ls_return-message.
      CALL FUNCTION &#39;BAPI_TRANSACTION_ROLLBACK&#39;.
    ENDIF.


    IF ls_return-type NE space.
      APPEND ls_return TO ls_upload-retmsg.
    ENDIF.

    IF ls_upload-ztype = &#39;E&#39; .
      ls_upload-zcol = &#39;C610&#39; .
    ENDIF .

    MODIFY gt_upload FROM ls_upload INDEX lv_index.
  ENDLOOP.

ENDFORM.                    &amp;quot;frm_order_change
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;order-release&#34;&gt;Order Release&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;*&amp;amp;---------------------------------------------------------------------*
*&amp;amp;      Form  frm_order_RELEASE
*&amp;amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM frm_order_release.
  DATA: ls_upload LIKE LINE OF gt_upload,
        ls_style  TYPE lvc_s_styl,
        lv_index  LIKE sy-tabix.

  DATA: lt_orders  TYPE TABLE OF bapi_order_key WITH HEADER LINE,
        ls_return  TYPE bapiret2,
        lt_detail_return TYPE TABLE OF bapi_order_return WITH HEADER LINE.

  LOOP AT gt_upload INTO ls_upload WHERE ztype EQ &#39;S&#39; AND box EQ &#39;X&#39;.
    lv_index = sy-tabix.

    CLEAR:lt_orders.
    lt_orders-order_number = ls_upload-aufnr.
    APPEND lt_orders .

    CALL FUNCTION &#39;BAPI_PRODORD_RELEASE&#39;
     EXPORTING
       release_control          = &#39;1&#39;
*     WORK_PROCESS_GROUP       = &#39;COWORK_BAPI&#39;
*     WORK_PROCESS_MAX         = 99
     IMPORTING
        return                   = ls_return
     TABLES
        orders                   = lt_orders
        detail_return            = lt_detail_return
*     APPLICATION_LOG          =
              .
    IF ls_return-number EQ space.
      CALL FUNCTION &#39;BAPI_TRANSACTION_COMMIT&#39;
        EXPORTING
          wait = &#39;X&#39;.

      CLEAR: ls_upload-fstyle, ls_upload-fstyle[].
      ls_style-style = cl_gui_alv_grid=&amp;gt;mc_style_disabled.
      INSERT ls_style INTO TABLE ls_upload-fstyle.

      ls_upload-aufnr = lt_orders-order_number.
      ls_upload-xtype = &#39;S&#39;.
    ELSE.
      &amp;quot;if lt_DETAIL_RETURN-NUMBER eq &#39;093&#39;.
      &amp;quot;ls_upload-xtype = lt_DETAIL_RETURN-MESSAGE.
      &amp;quot;endif.
      IF lt_detail_return-number EQ &#39;086&#39;.
        ls_upload-xtype = lt_detail_return-message.
        ls_upload-zcol = &#39;C610&#39; .
      ENDIF.
      CALL FUNCTION &#39;BAPI_TRANSACTION_ROLLBACK&#39;.
    ENDIF.
    MODIFY gt_upload FROM ls_upload INDEX lv_index.
  ENDLOOP.

ENDFORM.                    &amp;quot;frm_order_RELEASE
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>获取工单的Work Center</title>
      <link>https://coldinfire.github.io/2019/SAP_WorkCenter/</link>
      <pubDate>Wed, 28 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/SAP_WorkCenter/</guid>
      <description></description>
    </item>
    
    <item>
      <title>SAP Product Order status</title>
      <link>https://coldinfire.github.io/2019/SAP_PO/</link>
      <pubDate>Sun, 25 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/SAP_PO/</guid>
      <description>

&lt;h3 id=&#34;sap生产订单状态&#34;&gt;SAP生产订单状态&lt;/h3&gt;

&lt;h4 id=&#34;sap-系统的常见订单状态如下&#34;&gt;&lt;strong&gt;SAP 系统的常见订单状态如下：&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CRTD (创建)：&lt;/strong&gt;标识生产订单刚刚创建，此时禁止做后续发料和报工确认等操作；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PREL (部分下达)：&lt;/strong&gt;当生产订单部分下达时，如仅下达部分工序时出现此状态；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;REL    (已下达)：&lt;/strong&gt;当生产任务已经明确可下发生产时，将生产订单转换为已下达状态，这个状态后可以继续后续业务操作，如打印订单、发料、报完工等操作；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MANC (未检查物料可用性)：&lt;/strong&gt;生产订单未进行零部件物料的可用性检查；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SETC (结算规则维护)：&lt;/strong&gt;生产订单已维护结算规则；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MSPT (物料短缺)：&lt;/strong&gt;生产订单的零部件物料在进行可用性检查后发现存在短缺；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MACM (已承诺的物料)：&lt;/strong&gt;生产订单的零部件物料在进行可用性检查后确认完全可用；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GMPS (已过帐的货物移动)：&lt;/strong&gt;生产订单已经进行过发料；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PCNF (部分确认)：&lt;/strong&gt;生产订单只进行了部分完工确认，比如说订单需求 10 个，只进行了 5 个生产，或者订单有 2 道工序，只完成了第一道工序；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CNF (已确认) ：&lt;/strong&gt;生产订单已全部完工确认；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PDLV (部分交货)：&lt;/strong&gt;生产订单只有部分产品入库；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DLV (交货) ：&lt;/strong&gt;生产订单已经完全交货入库，这意味着生产订单业务全部完成。CO 看到 DLV 状态或 TECO 状态时将对订单进行完工结算。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;VCAL (差异计算) ：&lt;/strong&gt;生产订单进行过差异运算；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TECO (技术完成) ：&lt;/strong&gt;在生产过程中，会出现订单未完成但是不再继续生产的情况，这时就可以打上技术完结标识，此时订单对零部件的需求同时删除。在很多项目中，为了简便处理，会对所有完成的订单进行技术完结处理 (注：不再继续生产也是一种完成)。CO 看到 DLV 状态或 TECO 状态时将对订单进行完工结算；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RESA (进行结果分析)：&lt;/strong&gt;生产订单进行过结算；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CLSD (关闭)：&lt;/strong&gt;生产订单做账务关闭，不允许对订单发生任何过账，通常情况下，财务月末对订单进行结算后，如果确认不会再有追加发料等业务发生，则应该将订单进行关闭；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DLID (删除) ：&lt;/strong&gt;对生产订单做删除标识，数据仍然存在数据库中，状态可恢复。如果想彻底删除，需对订单进行归档处理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;状态相关表&#34;&gt;状态相关表&lt;/h4&gt;

&lt;p&gt;​   根据工单可以去&lt;strong&gt;AUFK&lt;/strong&gt;表中找到工单对应的Object Number(OBJNR).状态表为：&lt;strong&gt;JEST,&lt;/strong&gt; 字段 OBJNR 为 OR + 订单号，STAT 即为订单状态。但是 STAT 的都是 I 打头的状态，通过 &lt;strong&gt;CO03&lt;/strong&gt; 看生产订单状态都是英文简短字段标识。两者间的关系保存在表&lt;strong&gt;TJ02&lt;/strong&gt;中，&lt;strong&gt;TJ02T&lt;/strong&gt;：系统状态文本表（一般文本表都是标准表后加T）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/Resource/AUFK.png&#34; alt=&#34;AUFK&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/Resource/JEST.png&#34; alt=&#34;JEST&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/Resource/TJ02.png&#34; alt=&#34;TJ02&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/Resource/TJ02T.png&#34; alt=&#34;TJ02T&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;函数使用&#34;&gt;函数使用&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;STATUS_READ：获取输入工单的状态&lt;/li&gt;
&lt;li&gt;STATUS_CHECK：检查生产订单状态，看是否有某种状态&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;状态判断&#34;&gt;状态判断&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;通过JEST表中的状态判断读取,需要根据AUFNR在表AUFK中获取OBJNR字段&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;  DATA:jest type standard table jest.
  SELECT SINGLE * FROM aufk WHERE aufnr = it_table-aufnr. &amp;quot;
  &amp;quot;判定工单状态
  &amp;quot; 判定工单是否 RELASE
  CLEAR: jest.
  SELECT SINGLE * FROM jest
  WHERE objnr = aufk-objnr
  AND ( stat = &#39;I0002&#39; OR &amp;quot; RELEASE
  stat = &#39;I0042&#39;) &amp;quot; Partial RELEASE
  AND inact = space.
  IF sy-subrc &amp;lt;&amp;gt; 0.
  CONTINUE.
  ENDIF.
  
  &amp;quot; 判定工单状态
  CLEAR: jest.
  SELECT SINGLE * FROM jest
  WHERE objnr = aufk-objnr
  AND ( stat = &#39;I0045&#39; OR &amp;quot; TECO
  stat = &#39;I0013&#39; OR &amp;quot; DELETE
  stat = &#39;I0076&#39; OR &amp;quot; DELETE FLAG
  stat = &#39;I0046&#39; OR &amp;quot; CLSD
  stat = &#39;I0012 &#39;) &amp;quot;DLV
  AND inact = space.
  IF sy-subrc = 0.
  CONTINUE.
  ENDIF.
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ABAP混合算术运算</title>
      <link>https://coldinfire.github.io/2019/ABAP_MixedCalculate/</link>
      <pubDate>Mon, 12 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://coldinfire.github.io/2019/ABAP_MixedCalculate/</guid>
      <description>

&lt;h3 id=&#34;使用&#34;&gt;使用&lt;/h3&gt;

&lt;p&gt;​   在ABAP程序中将数值与表达式分别存放，通过表达式计算对应的结果。&lt;/p&gt;

&lt;h4 id=&#34;一-调用bapi-eval-formula&#34;&gt;一、调用BAPI：EVAL_FORMULA&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;TYPES:BEGIN OF TY_VAL,
      OPERAND TYPE C,
      VALUE TYPE STRING,
      END OF TY_VAL.
TYPES:BEGIN OF TY_FRM,
      NO TYPE I,
      FORMULA TYPE CHAR50,
      END OF TY_FRM.
DATA:IT_VAL TYPE TABLE OF TY_VAL,
     WA_VAL TYPE TY_VAL.
DATA:IT_FORMULA TYPE TABLE OF TY_FRM,
     WA_FRM TYPE TY_FRM.
DATA:WF_STRING TYPE CHAR255,
     WF_LEN TYPE I,
     WF_FORMULA TYPE CHAR50.
DATA: WF_RETCODE      LIKE SY-SUBRC,
      WF_FUNCNAME(30) TYPE C,
      WF_MESSAGE(70)  TYPE C,
      WF_POS          TYPE I,
      WF_C            TYPE P LENGTH 15 DECIMALS 2.
      
WA_VAL-OPERAND = &#39;A&#39;.
WA_VAL-VALUE = &#39;1&#39;.
APPEND WA_VAL TO IT_VAL.
WA_VAL-OPERAND = &#39;B&#39;.
WA_VAL-VALUE = &#39;2&#39;.
APPEND WA_VAL TO IT_VAL.
WA_VAL-OPERAND = &#39;C&#39;.
WA_VAL-VALUE = &#39;3&#39;.
APPEND WA_VAL TO IT_VAL.
WA_FRM-NO = 1.
WA_FRM-FORMULA = &#39;A*B+C&#39;.
APPEND WA_FRM TO IT_FORMULA.
WA_FRM-NO = 2.
WA_FRM-FORMULA = &#39;C*(A-B)&#39;.
APPEND WA_FRM TO IT_FORMULA.
LOOP AT IT_FORMULA INTO WA_FRM.
  WF_STRING = WA_FRM-FORMULA.
  WF_FORMULA = WA_FRM-FORMULA.
  REPLACE ALL OCCURRENCES OF REGEX &#39;[^[:alpha:]]&#39; IN WF_STRING WITH ` `.
  CONDENSE WF_STRING NO-GAPS.
  WF_LEN = STRLEN( WF_STRING ).
  DO WF_LEN TIMES.
    SY-INDEX = SY-INDEX - 1.
    READ TABLE IT_VAL INTO WA_VAL WITH KEY OPERAND = WF_STRING+SY-INDEX(1).
    IF SY-SUBRC = 0.
      REPLACE ALL OCCURRENCES OF WF_STRING+SY-INDEX(1)
                              IN WF_FORMULA
                              WITH WA_VAL-VALUE.
    ENDIF.
  ENDDO.
  CALL FUNCTION &#39;CHECK_FORMULA&#39;
    EXPORTING
      FORMULA  = WF_FORMULA
    IMPORTING
      SUBRC    = WF_RETCODE
      FUNCNAME = WF_FUNCNAME
      MESSAGE  = WF_MESSAGE
      POS      = WF_POS.
  IF WF_RETCODE IS INITIAL.
    CALL FUNCTION &#39;EVAL_FORMULA&#39;
      EXPORTING
        FORMULA = WF_FORMULA
      IMPORTING
        VALUE   = WF_C
      EXCEPTIONS
        OTHERS  = 1.
    IF SY-SUBRC = 0.
      WRITE: / WA_FRM-FORMULA,&#39;-&#39;, WF_C.
    ELSE.
      WRITE: / &#39;Error&#39;..
    ENDIF.
  ELSE.
    WRITE: / WF_FUNCNAME, WF_MESSAGE, WF_POS.
  ENDIF.
ENDLOOP.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;替换表达式的运算单位&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;REPLACE ALL OCCURRENCES OF REGEX &#39;[^[:alnum:]]&#39; IN WF_STRING WITH ‘ ’&lt;/code&gt; .&lt;/li&gt;
&lt;li&gt;&lt;code&gt;REPLACE ALL OCCURRENCES OF REGEX &#39;[^[:alpha:]]&#39; IN WF_STRING WITH ‘ ’&lt;/code&gt; .&lt;/li&gt;
&lt;li&gt;``：两个表示空格&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;将字符串切分保存到内表&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SPLIT  WF_STRING  AT SPACE INTO TABLE table_name.&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;二-通过直接调用表达式完成计算&#34;&gt;二、通过直接调用表达式完成计算&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;DATA: MESSAGE TYPE STRING,
      SOURCE TYPE STRING,
      RETURN_VALUE TYPE P LENGTH 15 DECIMALS 2,
      TXT_VAR1 TYPE CHAR40,
      TXT_VAR2 TYPE CHAR40,
      TXT_VAR3 TYPE CHAR40 VALUE &#39;987979.234-&#39;.

CALL FUNCTION &#39;CLOI_PUT_SIGN_IN_FRONT&#39;
  CHANGING
    VALUE  = TXT_VAR3.

MESSAGE = &#39;(-351422999.55+-59211228.95+-1297670.94+-3135583.53+-35337844.40)*100/(613848716.07+0.00+-1552672.73)&#39;.

DATA: JS_PROCESSOR TYPE REF TO CL_JAVA_SCRIPT.
  JS_PROCESSOR = CL_JAVA_SCRIPT=&amp;gt;CREATE( ).
    CONCATENATE
      &#39;var string = &#39; MESSAGE &#39;;&#39;
      &#39;function Set_String()                          &#39;
      &#39;  { string = eval(string);                     &#39;
      &#39;  }                                            &#39;
      &#39;Set_String();                                  &#39;
      &#39;string;                                        &#39;
    INTO SOURCE SEPARATED BY
    CL_ABAP_CHAR_UTILITIES=&amp;gt;CR_LF.
RETURN_VALUE = JS_PROCESSOR-&amp;gt;EVALUATE( SOURCE ).
WRITE: RETURN_VALUE.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;实际使用&#34;&gt;实际使用&lt;/h4&gt;

&lt;p&gt;​   可以将以上两种方法进行结合，计算出表达式的结果。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Search</title>
      <link>https://coldinfire.github.io/search/</link>
      <pubDate>Thu, 08 Aug 2019 15:05:27 +0800</pubDate>
      
      <guid>https://coldinfire.github.io/search/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
