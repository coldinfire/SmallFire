<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Small Fire`s Blog on Small Fire`s Blog</title>
    <link>https://coldinfire.github.io/</link>
    <description>Recent content in Small Fire`s Blog on Small Fire`s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 22 Jun 2019 15:15:42 +0800</lastBuildDate>
    <atom:link href="https://coldinfire.github.io/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Books</title>
      <link>https://coldinfire.github.io/books/</link>
      <pubDate>Thu, 15 Jun 2017 23:39:47 +0800</pubDate>
      
      <guid>https://coldinfire.github.io/books/</guid>
      <description>

&lt;h3 id=&#34;开卷有益&#34;&gt;开卷有益&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Number&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;th&gt;State&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;img width=200/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img width=500/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img width=500/&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://book.douban.com/subject/30370277/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;越简单，越美好&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://book.douban.com/subject/27053004/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;以幽默的方式过一生&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://book.douban.com/subject/27018748/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;大学&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://book.douban.com/subject/26801663/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;我，一个人生活&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://book.douban.com/subject/26650965/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;生命清单&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;🕐&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://book.douban.com/subject_search?search_text=%E8%BF%99%E4%B9%88%E6%85%A2%EF%BC%8C%E9%82%A3%E4%B9%88%E7%BE%8E&amp;amp;cat=1001&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;这么慢，那么美&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;🕐&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://coldinfire.github.io/about/</link>
      <pubDate>Thu, 15 Jun 2017 23:39:47 +0800</pubDate>
      
      <guid>https://coldinfire.github.io/about/</guid>
      <description>&lt;p&gt;这个人很懒，什么都没留下&amp;hellip;&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>No Title</title>
      <link>https://coldinfire.github.io/2019/my-first-post/</link>
      <pubDate>Sat, 22 Jun 2019 15:15:42 +0800</pubDate>
      
      <guid>https://coldinfire.github.io/2019/my-first-post/</guid>
      <description></description>
    </item>
    
    <item>
      <title> SAPUI5 </title>
      <link>https://coldinfire.github.io/2019/SAPUI5/</link>
      <pubDate>Sun, 16 Jun 2019 17:20:58 +0800</pubDate>
      
      <guid>https://coldinfire.github.io/2019/SAPUI5/</guid>
      <description>

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;h3 id=&#34;mvc模式&#34;&gt;MVC模式&lt;/h3&gt;

&lt;p&gt;​     MVC是程序设计的思想实现，通过将界面展示，用户操作，程序数据进行分离，降低模块间的耦合性，有利于项目的开发和维护。&lt;/p&gt;

&lt;p&gt;​    M : Model 代表应用程序的数据&lt;/p&gt;

&lt;p&gt;​    V : View 通过界面展示应用程序的数据和其它界面元素&lt;/p&gt;

&lt;p&gt;​    C : Controller 处理应用程序的数据，以及处理用户的交互&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/SAPUI5/MVC.png&#34; alt=&#34;MVC&#34; /&gt;&lt;/p&gt;

&lt;p&gt;● Model &amp;amp; View : SAPUI5 有单向绑定和双向绑定两种。通过绑定，当 model 变更时，UI 自动更新。&lt;/p&gt;

&lt;p&gt;● Controlle &amp;amp;View : View 通知 Controller，或者 Controller使用API来修改 View。&lt;/p&gt;

&lt;p&gt;● Controller &amp;amp; Model : Model 通知 Controller或者 Controller 修改 Model。&lt;/p&gt;

&lt;p&gt;SAPUI5提供了JSView、XMLView、JSONView和HTMLView。主要使用XMLView 和 JSView。&lt;/p&gt;

&lt;h3 id=&#34;核心类库&#34;&gt;核心类库&lt;/h3&gt;

&lt;p&gt;​   查看&lt;code&gt;Resource&lt;/code&gt;版本：Cttl+Shift+Alt+P在对应的App界面或则LunchPad.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m:&lt;/code&gt;主要用于移动设备的响应式组件，并支持很多移动设备特性检测，比如检测touch等，此库下面List, Table等组件使用比较广泛，而且包含了下拉刷新的功能，非常完善，并自动适应不同尺寸平台&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.ui:&lt;/code&gt; UI库包含的组件是最为丰富的，主要用于适应桌面平台，同样可以支持响应式的设计，比如sap.ui.table等组件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.ui.core:&lt;/code&gt;核心功能：加载和管理所有的附加资源，并包含模型和渲染管理器，一个负责处理渲染视图和控制的单例，写入DOM&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.ui.layout:&lt;/code&gt; 构建视图中元素的特殊控件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.ui.vk:&lt;/code&gt; 包含3D模型的功能和控件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.ui.unified:&lt;/code&gt; 包含用于移动和桌面应用程序的附加控件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.ui.table:&lt;/code&gt; 不适用于手机屏幕，处理大量数据应用而构建的&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.ui.comp:&lt;/code&gt; 包含SmartField,SmartFilterBar,SmartTable,ValueHelpDialog等智能控件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.uxap:&lt;/code&gt; 包含更多控件，包括页面标题&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.ushell:&lt;/code&gt; 包含几个库包，含有所有统一的与shell服务相关的功能&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.ca:&lt;/code&gt; 是官方标准app的常用类库，如果在实际开发过程当中想要拓展标准应用，必须要了解此类库的一些特性，否则拓展起来会有很大问题。&lt;/p&gt;

&lt;h3 id=&#34;核心函数&#34;&gt;核心函数&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sap.ui.getCore()&lt;/code&gt; : 获取核心的实例&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.ui.getCore().byId(id)&lt;/code&gt; : 根据组件id获取其控制；可用于获取已经删除的组件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.ui.getCore().applyChanges()&lt;/code&gt; : 在系统运行前修改UI5组件属性&lt;/p&gt;

&lt;p&gt;&lt;code&gt;jQuery.sap.domById(id)&lt;/code&gt; : 根据ID获取HTML元素;如果UI5也存在该ID返回HTML最顶层的元素;和 document.getElementById 类似&lt;/p&gt;

&lt;p&gt;&lt;code&gt;jQuery.sap.byId(id)&lt;/code&gt; : 根据ID获取JQuery对象的DOM元素; $(,,#myId)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.MessageBox&lt;/code&gt; : SAPUI5风格对话框显示&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.URLHelper.redirect(&amp;quot;http://www.jd.com&amp;quot;, true);&lt;/code&gt;重定向&lt;/p&gt;

&lt;h3 id=&#34;常用组件&#34;&gt;常用组件&lt;/h3&gt;

&lt;h4 id=&#34;splitapp&#34;&gt;SplitApp&lt;/h4&gt;

&lt;p&gt;​    SplitApp : 这是一个Master Detail形式的结构，可以在移动，桌面不同尺寸的设备上自适应，也是大部分app需要采用的一种架构形式。&lt;/p&gt;

&lt;h4 id=&#34;list&#34;&gt;List&lt;/h4&gt;

&lt;p&gt;List : 列表在任何应用中是比较常见的，List在SAPUI5定义功能比较完善，支持分批加载数据，提高运行效率，支持下拉等功能，并提供给我们丰富的标准Item, 可以简单配置使用，更可以根据自身需求定义item。&lt;/p&gt;

&lt;p&gt;​   对于移动设备来说，出于性能考虑，不要超过100行。使用&lt;strong&gt;growing&lt;/strong&gt;特性可以加速内部的渲染。&lt;/p&gt;

&lt;p&gt;​   List控件继承自&lt;code&gt;sap.m.ListBase&lt;/code&gt;，ListBase的items聚合属性(类型：&lt;code&gt;sap.m.ListeItemBase[]&lt;/code&gt;) 设置行项目的模板。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;sap.m.List&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;new sap.m.List({items:{path:&amp;ldquo;/path&amp;rdquo;,template:oTemplate}});&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;new sap.m.List().bindItems({path:&amp;ldquo;/path&amp;rdquo;,template:oTemplate});&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sap.m.ObjectListItem&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ObjectListItem适用于显示行项目的信息，主要使用title属性进行标识，text、icon、atrributes和statuses等属性可以用于提供对象更多信息。继承自sap.m.ObjectListItem，可定义press事件对用户的点击做出回应。&lt;/p&gt;

&lt;h4 id=&#34;table&#34;&gt;Table&lt;/h4&gt;

&lt;p&gt;​    Table : 这是一个表单性质的的组件，支持响应式，很多是够我们做一个表单展示需要此控件的支持。自身也携带了丰富的property供我们选择。&lt;/p&gt;

&lt;h5 id=&#34;sap-ui-table-table&#34;&gt;sap.ui.table.Table&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;sap.ui.table.Table&lt;/p&gt;

&lt;p&gt;&lt;code&gt;oTable.setModel(oModel);&lt;/code&gt;实现Table与JSONModel的绑定，也就是View和Model的绑定。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;oTable.bindRows(&amp;quot;/Suppliers&amp;quot;);&lt;/code&gt;语句实现Table与JSON数据的绑定。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;width : sap.ui.core.CSSSize (default: auto)。表格的宽度可以是百分百，或者基于像素px。&lt;/p&gt;

&lt;p&gt;titel : 设置Table的标题 。&lt;/p&gt;

&lt;p&gt;visibleRowCount : int (default: 10)。默认显示10行，可以自定义显示的行数。&lt;/p&gt;

&lt;p&gt;firstVisibleRow : int (default: 0) 。默认为0，从第一行开始展示数据。&lt;/p&gt;

&lt;p&gt;selectionMode : sap.ui.table.SelectionMode (default: MultiToggle)。包括单行(sap.ui.table.SelectionMode.Single)、多行                                           (sap.ui.table.SelectionMode.MultiToggle)和不能选择行(sap.ui.table.SelectionMode.None)。&lt;/p&gt;

&lt;p&gt;editable : boolean (default: true)。默认可以编辑，如果只是显示，将此属性设置为false。&lt;/p&gt;

&lt;p&gt;columns : [ind1,ind2] 里面填充Table的列元素。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sap.ui.table.Column&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;width : 宽度(100px)。&lt;/p&gt;

&lt;p&gt;label : 设置标题栏。&lt;/p&gt;

&lt;p&gt;template : 设置单元格的显示模板。&lt;/p&gt;

&lt;p&gt;sortProperty : 设置排序针对的字段。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;sap-m-table&#34;&gt;sap.m.Table&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;sap.m.Table&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;继承自sap.m.ListBase，用于显示包含行和列的表格式数据。表格的列可以通过&lt;code&gt;columns&lt;/code&gt;聚合属性来设置，也可以使用&lt;code&gt;addColumn()&lt;/code&gt;方法来添加。每一列都是&lt;code&gt;sap.m.Column&lt;/code&gt;对象。&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;columns&lt;/code&gt;聚合属性和&lt;code&gt;items&lt;/code&gt;聚合属性，items属性实现的就是聚合绑定.。&lt;/p&gt;

&lt;p&gt;sap.m.Table的重要属性：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;columns:&lt;/code&gt;定义Table包含哪些列，类型是sap.m.Column数组。另外，sap.m.Table从sap.m.ListBase继承，所以可以直接使用sap.m.ListBase的属性。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;growing:&lt;/code&gt;设置Table显示的数据可以依据向model的请求增加行noDataText: 当Table没有数据的时候显示的文本，类型是string。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;items:&lt;/code&gt;sap.m.ListItemBase数组，sap.m.ListItemBase类定义了列表项(list item)的基本特征。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;sap.m.ColumnListItem:&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;sap.m.ColumnListItem&lt;/code&gt;用于创建&lt;code&gt;sap.m.Table&lt;/code&gt;的行，行中包含的&lt;code&gt;cells&lt;/code&gt;需要与&lt;code&gt;sap.m.Table&lt;/code&gt;的Columns匹配，顺序一致。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.Table().bindItems(&amp;quot;/modelData&amp;quot;,oCllumnListItem);&lt;/code&gt;绑定行&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.Table().bindAggregation(&amp;quot;items&amp;quot;,&amp;quot;/modelData&amp;quot;,oCollumnListItem);&lt;/code&gt;:聚合绑定。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;oColumnListItem.addCell();&lt;/code&gt;为Items添加元素。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.ColumnListItem&lt;/code&gt;的press属性设置为一个数组，这种方法能够保证在Controller中，this表示Controller本身，而不是某个控件。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;vAlign:&lt;/code&gt;行的垂直对齐：&lt;/p&gt;

&lt;p&gt;​  &lt;code&gt;sap.ui.core.VerticalAlign.Bottom:&lt;/code&gt;底部对齐&lt;/p&gt;

&lt;p&gt;​  &lt;code&gt;sap.ui.core.VerticalAlign.Inherit:&lt;/code&gt;从父控件继承&lt;/p&gt;

&lt;p&gt;​  &lt;code&gt;sap.ui.core.VerticalAlign.Middle:&lt;/code&gt;居中对齐&lt;/p&gt;

&lt;p&gt;​ &lt;code&gt;sap.ui.core.VerticalAlign.Top:&lt;/code&gt;顶部对齐&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;cells:&lt;/code&gt;行包含的cells，每一个cell都是&lt;code&gt;sap.ui.core.Control&lt;/code&gt;对象，从而开发人员可以根据需要选择合适的控件，灵活度很高。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt; &amp;lt;ObjectIdentifier text=&amp;quot;{ID}&amp;quot;&amp;gt;&amp;lt;/ObjectIdentifier&amp;gt; : cell元素。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;主题设置&#34;&gt;主题设置&lt;/h3&gt;

&lt;p&gt;​    SAPUI5 默认提供了一些主题，并在组件添加新的主题。&lt;/p&gt;

&lt;p&gt;​        - Blue crystal (常用)&lt;/p&gt;

&lt;p&gt;​        - Platium&lt;/p&gt;

&lt;p&gt;​        - Gold Reflection (常用)&lt;/p&gt;

&lt;p&gt;​        - High Contast Black&lt;/p&gt;

&lt;p&gt;​        - Belize (常用)    - …&lt;/p&gt;

&lt;p&gt;​    设置主题：&lt;/p&gt;

&lt;p&gt;​        1.在Header中设置 : &lt;code&gt;data-sap-ui-theme=&amp;quot;sap_bluecrystal&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​        2.在程序中设定样式 :&lt;code&gt;sap.ui.getCore().applyTheme(sThemeName, sThemeBaseUrl?)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;文件模块介绍&#34;&gt;文件模块介绍&lt;/h3&gt;

&lt;h4 id=&#34;index&#34;&gt;Index&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;&amp;lt;script id=&amp;quot;sap-ui-bootstrap&amp;quot;
		src=&amp;quot;https://openui5.hana.ondemand.com/resources/sap-ui-core.js&amp;quot;
		data-sap-ui-theme=&amp;quot;sap_belize&amp;quot;
		data-sap-ui-libs=&amp;quot;sap.m&amp;quot;
		data-sap-ui-compatVersion=&amp;quot;edge&amp;quot;
		data-sap-ui-preload=&amp;quot;async&amp;quot;
		data-sap-ui-bindingSyntax = &amp;quot;complex&amp;quot;
		data-sap-ui-resourceroots = &#39;{&amp;quot;sFileSourceName&amp;quot;:&amp;quot;oURL&amp;quot;}&#39;&amp;gt;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;​   src : 核心资源的加载路径。&lt;/p&gt;

&lt;p&gt;​   data-sap-ui-theme : 设置主题&lt;/p&gt;

&lt;p&gt;​   data-sap-ui-libs : 选择文件默认加载的库文件&lt;/p&gt;

&lt;p&gt;​   data-sap-ui-compatVersion : edge兼容模式，为了方便使用新功能&lt;/p&gt;

&lt;p&gt;​   data-sap-ui-preload : async 设置文件加载形式为异步加载&lt;/p&gt;

&lt;p&gt;​   data-sap-ui-bindingSyntax : 数据绑定的设置 complex复杂绑定，对绑定数据进行计算。&lt;/p&gt;

&lt;p&gt;​   data-sap-ui-resourceroots : 命名文件的根目录，声明资源文件位置&lt;/p&gt;

&lt;p&gt;​   data-sap-ui-onInit=&amp;ldquo;module:sNameSpace/index&amp;rdquo; : 定义初始化时加载的初始页面文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSP&#34;&gt;&amp;lt;script&amp;gt;
    sap.ui.localResources(&amp;quot;ui5mvc&amp;quot;);
    var app = new sap.m.App({initialPage:&amp;quot;idmain1&amp;quot;});
    var view = sap.ui.view({
        id:&amp;quot;idmain1&amp;quot;, 
        viewName:&amp;quot;ui5mvc.main&amp;quot;, 
        type:sap.ui.core.mvc.ViewType.JS});
    app.addPage(view);
    app.placeAt(&amp;quot;content&amp;quot;);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sap.ui.localResources(&amp;quot;filename&amp;quot;)&lt;/code&gt; : 将当前目录下的FILE文件夹注册为当前文件夹，程序会在该文件夹下查找&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;View和Controller代码。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;sap.m.App&lt;/code&gt; : 是SAP移动APP的root element,提供导航功能，并将一些header标签加到HTML页。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;sap.ui.view&lt;/code&gt; : 定义一个view,ID,name,type来指定显示的View。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​                                  &lt;code&gt;sap.ui.xmlview&lt;/code&gt;可直接定义xml类型View。View type:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sap.ui.core.mvc.ViewType.JS       &amp;ldquo;JS&amp;rdquo;&lt;/li&gt;
&lt;li&gt;sap.ui.core.mvc.ViewType.XML    &amp;ldquo;XML&amp;rdquo;&lt;/li&gt;
&lt;li&gt;sap.ui.core.mvc.ViewType.JSON    &amp;ldquo;JSON&amp;rdquo;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sap.ui.core.mvc.ViewType.HTML   &amp;ldquo;HTML&amp;rdquo;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;app.placeAt()&lt;/code&gt; : 该方法将控件放到指定的div中。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;view&#34;&gt;View&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;view.js&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;sap.ui.jsview(&amp;quot;ui5mvc.main&amp;quot;, {
	getControllerName : function() {
		return &amp;quot;ui5mvc.main&amp;quot;;
	},
	createContent : function(oController) {
		var oShell = new sap.ui.ux3.Shell();// Create Shell

		oShell.addWorksetItem(new sap.ui.ux3.NavigationItem({
			key : &amp;quot;btn&amp;quot;,
			text : &amp;quot;Button&amp;quot;
		}));// Add Navigation item

		oShell.addWorksetItem(new sap.ui.ux3.NavigationItem({
			key : &amp;quot;tf&amp;quot;,
			text : &amp;quot;Textfield&amp;quot;
		}));

		oShell.addWorksetItem(new sap.ui.ux3.NavigationItem({
			key : &amp;quot;xml&amp;quot;,
			text : &amp;quot;XMLView&amp;quot;
		}));

		var mContent = {}; // map holding shell content
		mContent.btn = new sap.ui.commons.Button({
			text : &amp;quot;Hello World&amp;quot;
		});

		mContent.tf = new sap.ui.commons.TextField();
		oShell.attachWorksetItemSelected(function(evt) {
			var key = evt.getParameter(&amp;quot;key&amp;quot;);
			oShell.setContent(mContent[key]);
		});// Add WorksetItem Selected event

		mContent.xml = sap.ui.view({
			viewName : &amp;quot;ui5mvc.XML&amp;quot;,
			type : sap.ui.core.mvc.ViewType.XML
		});
	
		oShell.setContent(mContent.btn);//initial content
		return oShell;
	}
});
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;getControllerName&lt;/code&gt;: 函数用于返回 controller name&lt;/p&gt;

&lt;p&gt;&lt;code&gt;createContent&lt;/code&gt;: 函数用于返回页面上要显示的元素&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;view.xml&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-XML&#34;&gt;&amp;lt;core:View xmlns:core=&amp;quot;sap.ui.core&amp;quot;
	xmlns:mvc=&amp;quot;sap.ui.core.mvc&amp;quot; xmlns=&amp;quot;sap.m&amp;quot; controllerName=&amp;quot;ui5mvc.XML&amp;quot;
	mlns:html=&amp;quot;http://www.w3.org/1999/xhtml&amp;quot;&amp;gt;
	&amp;lt;html:h1&amp;gt;My first XML-Header&amp;lt;/html:h1&amp;gt;
	&amp;lt;Panel&amp;gt;
		&amp;lt;Button press=&amp;quot;.sayHello&amp;quot; text=&amp;quot;Say Hello&amp;quot;&amp;gt;&amp;lt;/Button&amp;gt;
	&amp;lt;/Panel&amp;gt;
&amp;lt;/core:View&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​       空的的namespace设定 : xmlns = &amp;ldquo;sap.m&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;​       命名的namespace设定 : xmlns:mvc = &amp;ldquo;sap.ui.core.mvc&amp;rdquo;. mvc标签指代&lt;code&gt;sap.ui.core.mvc&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;申明namespace: &lt;code&gt;xmlns:t=&amp;quot;sap.ui.table&amp;quot;&lt;/code&gt;。xml中就可以表示为&lt;code&gt;&amp;lt;t:Table&amp;gt; ... &amp;lt;/t:Table&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果属性是简单类型，可以直接作为atrribute的方式来申明，如Table的width属性、title属性&lt;/li&gt;
&lt;li&gt;如果属性是Aggregation和Association，则使用子标签，如Column的Label，是&lt;code&gt;sap.m.Label&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;绑定的语法稍有差异。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;视图模型可以包含分配给控件的任何配置选项，以绑定属性。&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;一个 ” . ”在格式化程序名称前面表示在当前视图的控制器中查找该函数&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;xmlView 聚合绑定&lt;/p&gt;

&lt;p&gt;​   1）xmlview中对需要动态显示的部分不作声明&lt;/p&gt;

&lt;p&gt;​   2）在controller中定义factory function，实现控件的绑定和动态加载。&lt;/p&gt;

&lt;h4 id=&#34;controller&#34;&gt;Controller&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;系统生成的文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;sap.ui.controller(&amp;quot;ui5mvc.XML&amp;quot;, {
// onInit: function() {
//		
// },

// onBeforeRendering: function() {
//
// },

// onAfterRendering: function() {
//
// },

// onExit: function() {
//
// }

sayHello : function() {
	sap.ui.commons.MessageBox.show(&amp;quot;Hello World&amp;quot;);
}
});
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过模块定义&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;sap.ui.define(
	[&amp;quot;Dependencies1&amp;quot;,&amp;quot;Dependencies2&amp;quot;,&amp;quot;formatter&amp;quot;],
	function(Controller,formatter){
	&amp;quot;use strict&amp;quot;;
		return Controller.extend(&amp;quot;ControllerName&amp;quot;,{
        formatter:formatter,
            
			onInit:function(){},
           onBeforeRendering:function(){},
           onAfterRendering:function(){},
           onExit:function(){}
		});
	}
);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;生命周期：&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​           Start  &amp;ndash;&amp;gt;  视图和控制器被实例化  &amp;ndash;&amp;gt;  控制器被加载(存在控制器) &amp;ndash;&amp;gt;  onInit  &amp;ndash;&amp;gt;  onBeforeRendering  &amp;ndash;&amp;gt;&lt;/p&gt;

&lt;p&gt;​       视图被渲染  &amp;ndash;&amp;gt;  onAfterRendering  &amp;ndash;&amp;gt;  onExit  &amp;ndash;&amp;gt;  END(视图和控制器被销毁)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;onInit : 当视图被实例化并且其控件已经创建时调用。用于在显示前修改视图，绑定事件处理程序并执行其他一次性初始化任务。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;onExit : 视图退出时调用。用于释放资源并完成任务。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;onAfterRendering : 当视图被渲染时调用;是HTML的一部分。用于执行HTML的后续操作，SAPUI5控制在渲染后访问此钩子。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;onBeforeRendering : 在控制器视图重新呈现之前调用，不在第一次呈现之前调用。用于在其中调用第一个渲染前的钩子。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;控制器只是将加载的格式化程序函数存储在本地属性格式化程序中，以便能够在视图中访问它们。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;model&#34;&gt;Model&lt;/h4&gt;

&lt;p&gt;应用程序数据&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;客户端 JSON model、XML model、Resource model&lt;/li&gt;
&lt;li&gt;服务端 oData model&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;resource&#34;&gt;Resource&lt;/h4&gt;

&lt;p&gt;三种方法声明文件位置：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sap.ui.localResources()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​ sap.ui.localResources(&amp;ldquo;foldle.foldle&amp;rdquo;);&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;jQuery.sap.registerModulePath()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​ jQuery.sap.registerModulePath(sModuleNamePrefix, sURL);&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;bootstrap声明 : &lt;code&gt;data-sap-ui-resourceroots = &#39;{&amp;quot;sName&amp;quot;:&amp;quot;oURL&amp;quot;}&#39;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;变更位置后需要修改系统自动生成的文件名称。&lt;/p&gt;

&lt;p&gt;Component&lt;/p&gt;

&lt;p&gt;Component.js通过调用manifest.json的配置信息，完成初始化调用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;sap.ui.define([
        &amp;quot;sap/ui/core/UIComponent&amp;quot;,
        &amp;quot;sap/ui/model/resource/ResourceModel&amp;quot;,
        &amp;quot;sap/ui/model/json/JSONModel&amp;quot;
        
    ], function (UIComponent, ResourceModel, JSONModel) {
    &amp;quot;use strict&amp;quot;;

    return UIComponent.extend(&amp;quot;webapp.Component&amp;quot;, {
		//metadata
        metadata: {
            manifest: &amp;quot;json&amp;quot;
         },

        init : function () {
            // call the base component&#39;s init function
            UIComponent.prototype.init.apply(this, arguments);

            // create the views based on the url/hash
            this.getRouter().initialize();
        }
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;application-descriptor&#34;&gt;Application Descriptor&lt;/h4&gt;

&lt;p&gt;​   manifest.json配置应用程序的相关信息。被称为Application Descriptor。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;sap.app&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;包含特定于应用程序的属性&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ID(强制)：应用程序组件的命名空间，唯一的，必须与组件的空间名称对应&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;type：定义我们想要配置的内容，例如：应用程序&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;i18n：定义资源包文件的路径&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;title：应用程序资源包中引用的句柄语法中的应用程序标题&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;description：简短说明文本应用程序在应用程序资源包中引用的句柄语法中的作用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;applicationVersion：应用程序的版本，以便以后可以轻松更新应用程序&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;sap.ui&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;提供以下UI属性&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;technology：此值指定UI技术; 在我们的例子中，我们使用SAPUI5&lt;/li&gt;
&lt;li&gt;deviceTypes：告诉应用程序支持哪些设备：台式机，平板电脑，手机（默认情况下均为true）&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;sap.ui5&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;该 sap.ui5 namespace添加SAPUI5自动处理的SAPUI5特定配置参数。最重要的参数是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;rootView：如果指定此参数，组件将自动实例化视图并将其用作此组件的根&lt;/li&gt;
&lt;li&gt;dependencies：这里我们声明应用程序中使用的UI库&lt;/li&gt;
&lt;li&gt;models：在描述符的这一部分中，我们可以定义在应用程序启动时由SAPUI5自动实例化的模型。在这里，我们现在可以定义本地资源包。我们将模型“i18n”的名称定义为键，并按名称空间指定包文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;资源包文件&#34;&gt;资源包文件&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;sap.app设置资源包文件的路径和文件名。使用的相对于 &lt;code&gt;manifest.json&lt;/code&gt; 文件的相对路径。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;sap.app&amp;rdquo;: {
    &amp;ldquo;_version&amp;rdquo;: &amp;ldquo;1.1.0&amp;rdquo;,
    &amp;ldquo;id&amp;rdquo;: &amp;ldquo;resource&amp;rdquo;,
    &amp;ldquo;type&amp;rdquo;: &amp;ldquo;application&amp;rdquo;,
    &amp;ldquo;i18n&amp;rdquo;: &amp;ldquo;i18n/i18n.properties&amp;rdquo;,
    &amp;hellip;&lt;/p&gt;

&lt;p&gt;},&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;sap.ui5中models设置名称为 i18n 的 &lt;strong&gt;resource model&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;sap.ui5&amp;rdquo;: {&lt;br /&gt;
   &amp;hellip;
   &amp;ldquo;models&amp;rdquo;: {
       &amp;hellip;
       &amp;ldquo;i18n&amp;rdquo;: {
           &amp;ldquo;type&amp;rdquo;: &amp;ldquo;sap.ui.model.resource.ResourceModel&amp;rdquo;,
           &amp;ldquo;settings&amp;rdquo;: {
               &amp;ldquo;bundleName&amp;rdquo;: &amp;ldquo;webapp.i18n.i18n&amp;rdquo;
               }
     }&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;bundleName&lt;/code&gt; 后面是根据 index.html文件的 &lt;strong&gt;resource roots&lt;/strong&gt; 设置的相对路径。然后在代码中添加对 ResourceBundle 的依赖后，通过 &lt;code&gt;{i18n&amp;gt;xxx}&lt;/code&gt; 实现绑定。&lt;/p&gt;

&lt;h5 id=&#34;models&#34;&gt;Models&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;sap.app设置资源包文件的路径和文件名。使用的相对于 &lt;code&gt;manifest.json&lt;/code&gt; 文件的相对路径。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;&amp;quot;sap.app&amp;quot;: {
   ...
   &amp;quot;dataSources&amp;quot;: {
       &amp;quot;mainService&amp;quot;: {
           &amp;quot;uri&amp;quot;: &amp;quot;./service/data.json&amp;quot;,
           &amp;quot;type&amp;quot;: &amp;quot;JSON&amp;quot;
       }
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sap.ui5的&lt;code&gt;models&lt;/code&gt;没有指定名称的 model，当 view 中数据绑定时，没有给出前缀的时候，就参照到这个 model。使用sap.app中设置的dataSource.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;&amp;quot;sap.ui5&amp;quot;: {
       ...
       &amp;quot;models&amp;quot;: {
           &amp;quot;&amp;quot;: {
               &amp;quot;dataSource&amp;quot;: &amp;quot;mainService&amp;quot;
            },
       ...
       }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;root-view&#34;&gt;Root View&lt;/h5&gt;

&lt;p&gt;​   Root view (启动即显示的 view)：类型为 xml，名称为 App。OpenUI5 在相应文件夹下面查找名为 &lt;code&gt;App.view.xml&lt;/code&gt; 文件并加载。通过这种方式，实现了 root view 的配置化.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;sap.ui5&amp;rdquo;: {
      &amp;ldquo;_version&amp;rdquo;: &amp;ldquo;1.1.0&amp;rdquo;,
      &amp;ldquo;rootView&amp;rdquo;: {
          &amp;ldquo;viewName&amp;rdquo;: &amp;ldquo;webapp.view.App&amp;rdquo;,
          &amp;ldquo;type&amp;rdquo;: &amp;ldquo;XML&amp;rdquo;
      }&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;​   启动流程 :&lt;/p&gt;

&lt;p&gt;​   1) &lt;code&gt;index.html&lt;/code&gt; 的 &lt;code&gt;ComponentContainer&lt;/code&gt; 根据 &lt;code&gt;name&lt;/code&gt; 或 &lt;code&gt;component&lt;/code&gt; 属性实例化 Component。&lt;/p&gt;

&lt;p&gt;​   2) Component 的 &lt;code&gt;metadata&lt;/code&gt; 指向设定的 &lt;code&gt;manifest.json&lt;/code&gt; 文件。&lt;/p&gt;

&lt;p&gt;​   3) &lt;code&gt;manifest.json&lt;/code&gt; 文件的 &lt;code&gt;sap.ui5&amp;gt;rootView&lt;/code&gt; 设定了启动时候加载并显示的 root view 为 &lt;code&gt;App.view.xml&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;​   4) App view 并不需要像之前文章介绍的内嵌 master view 和 detail view，而是由路由器根据路径在 pattern 中找匹配的模式，在 target 中找对应的 view 加载。&lt;/p&gt;

&lt;h5 id=&#34;routing设置&#34;&gt;Routing设置&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;&amp;quot;sap.ui5&amp;quot;: {
        ...
        &amp;quot;routing&amp;quot;: {
            &amp;quot;config&amp;quot;: {
                &amp;quot;routerClass&amp;quot;: &amp;quot;sap.m.routing.Router&amp;quot;,
                &amp;quot;viewType&amp;quot;: &amp;quot;XML&amp;quot;,
                &amp;quot;viewPath&amp;quot;: &amp;quot;webapp.view&amp;quot;,
                &amp;quot;controlId&amp;quot;: &amp;quot;app&amp;quot;,
                &amp;quot;controlAggregation&amp;quot;: &amp;quot;pages&amp;quot;,
                &amp;quot;bypassed&amp;quot;: {
                    &amp;quot;target&amp;quot;: &amp;quot;notFound&amp;quot;
                }
            },
            &amp;quot;routes&amp;quot;: [{
                &amp;quot;pattern&amp;quot;: &amp;quot;&amp;quot;,
                &amp;quot;name&amp;quot;: &amp;quot;master&amp;quot;,
                &amp;quot;target&amp;quot;: &amp;quot;master&amp;quot;
            },
            {
                &amp;quot;pattern&amp;quot;: &amp;quot;detail/{supplierPath}&amp;quot;,
                &amp;quot;name&amp;quot;: &amp;quot;detail&amp;quot;,
                &amp;quot;target&amp;quot;: &amp;quot;detail&amp;quot;
            }],
            &amp;quot;targets&amp;quot;: {
                &amp;quot;master&amp;quot;: {
                    &amp;quot;viewName&amp;quot;: &amp;quot;Master&amp;quot;,
                    &amp;quot;viewLevel&amp;quot;: 1
                },
                &amp;quot;detail&amp;quot;: {
                    &amp;quot;viewName&amp;quot;: &amp;quot;Detail&amp;quot;,
                    &amp;quot;viewLevel&amp;quot;: 2
                },
                &amp;quot;notFound&amp;quot;: {
                    &amp;quot;viewName&amp;quot;: &amp;quot;NotFound&amp;quot;,
                    &amp;quot;viewId&amp;quot;: &amp;quot;notFound&amp;quot;
                }
            }
        }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;多语言&#34;&gt;多语言&lt;/h4&gt;

&lt;p&gt;在 SAPUI5 中，通过两种方法来实现多语言.&lt;/p&gt;

&lt;p&gt;​   (1) SAPUI5 提供 Resource Model，Resource Model 读取资源包 (Resource Bundle) 并与 View 中的控件绑定。&lt;/p&gt;

&lt;p&gt;​   (2) 使用 jQuery.sap.resources 相关的 API 读取资源包。两种方法都需要资源包文件并且在配置中设置。&lt;/p&gt;

&lt;h5 id=&#34;语言代码&#34;&gt;语言代码&lt;/h5&gt;

&lt;p&gt;​   OpenUI5 对页面的显示，有一个 &lt;strong&gt;当前语言( Current Language )&lt;/strong&gt; 的概念，按照当前语言，读取相应的资源包文件，按当前语言显示。OpenUI5 按照如下顺序顺序(从高到低)，如果都没有找到，最后读取通用设置（比如 i18n.properties)。&lt;/p&gt;

&lt;p&gt;​   &lt;code&gt;sap.ui.getCore().getConfiguration().getLanguage()&lt;/code&gt; 获得当前语言。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;1) URL中的 locale 参数（即在 url 后面加上 &lt;code&gt;?sap-ui-language=en&lt;/code&gt; )&lt;/p&gt;

&lt;p&gt;2) 应用程序代码的 locale 设置，sap.ui.getCore().getConfiguration().applySettings({ language: &amp;lsquo;de&amp;rsquo;});&lt;/p&gt;

&lt;p&gt;3) Android 平台的用户代理字符串设置&lt;/p&gt;

&lt;p&gt;4) 浏览器的一般语言设置，可以用 window.navigator.language 查看&lt;/p&gt;

&lt;p&gt;5) 浏览器中用户语言配置。这个与浏览器相关，比如 IE 通过 window.navigator.userLanguage 查看。&lt;/p&gt;

&lt;p&gt;6) 浏览器语言配置。这个业余浏览器相关，比如 IE 通过 window.navigator.browserLanguage 查看&lt;/p&gt;

&lt;p&gt;7) OpenUI5中硬编码，默认为 en&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;资源包文件-1&#34;&gt;资源包文件&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;Java的属性文件，文件的扩展名总是.properties。文件中包含于语言相关的文本。&lt;/li&gt;
&lt;li&gt;文件名包括固定部分和语言相关部分。那么 i18n.properties 是默认的文件，i18n_zh_CN.properties 是中文简体的资源文件。&lt;/li&gt;
&lt;li&gt;资源包文件为扁平结构，不能嵌套。每一行要么是 key-value键值对 ，要么是 # 开头的注释。也可以可以空行。&lt;/li&gt;
&lt;li&gt;如果 Properties 文件的文本为 Unicode 字符，文件使用16进制的编码来存储，而不是明文。&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;resource-model&#34;&gt;Resource Model&lt;/h5&gt;

&lt;p&gt;​   使用 Resource Model 绑定数据需要三步：&lt;/p&gt;

&lt;p&gt;​   1) 添加资源包文件，将不同的语言放在不同的资源包文件中。&lt;code&gt;i18n.properties,i18n_zh_CN.properties&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​   2) 在 Component.js 文件中，创建 Resource model 的实例 。&lt;/p&gt;

&lt;p&gt;​   3) 在 View 中参照 Resource Model 中定义的 key。 &lt;code&gt;title=&amp;quot;{i18n&amp;gt;masterTitle}&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​    url 后面添加&lt;code&gt;?sap-ui-language=XXX&lt;/code&gt;，实现语言的切换。&lt;/p&gt;

&lt;h5 id=&#34;jquery-sap-resources&#34;&gt;jQuery.sap.resources&lt;/h5&gt;

&lt;p&gt;​   在代码中直接使用资源包的文本。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;var sLocale = sap.ui.getCore().getConfiguration().getLanguage();//获取当前语言
var oBd = jQuery.sap.resources({
	url: &amp;quot;i18n/i18n.properties&amp;quot;,
	locale: sLocale
})               						 //根据指定的 URL 和 Locale，创建一个新的资源包实例
var sMeg = oBd.getText(&amp;quot;key&amp;quot;,[sLocale]); //根据资源包文件的 key，获取与语言相关的 value。

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;layout设置&#34;&gt;Layout设置&lt;/h2&gt;

&lt;h3 id=&#34;多页面显示和跳转&#34;&gt;多页面显示和跳转&lt;/h3&gt;

&lt;p&gt;​   sap.m.App : 是一个全局对象，可以通过 app.to(sPageId) 跳转到另一个页面。&lt;/p&gt;

&lt;p&gt;​       to(sPageId, sTransitionName&lt;em&gt;?&lt;/em&gt;, oData&lt;em&gt;?&lt;/em&gt;, oTransitionParameters&lt;em&gt;?&lt;/em&gt;): [sap.m.NavContainer]&lt;/p&gt;

&lt;p&gt;​   app.back()则跳回到刚才的page：&lt;/p&gt;

&lt;p&gt;​       back(oBackData&lt;em&gt;?&lt;/em&gt;, oTransitionParameters&lt;em&gt;?&lt;/em&gt;): [sap.m.NavContainer]&lt;/p&gt;

&lt;p&gt;​   &lt;code&gt;sap.m.Page&lt;/code&gt;中，&lt;code&gt;showNavButton&lt;/code&gt;设置为&lt;code&gt;true&lt;/code&gt;，就会出现Navigation按钮，点击按钮的event hander通过Controller中&lt;code&gt;onNavPress&lt;/code&gt;函数来实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;	var oDetailPage = new sap.m.Page({
        showNavButton: true,
        navButtonPress: [oController.onNavPress, oController],
        title: &amp;quot;供应商明细&amp;quot;,
        content: [oObjectHeader]
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;​   &lt;code&gt;sap.m.ColumnListItem&lt;/code&gt;的type必须为Navigation，否则不能实现跳转。&lt;code&gt;sap.m.ColumnListItem&lt;/code&gt;的press属性设置为一个数组，这种方法能够保证在Controller中，this表示Controller本身，而不是某个控件。&lt;/p&gt;

&lt;h3 id=&#34;布局类型&#34;&gt;布局类型&lt;/h3&gt;

&lt;p&gt;​   sap.ui.layout.HorizontalLayout() : 水平布局&lt;/p&gt;

&lt;p&gt;​   sap.ui.layout.VerticalLayout() : 垂直布局&lt;/p&gt;

&lt;p&gt;​   sap.ui.layout.Grid() : 表格式布局&lt;/p&gt;

&lt;h4 id=&#34;grid-layout&#34;&gt;Grid Layout&lt;/h4&gt;

&lt;p&gt;​   Grid Layout 控件负责将页面进行表格式布局，将页面分为 12 列，子控件从左至右排列。每个控件并不是占一列，OpenUI5 根据屏幕的大小，将屏幕分为 4 种，分别是&lt;code&gt;XL: extra large 、 L: large、M: medium、S: small&lt;/code&gt;。XL的如 PC 机的大桌面，L的如 PC 的桌面，M的比如平板，S的比如手机。默认情况下，每个控件在 XL 桌面上占 3 列，在 L 桌面上占 3 列，在 M 桌面上占 6 列，在 S 桌面上占 12 列。OpenUI5 用一个字符串表示为&lt;code&gt;XL3 L3 M6 S12&lt;/code&gt;，通过 default Span 属性来设置。&lt;/p&gt;

&lt;p&gt;​    当屏幕的尺寸变更的时候，OpenUI5 检测到尺寸的变化，根据上面的 4 个分类对控件的位置进行调整，从而实现所谓的自适应。&lt;/p&gt;

&lt;p&gt;​    Grid layout 控件宽度 (Width)，可以基于像素，或者基于页面宽度的相对比例。控件之间的间距可以通过 vSpacing 和 hSpacing 属性进行设置。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.ui.layout&lt;/code&gt; : 该function可以对Layout页面布局进行设置。&lt;/p&gt;

&lt;p&gt;​       &lt;code&gt;new sap.ui.layout.Grid({ content: [ a1,b1,c1,d1] }).placeAt(&amp;quot;content&amp;quot;);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​    将各个空间放到Layout.Grid中，然后将该Grid放到页面指定位置上。&lt;/p&gt;

&lt;h3 id=&#34;layoutdata-属性&#34;&gt;LayoutData 属性&lt;/h3&gt;

&lt;p&gt;​      &lt;code&gt;sap.ui.core.Element&lt;/code&gt; 类定义了&lt;code&gt;layoutData&lt;/code&gt; 属性、&lt;code&gt;getLayoutData()&lt;/code&gt; 方法和&lt;code&gt;setLayoutData()&lt;/code&gt; 方法。控件都是 &lt;code&gt;sap.ui.core.Element&lt;/code&gt; 类的间接子类，从而控件都可以利用这些属性和方法设定这个控件在页面中如何定位。&lt;code&gt;setLayoutData()&lt;/code&gt; 方法的参数是&lt;code&gt;sap.ui.core.LayoutData&lt;/code&gt; 对象。 Grid 布局时&lt;code&gt;layoutData&lt;/code&gt; 我们可以用&lt;code&gt;sap.ui.core.LayoutData&lt;/code&gt; 类的子类 &lt;code&gt;sap.ui.layout.GridData&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSP&#34;&gt;var oLabel2 = new sap.m.Label({
   text : &amp;quot;XXXXXXXXXXXXXXXXXXX&amp;quot;,
   layoutData : new sap.ui.layout.GridData({
     span : &amp;quot;XL12 L12 M12 S12&amp;quot;       //通过该设置让该元素独占屏幕元素的一整行
   })
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;margin-classes&#34;&gt;Margin Classes&lt;/h4&gt;

&lt;p&gt;​   在class属性中设置了四种标准的大小: tiny-8px、small-16px、medium-32px、large-48px， Begin is left and End is right。&lt;/p&gt;

&lt;p&gt;在 div 的 class 属性中添加对应的属性值来解决边距问题。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Full Margins : all around control&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;sapUiTinyMargin&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sapUiSmallMargin&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sapUiMediumMargin&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sapUiLargeMargin&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Single-sided margins : class中只能设定一个边框距离&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;sapUixxxxMarginTop&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sapUixxxxMarginBottom&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sapUixxxxMarginBegin&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sapUixxxxMarginEnd&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Two-Sided Margins : 两个方向&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;sapUiTinyMarginBeginEnd&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sapUiTinyMarginTopBottom&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Responsive Margins : margins depending on the screen width&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;sapUiResponsiveMargin&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;Panel headerText=&#34;{i18n&gt;helloPanelTitle}&amp;rdquo;
      class=&amp;ldquo;sapUiResponsiveMargin&amp;rdquo;
      width=&amp;ldquo;auto&amp;rdquo;&amp;gt;
&lt;/Panel&gt;&lt;/p&gt;

&lt;p&gt;&lt;body class=&#34;sapUiBody sapUiResponsiveMargin&#34; role=&#34;application&#34;&gt;&lt;/p&gt;

&lt;p&gt;​      &lt;div id=&#34;content&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;/body&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;100%宽度控制&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果控件包含有&lt;code&gt;width&lt;/code&gt;属性，设置该属性为&lt;code&gt;width=auto&lt;/code&gt;.如果没有该属性，可以添加 sapUiForceWidthAuto属性到控件的class.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;移除Margins&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sapUiNoMarginTop&lt;/li&gt;
&lt;li&gt;sapUiNoMarginBottom&lt;/li&gt;
&lt;li&gt;sapUiNoMarginBegin&lt;/li&gt;
&lt;li&gt;sapUiNoMarginEnd
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;自定义css和主题颜色&#34;&gt;自定义CSS和主题颜色&lt;/h4&gt;

&lt;p&gt;​   不要在自定义CSS中指定颜色，而是使用标准的主题依赖类。&lt;/p&gt;

&lt;h3 id=&#34;对象组件显示&#34;&gt;对象组件显示&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;组件&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;sap.m.ObjectIdentifier:&lt;/code&gt; 用于需要对操作对象进行明确区分的时候，使用这个组件进行显示。强调的是标识。                title属性是主要标识，text属性是补充，如果titleActive为true，则标题用颜色标识.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.ObjectNumber:&lt;/code&gt; 显示数字,能根据不同的状态提供颜色区分。有四种state: Warning, Error, Success,Default.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.ObjectMarker:&lt;/code&gt; 以图标的方式显示预定义的几种类型，可以绑定press事件。包括 [Flagged、Favorite、Draft&lt;/p&gt;

&lt;p&gt;、Locked、LockedBy、Unsaved、UnsavedBy].&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.ObjectAttribute:&lt;/code&gt; 显示对象，并提供普通和active两种状态，active状态可与事件绑定。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.ObjectStatus:&lt;/code&gt; 显示对象的文本，并且根据状态不同，文本以不同的颜色区分。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.ObjectHeader:&lt;/code&gt; 显示对象，包括标识和附加的信息，图标等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;dialogs-and-fragments&#34;&gt;Dialogs and Fragments&lt;/h2&gt;

&lt;h3 id=&#34;fragments&#34;&gt;Fragments&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;片段是一个轻量级的Ui部分，它只是一组重用控件的容器。包含一到多个控件，不需要控制器。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;定义并调用已存在的 Fragments : &amp;ldquo;sap/ui/core/Fragment&amp;rdquo;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1) 定义xxx.fragment.xml&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;   &amp;lt;core:FragmentDefinition xmlns=&amp;quot;sap.m&amp;quot; xmlns:core=&amp;quot;sap.ui.core&amp;quot;&amp;gt;
   	&amp;lt;Dialog id=&amp;quot;helloDialog&amp;quot; title=&amp;quot;Hello {/recipient/name}&amp;quot;&amp;gt;
   		&amp;lt;content&amp;gt;
   			&amp;lt;core:Icon src=&amp;quot;sap-icon://hello-world&amp;quot; size=&amp;quot;80px&amp;quot; class=&amp;quot;sapUiMediumMargin&amp;quot;&amp;gt;					 &amp;lt;/core:Icon&amp;gt;
   		&amp;lt;/content&amp;gt;
   		&amp;lt;beginButton&amp;gt;
   			&amp;lt;Button text=&amp;quot;{i18n&amp;gt;dialogCloseButtonText}&amp;quot; press=&amp;quot;.onCloseDialog&amp;quot;&amp;gt;&amp;lt;/Button&amp;gt;
   		&amp;lt;/beginButton&amp;gt;
   	&amp;lt;/Dialog&amp;gt;
   &amp;lt;/core:FragmentDefinition&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;   // create dialog lazily
   if (!this.byId(&amp;quot;helloDialog&amp;quot;)) {  //如果id为helloDialog的Dialog不存在
   	// load asynchronous XML fragment
   	Fragment.load({
   		id: oView.getId(),
   		name: &amp;quot;sap.ui.demo.walkthrough.view.HelloDialog&amp;quot;,
             controller:this    //函数的回调
   	}).then(function (oDialog) {
   		// connect dialog to the root view of this component (models, lifecycle)
   		oView.addDependent(oDialog);
   		oDialog.open();
   	});
   } else {
   	this.byId(&amp;quot;helloDialog&amp;quot;).open();
   },
      
   onCloseDialog:function(){
       this.byId(&amp;quot;helloDialog&amp;quot;).close();
   }
   
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;始终使用addDependent方法将对话框连接到视图的生命周期管理和数据绑定，即使它未添加到其UI树中。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果片段中的对话框尚不存在，则通过使用以下方法调用sap.ui.xmlfragment方法来实例化片段&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;回调open方法&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;dialog&#34;&gt;Dialog&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;不属于特定视图，不能将其定义为视图，这意味着必须在控制器代码中的某处实例化对话框。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重用&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1) 定义单独的控制来实现Dialog的创建 HelloDialog.js&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;   sap.ui.define([
   		&amp;quot;sap/ui/base/ManagedObject&amp;quot;, //实现该类
   		&amp;quot;sap/ui/core/Fragment&amp;quot;
   	],
   	function (ManagedObject, Fragment) {
   		&amp;quot;use strict&amp;quot;;
   
   	return ManagedObject.extend(&amp;quot;SAPUI5.Walkthrough.controller.HelloDialog&amp;quot;, {
   		constructor: function (oView) { //oView参数用于关联当前视图到对话框.
   			this._oView = oView;
   		},
   
   		exit: function () {
   			delete this._oView();
   		},
   
   		open: function () {
   			var oView = this._oView;
   
   			//create dialog lazily
   			if (!oView.byId(&amp;quot;helloDialog&amp;quot;)) {
   				var oFragmentController = {
   					onCloseDialog: function () {
   						oView.byId(&amp;quot;helloDialog&amp;quot;).close();
   					}
   				};
   				//load asynchronous XML fragment
   				Fragment.load({
   					id: oView.getId(),
   					name: &amp;quot;SAPUI5.Walkthrough.view.HelloDialog&amp;quot;,
   					controller: oFragmentController
   				}).then(function (oDialog) {
   					//connect dialog to the root view of this component (models,lifecycle)
   					oView.addDependent(oDialog);
   					oDialog.open();
   				});
   			} else {
   				oView.byId(&amp;quot;helloDialog&amp;quot;).open();
   			}
   		}
   	});
   });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2) 在Component.js文件中声明该控件为私有属性,并封装其方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;   sap.ui.define([
   	&amp;quot;sap/ui/core/UIComponent&amp;quot;,
   	&amp;quot;sap/ui/Device&amp;quot;,
   	&amp;quot;SAPUI5/Walkthrough/model/models&amp;quot;,
   	&amp;quot;sap/ui/model/json/JSONModel&amp;quot;,
   	&amp;quot;./controller/HelloDialog&amp;quot;
   ], function (UIComponent, Device, models,JSONModel,HelloDialog) {
   	&amp;quot;use strict&amp;quot;;
   
   	return UIComponent.extend(&amp;quot;SAPUI5.Walkthrough.Component&amp;quot;, {
   
   		metadata: {
   			manifest: &amp;quot;json&amp;quot;
   		},
   
   		/**
   		 * The component is initialized by UI5 automatically during the startup of the app and calls the init method once.
   		 * @public
   		 * @override
   		 */
   		init: function () {
   			// call the base component&#39;s init function
   			UIComponent.prototype.init.apply(this, arguments);
   
   			// enable routing
   			this.getRouter().initialize();
   
   			// set the device model
   			this.setModel(models.createDeviceModel(), &amp;quot;device&amp;quot;);
   
   			//set dialog
   			this._helloDialog = new HelloDialog(this.getRootControl());
   		},
   		
   		exit:function(){
   			this._helloDialog.destory();
   			delete this._helloDialog;
   		},
   		
   		openHelloDialog:function(){
   			this._helloDialog.open();
   		}
   	});
   });
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;在按钮事件中通过&lt;code&gt;this.getOwnerComponent().openHelloDialog()&lt;/code&gt;调用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;onOpenDialog方法现在通过调用辅助方法getOwnerComponent来访问其组件。当调用重用对象的open方法时，我们传入当前视图以将其连接到对话框。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Attention&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;将跨多个控制器使用的所有资产放在单独的模块中&lt;/p&gt;

&lt;h2 id=&#34;icons&#34;&gt;Icons&lt;/h2&gt;

&lt;p&gt;sap.ui.core.Icon&lt;/p&gt;

&lt;h2 id=&#34;数据类型和操作&#34;&gt;数据类型和操作&lt;/h2&gt;

&lt;h3 id=&#34;基本数据类型&#34;&gt;基本数据类型&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;​ sap.ui.model.type.Integer(oFormatOptions?, oConstraints?):支持minimum,maximum&lt;/p&gt;

&lt;p&gt;​ sap.ui.model.type.Float(oFormatOptions?, oConstraints?):&lt;code&gt;decimalSeparator&lt;/code&gt;定义小数位的分隔符&lt;/p&gt;

&lt;p&gt;​ sap.ui.model.type.String(&amp;hellip;&amp;hellip;&amp;hellip;)&lt;/p&gt;

&lt;p&gt;​ sap.ui.model.type.Boolean&lt;/p&gt;

&lt;p&gt;​ sap.ui.model.type.Date : ui5支持原数据为JavaScript和原数据为String的日期数据进行格式输出&lt;/p&gt;

&lt;p&gt;​ sap.ui.model.type.Time : Time也支持原数据为Time类型或者字符串类型&lt;/p&gt;

&lt;p&gt;​ sap.ui.model.type.DateTime&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;属性设置&#34;&gt;属性设置&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;尽可能使用数据类型而不是自定义格式化程序。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;number=&amp;quot;{
	parts: [{path: &#39;invoice&amp;gt;ExtendedPrice&#39;}, {path: &#39;view&amp;gt;/currency&#39;}],
	type: &#39;sap.ui.model.type.Currency&#39;,
	formatOptions: {
		showMeasure: false
	}
}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;计算字段绑定(parts)：它允许将来自不同模型的多个属性绑定到控件的单个属性。&lt;/li&gt;
&lt;li&gt;控件的属性是数字，从两个不同模型检索的绑定属性（“部件”）invoice&amp;gt; ExtendedPrice和view&amp;gt; / currency。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Expression Binding 仅使用表达式绑定进行简单的计算。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;numberState=&amp;quot;{= ${invoice&amp;gt;ExtendedPrice} &amp;gt; 50 ? &#39;Error&#39; : &#39;Success&#39; }&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;数据校验&#34;&gt;数据校验&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;基本使用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​    sap.ui.core.message.MessageManager();&lt;/p&gt;

&lt;p&gt;​    registerObject(oObject,bHandelValidation) : 第一个参数是ManagedObject对象的实例，第二个参数是boolean类型变量，为true时执行数据校验。&lt;/p&gt;

&lt;p&gt;​    attachValidationError(this,function(){}) : 控件都有该方法，用于校验失败时的处理。&lt;/p&gt;

&lt;p&gt;​    attachValidationSuccess(this,function(){}) : 用于校验成功时的处理。&lt;/p&gt;

&lt;p&gt;ValueState 种类:setValueState()&lt;/p&gt;

&lt;p&gt;​    sap.ui.core.ValueState.Error&lt;/p&gt;

&lt;p&gt;​    sap.ui.core.ValueState.None&lt;/p&gt;

&lt;p&gt;​    sap.ui.core.ValueState.Success&lt;/p&gt;

&lt;p&gt;​    sap.ui.core.ValueState.Warning&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;集中处理数据校验:&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;sap.ui.core.Core也可添加attachValidationError().&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;自定义数据类型校验:&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;sap.ui.model.SimpleType.extend()自定义数据类型，可以使用formatValue(),parseValue(),validateValue()实现自定义的校验规则和提示消息。&lt;/p&gt;

&lt;p&gt;抛出异常信息：throw new sap.ui.model.ValidationException(&amp;ldquo;Message&amp;rdquo;);&lt;/p&gt;

&lt;p&gt;截取异常消息，使用该类型的控件通过&lt;code&gt;oEvent.getParameter(&amp;quot;message&amp;quot;)&lt;/code&gt;获取该错误消息。&lt;/p&gt;

&lt;h3 id=&#34;formart设置&#34;&gt;Formart设置&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;在Constructor或绑定方法中定义formatter (绑定单个控件)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;var oText = new sap.m.Text({
        text:{ formatter:function(sValue){
                        return sValue &amp;amp;&amp;amp; sValue.toUpperCase();
                }
        }
     });&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在Controller中定义formatter (更灵活，可重复调用)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;Text text=&#34;{path: &#39;/productname&#39;, formatter: &#39;.toUpper&#39;}&#34;/&gt;&lt;/p&gt;

&lt;p&gt;其中&lt;code&gt;.toUpper&lt;/code&gt; 前面的&lt;code&gt;.&lt;/code&gt;表示当前Controller方法。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在专门模块中定义formatter&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;单独定义formatter在Controller中引入该文件。并在view中调用。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;自定义数据类型中设置formatter&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;搜索与过滤&#34;&gt;搜索与过滤&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;添加搜索框并绑定事件 &lt;code&gt;sap.m.SearchField&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;List id=&amp;quot;invoiceList&amp;quot; items=&amp;quot;{invoice&amp;gt;/Invoices}&amp;quot;&amp;gt;
&amp;lt;headerToolbar&amp;gt;
  &amp;lt;Toolbar&amp;gt;
     &amp;lt;Title text=&amp;quot;{i18n&amp;gt;invoiceListTitle}&amp;quot;/&amp;gt;
     &amp;lt;ToolbarSpacer/&amp;gt;
     &amp;lt;SearchField width=&amp;quot;50%&amp;quot; search=&amp;quot;.onFilterInvoices&amp;quot;/&amp;gt;
  &amp;lt;/Toolbar&amp;gt;
&amp;lt;/headerToolbar&amp;gt;
  &amp;lt;items&amp;gt;
  	&amp;lt;ObjectListItem&amp;gt;
    	,,,,,,
    &amp;lt;/ObjectListItem&amp;gt; 
  &amp;lt;/items&amp;gt;
&amp;lt;/List&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;事件定义并实现过滤&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;filter对象将保留我们对filter操作的配置。&lt;strong&gt;new sap.ui.model.Filter(vFilterInfo, vOperator?, vValue1?, vValue2?)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;FilterOperator是我们需要的帮助器类型，以指定过滤器，范围。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;   new Filter({
         path: &amp;quot;Price&amp;quot;,
         operator: FilterOperator.BT,
         value1: 11.0,
         value2: 23.0
       });
       
   new Filter({
       filters: [
         ...
         new Filter({
           path: &#39;Quantity&#39;,
           operator: FilterOperator.LT,
           value1: 20
         }),
         new Filter({
           path: &#39;Price&#39;,
           operator: FilterOperator.GT,
           value1: 14.0
         })
         ...
       ],
       and: true|false
     })
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;   onFilterInvoices : function (oEvent) {
   	// build filter array
   	var aFilter = [];
   	var sQuery = oEvent.getParameter(&amp;quot;query&amp;quot;); //&amp;quot;query&amp;quot; 获取搜索字段
   	if (sQuery) {
   		aFilter.push(new Filter(&amp;quot;ProductName&amp;quot;, FilterOperator.Contains, sQuery)); //添加过滤条件
   	}
   
   	// filter binding
   	var oList = this.byId(&amp;quot;invoiceList&amp;quot;);     //获取List对象
   	var oBinding = oList.getBinding(&amp;quot;items&amp;quot;); //获取绑定的items
   	oBinding.filter(aFilter);			   //根据过滤条件过滤items数据
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;排序与分组&#34;&gt;排序与分组&lt;/h3&gt;

&lt;p&gt;​       &lt;code&gt;new sap.ui.model.Sorter(sPath, bDescending?, vGroup?, fnComparator?)&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;items=&amp;ldquo;{path:&amp;lsquo;invoice&amp;gt;/Invoices&amp;rsquo; sorter:{path:&amp;lsquo;ProductName&amp;rsquo;}}&amp;rdquo;  //默认是升序ascending,可以添加属性descending : true.&lt;/li&gt;
&lt;li&gt;items=&amp;ldquo;{path:&amp;lsquo;invoice&amp;gt;/Invoices&amp;rsquo; sorter:{path:&amp;lsquo;ProductName&amp;rsquo;,group:true}}&amp;rdquo;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;私有函数和变量&#34;&gt;私有函数和变量&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;私有函数和变量应始终以下划线开头。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;消息设置&#34;&gt;消息设置&lt;/h2&gt;

&lt;h3 id=&#34;sap-m-messagebox&#34;&gt;sap.m.MessageBox&lt;/h3&gt;

&lt;p&gt;​    SAPUI5 提供的对话框，可以显示信息、警告、错误等等。MessageBox 类是静态类，在使用之前必须执行 &lt;code&gt;jQuery.sap.require(&amp;quot;sap.m.MessageBox&amp;quot;)&lt;/code&gt; 语句 SAPUI5 包含 jQuery 包，&lt;code&gt;jQuery.sap.require(vModuleName)&lt;/code&gt; 方法的作用是加载指定的模块并且执行，这样 MessageBox 的 show() 方法才能运行。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;sap.m.MessageBox.alert(vMessage, mOptions*?*)&lt;/code&gt;对话框显示消息，有一个OK按钮（“确定”），没有图标&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.MessageBox.confirm(vMessage, mOptions*?*)&lt;/code&gt; 确认对话框，询问是否确定，有一个OK按钮和Cancel按钮，一个问号的图标。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.MessageBox.error(vMessage, mOptions*?*)&lt;/code&gt; 显示错误对话框，带有错误图标和关闭按钮Displays an error dialog with the given message, an ERROR icon, a CLOSE button。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.MessageBox.information(vMessage, mOptions*?*)&lt;/code&gt; 消息对话框，带有INFO图标和OK按钮。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.MessageBox.show(vMessage, mOptions*?*)&lt;/code&gt; 显示对话框，类型为sap.m.DialogType.Message，图标和按钮由开发人员自行定义，相对灵活一些。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.MessageBox.success(vMessage, mOptions*?*)&lt;/code&gt; 显示成功对话框，带有SUCCESS图标和OK按钮。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.MessageBox.warning(vMessage, mOptions*?*)&lt;/code&gt; 显示警告消息，带有WARNING图标和OK按钮。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.m.MessageToast.show()&lt;/code&gt;对用户操作提供一种简单的反馈，并且经过一段时间后自动消失，除非用户将鼠标放在消息上面。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;模块化&#34;&gt;模块化&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;如何加载模块&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;jQuery.sap.declare(sModuleName,bCreateNamespace)&lt;/code&gt;申明一个模块，以确保模块存在。这个语句必须出现在 模块代码（也就是代码文件)的第一句。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;jQuery.sap.require(vModuleName)&lt;/code&gt;确保当前代码继续之前，所指定的模块被加载和执行。如果所需要的模块没有被加载，将会被同步加载和执行，如果已经加载，就忽略。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.ui.define(sModuleName,aDependencies,vFactory,bExport)&lt;/code&gt;定义module，异步加载依赖模块,sap.ui.define()定义的模块具有全局命名空间。2:定义依赖 3:继承工厂函数。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sap.ui.require()&lt;/code&gt;异步加载依赖的模块，不具有全局命名空间。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用模块方法实现Controller&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;sap.ui.define(
	[&amp;quot;Dependencies1&amp;quot;,&amp;quot;Dependencies2&amp;quot;],
	function(Controller){
	&amp;quot;use strict&amp;quot;;
		return Controller.extend(&amp;quot;ControllerName&amp;quot;,{
			onInit:function(){},
              onBeforeRendering:function(){},
              onAfterRendering:function(){},
              onExit:function(){}
		});
	}
);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;参数1 : 不定义，便于对模块进行访问&lt;/li&gt;
&lt;li&gt;参数2 : 指定依赖的模块，可指定多个&lt;/li&gt;
&lt;li&gt;参数3 : 定义工厂函数，实现Controller功能&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;model-binding&#34;&gt;Model Binding&lt;/h2&gt;

&lt;h3 id=&#34;单数据绑定&#34;&gt;单数据绑定&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;使用数据绑定前，需要先实例化Model.构造函数获取实例的URL或则数据本身作为第一个参数。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​    JSON-Model:&lt;/p&gt;

&lt;p&gt;​        &lt;code&gt;var oModel = new sap.ui.model.json.JSONModel(dataUrlOrData);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​    XML-Model:&lt;/p&gt;

&lt;p&gt;​        &lt;code&gt;var oModel = new sap.ui.model.xml.XMLModel(dataUrlOrData);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​    OData-Model:&lt;/p&gt;

&lt;p&gt;​        &lt;code&gt;var oModel = new sap.ui.model.odata.ODataModel(dataUrl[,userJSON,user,pass]);&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;给Model设置值&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;oModel.setData(data);  绑定定义的数据&lt;/p&gt;

&lt;p&gt;oModel.loadData(&amp;ldquo;models/suppliers.json&amp;rdquo;); 从文件中读取数据绑定&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;将Model分配给Core或则其他的控制器（setModel）方法。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Global model:&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​        &lt;code&gt;sap.ui.getCore().setModel(oModel)&lt;/code&gt; : 这样oModel对整个应用程序可见&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Bind a model to a view&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​       &lt;code&gt;var oView = sap.ui.view({type:sap.ui.core.mvc.ViewType.JS,viewName:&amp;quot;text.view&amp;quot;})&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​     &lt;code&gt;oView.setModel(oModel);&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Bind a model to a specific control&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​        &lt;code&gt;var oTable = sap.ui.getCore().byId(&amp;quot;table&amp;quot;);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​        &lt;code&gt;oTable.setModel(oModel);&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Model属性绑定方法（{ } curly braces，bindProperty()）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​    控件的大多数属性都可以绑定到模型属性。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;bindProperty  method: [extend : sap.ui.base.ManagedObject]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​        &lt;code&gt;oControl.bindProperty(&amp;quot;sName&amp;quot;,&amp;quot;oBindingInfo&amp;quot;);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​            oBindingInfo attributes : path、model、formatter等&lt;/p&gt;

&lt;p&gt;​                path : 指定绑定的数据路径&lt;/p&gt;

&lt;p&gt;​                model : sap.ui.model.BindingMode.OneWay、sap.ui.model.BindingMode.TwoWay&lt;/p&gt;

&lt;p&gt;​                formatter :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;花括号:{ }
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​        &lt;code&gt;var oControl = new sap.ui.commons.TextView({controlProperty:&amp;quot;{/modelProperty}&amp;quot;});&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;alternatively：
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​        &lt;code&gt;var oControl = new sap.ui.commons.TextView({controlProperty:{path:&amp;quot;/modelProperty&amp;quot;}});&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Model属性的获取。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;oModel.getProperty(&amp;ldquo;/sName&amp;rdquo;);    根据JSON数据属性名获取对应的值&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;多数据绑定&#34;&gt;多数据绑定&lt;/h3&gt;

&lt;p&gt;​    用于绑定集合数据，如绑定多行数据到一个表格中。使用模板:所有行都用同样的方法显示数据。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用模板:所有行都用同样的方法显示数据&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;var oItemTemplate = new sap.ui.core.ListItem({text:&amp;quot;{aggrProperty}&amp;quot;});
var oComboBox = new sap.ui.commons.ComboBox({
items:{path:&amp;quot;/modelAggregation&amp;quot;, template: oItemTemplate}
});
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;bindAggregation():&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​        &lt;code&gt;oComboBox.bindAggregation(&amp;quot;items&amp;quot;,&amp;quot;/modelAggregation&amp;quot;,oItemTemplate);&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;工厂函数实现聚合绑定&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;oTable.bindAggregation(&amp;ldquo;items&amp;rdquo;,&amp;ldquo;/modelData&amp;rdquo;,function(sId,oContext){&lt;/p&gt;

&lt;p&gt;​ return oColumnListItem; //通过工厂函数，定义数据并返回&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;h3 id=&#34;元素绑定&#34;&gt;元素绑定&lt;/h3&gt;

&lt;p&gt;​   元素绑定指根据上下文(binding context)使用相对绑定的方式绑定到model数据的某一具体对象。尤其适用于&lt;strong&gt;主从数据显示(master-detail data)&lt;/strong&gt;的情况。&lt;/p&gt;

&lt;p&gt;​   sap.m.List(sId?, mSettings?) : List控件适用于显示行项目，所有类型都可以。&lt;/p&gt;

&lt;p&gt;​   sap.m.ObjectListItem(sId?, mSettings?) : 适用于显示行项目的信息，主要使用&lt;strong&gt;title&lt;/strong&gt;属性进行标识，text、icon、atrributes和statuses等属性可以用于提供对象更多信息。&lt;/p&gt;

&lt;p&gt;​   sap.m.Panel().bindElement({path:sPath}) : 将显示的明细与Model绑定。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;左边是一个List控件，右边在Panel中放置几个控件组合。当选择左边某个产品的时候，右边相应显示该产品的信息。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;oEvent.getSource().getBindingContext()&lt;/code&gt;获取绑定的项，再使用&lt;code&gt;getPath()&lt;/code&gt;方法得到path路径，然后设置右边的detailPanel与这个路径绑定。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Model 中detail包含多条数据的情况，点击 一个header,显示多个行项目，可以通过&lt;code&gt;sap.ui.model.Filter()&lt;/code&gt;的方法实现。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;绑定点击事件,&lt;code&gt;oSupTable.attachRowSelectionChange(fuction(oEvent()))&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;通过&lt;code&gt;var oRowContext = oEvent.getParameter(&amp;quot;rowContext&amp;quot;)&lt;/code&gt;获取行的上下文。如果选中第一行，rowContext就是constructor {oModel: 指定Model, sPath: &amp;ldquo;数据第一行地址&amp;rdquo;}。&lt;/p&gt;

&lt;p&gt;然后通过&lt;code&gt;var sSelectedId = oModel.getProperty(&amp;quot;id&amp;quot;, oRowContext)&lt;/code&gt;;就能获取到所选择行的id数据。&lt;/p&gt;

&lt;p&gt;通过 &lt;code&gt;var oBinding = oPrdTable.getBinding()&lt;/code&gt;;获取对应详细数据的绑定。&lt;/p&gt;

&lt;p&gt;定义过滤规则，var oF = new sap.ui.model.Filter({path:&amp;ldquo;key index&amp;rdquo;,oprator: new sap.ui.model.FilterOperator.BT,value1:value&amp;hellip;})。&lt;/p&gt;

&lt;p&gt;使用过滤规则，oBinding.filter(oF);&lt;/p&gt;

&lt;h3 id=&#34;绝对绑定和相对绑定&#34;&gt;绝对绑定和相对绑定&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;绝对绑定&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;将value属性绑定到json model根目录下对应的字段title/attr。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;相对绑定&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;相对绑定尤其适用于布局(layout)控件或者容器控件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当父控件的绑定路径设置后，子控件可以基于这个路径使用相对路径。&lt;/p&gt;

&lt;h2 id=&#34;routing导航&#34;&gt;Routing导航&lt;/h2&gt;

&lt;p&gt;​   Openui5 的 routing 基于模式 ( pattern )，使用 &lt;code&gt;#&lt;/code&gt; 符号表示不同的路径 ( route )，导航通过路径的改变来实现。&lt;/p&gt;

&lt;h3 id=&#34;pattern-表达式&#34;&gt;Pattern 表达式&lt;/h3&gt;

&lt;p&gt;Openui5 一共有 5 种 pattern表达式:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;硬编码模式&lt;/strong&gt; : 页面之间根据模式导航，没有参数传递，比如 product/settings 表示导航到产品配置。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;路径含有必输参数模式&lt;/strong&gt; : 模式中 大括号({}) 包含的部分表示参数必须输入。比如 product/{id} 表示导航到产品某一 id，比如 product/5 表示 id 为 5 的产品，id 为必输。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;路径含有可选参数模式&lt;/strong&gt; : 模式中 冒号 包含的部分为必输参数。比如 product/{id}/detail/:detailId:，detailId 为可选参数。product/5/detail 以及 product/3/detail/2 都能与此模式匹配。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;路径含有查询参数模式&lt;/strong&gt; : 查询参数 ( query parameter ) 在问号之后。比如 product{?query}，query 这个参数为必输项。product:?query: 中的 query 这个参数为可选参数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;**通配参数模式 **: 以星号结尾的参数是通配参数，通配参数将根据模式尽可能匹配。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;导航调用&#34;&gt;导航调用&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;父导航&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1) 跳转到Detail view子导航&lt;/p&gt;

&lt;p&gt;2) 向Detail view传递一个参数，参数为当前点击的路径，Detail获取该路径完成数据绑定&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;var oRouter = UIComponent.getRouterFor(this);获取当前的router&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;var oItem = oEvent.getSource();获取点击所在的行&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;oItem.getBindingContext().getPath();获取点击的路径，String类型（/Sup/0）路径传到Detail&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;oRouter.navTo(&amp;ldquo;detail&amp;rdquo;,{supplierPath:encodeURIComponent(sPath)});方法不能包含&lt;code&gt;/&lt;/code&gt;所以使用 &lt;code&gt;encodeURIComponent()&lt;/code&gt; 函数编码，在Detail controller 中用&lt;code&gt;decodeURIComponent()&lt;/code&gt;函数解码。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;子导航&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1) 获取 Master view 传递的路径，根据此路径完成 element binding。比如当 Master view 传过来 &lt;code&gt;/Suppliers/0&lt;/code&gt;，则与第一条数据绑定;&lt;/p&gt;

&lt;p&gt;2) 根据页面之间的关系，当点击 &lt;strong&gt;返回&lt;/strong&gt; 按钮时，返回到上一个页面。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;var oRouter = UIComponent.getRouterFor(this);&lt;/code&gt;获取当前Router&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;oRouter.getRoute(&amp;quot;detail&amp;quot;).attachPatternMatched(this._onObjectMatched, this);&lt;/code&gt;，当模式匹配时，附加事件处理器为 &lt;code&gt;_onObjectMatched&lt;/code&gt;。然后在 &lt;code&gt;_onObjectMatched&lt;/code&gt; 中获取 Master view 传递的路径并绑定数据。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt; _onObjectMatched: function (oEvent) {           
     var sPath = decodeURIComponent(
             oEvent.getParameter(&amp;quot;arguments&amp;quot;).supplierPath);
     this.getView().bindElement({path: sPath});
 }   
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当用户点击导航按钮，判断是否有上一个路径 ( previous hash )，如果有就返回上一个路径，否则跳转到 Master view:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt; onNavPress: function() {
     var oHistory = History.getInstance();
     var sPreviousHash = oHistory.getPreviousHash();
         
     if (sPreviousHash != undefined){
         window.history.go(-1);
     }else{
         var oRouter = UIComponent.getRouterFor(this);
         oRouter.navTo(&amp;quot;master&amp;quot;,{}, true);
     }
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;mock-server&#34;&gt;mock server&lt;/h2&gt;

&lt;p&gt;​   在开发过程中，通过使用模拟服务器的方法方便测试，SAPUI5将模拟服务器称为mock server.mock server的基本功能是模拟oData数据的提供者，截获应用程序对服务器端的http或https请求，并传回模拟请求的回应，可以降低与真实后端的耦合。&lt;/p&gt;

&lt;h1 id=&#34;系统配置和功能块&#34;&gt;系统配置和功能块&lt;/h1&gt;

&lt;h2 id=&#34;sap-netweaver-gateway&#34;&gt;SAP NetWeaver Gateway&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;SAP NetWeaver Gateway 是一种技术，它提供了一种基于市场标准将设备，环境和平台连接到 SAP 软件的简单方法。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;任何SAP业务套件都是无中断的&lt;/p&gt;

&lt;p&gt;易于开发简单的API,不需要任何工具知识&lt;/p&gt;

&lt;p&gt;基于REST,oData。允许使用功能任何编程语言或模型连接到SAP应用程序&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;将SAP NetWeaver Gateway 连接到 SAP Business Suite&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1) 将后端服务器配置为信任系统 : SM59&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/SAPUI5/1559703243928.png&#34; alt=&#34;1559703243928&#34; /&gt;&lt;/p&gt;

&lt;p&gt;​                &lt;img src=&#34;https://coldinfire.github.io/images/SAPUI5/1559712968906.png&#34; alt=&#34;1559712968906&#34; /&gt;&lt;/p&gt;

&lt;p&gt;2) SMT1&lt;/p&gt;

&lt;p&gt;​                &lt;img src=&#34;https://coldinfire.github.io/images/SAPUI5/1559713194355.png&#34; alt=&#34;1559713194355&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;SAP NetWeaver Gateway部署选项&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1) 中央枢纽部署 : 后端系统的开发&lt;/p&gt;

&lt;p&gt;​    在此类部署选项中，中央 UI 附加组件，特定于产品的 UI 附加组件和 SAP NetWeaver 网关包含在 ABAP 前端服务器中。后端服务器包含业务逻辑和后端数据。开发在 ABAP 后端系统中进行。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;它需要单独的 SAP NetWeaver Gateway 系统&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;它允许在没有后端开发授权的情况下更改 UI。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;它为所有 UI 问题提供单点维护。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;它为 Fiori Apps 的主题和品牌提供了中心位置。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;它提供对后端系统的单点访问。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;由于无法直接访问后端系统，因此增强了安全性。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;直接本地访问元数据（DDIC）和业务数据以及轻松重用数据。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2) 中央集线器的部署&lt;/p&gt;

&lt;p&gt;​    如果必须在后端系统上执行开发，或者在 7.40 之前的版本中执行开发，则使用此选项。如果不允许在&lt;strong&gt;后端&lt;/strong&gt;部署 Add-On &lt;strong&gt;IW_BEP&lt;/strong&gt;。在这种情况下，开发人员仅限于可通过后端 RFC 访问的接口。&lt;/p&gt;

&lt;p&gt;​    开发在 Gateway 集线器系统中进行，并且不触及 Business Suite 后端系统。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;无法直接访问&lt;strong&gt;元数据（DDIC）&lt;/strong&gt;和业务数据。因此，数据的重用是有限的。&lt;/li&gt;
&lt;li&gt;无法远程使用 GENIL 对象。&lt;/li&gt;
&lt;li&gt;在此配置中，访问仅限于远程启用的接口，如 RFC 模块，BAPI 等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;odata-开放数据协议&#34;&gt;oData(开放数据协议)&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;概述: OData 用于定义构建和使用 RESTful API 所需的最佳实践&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;OData 提供扩展功能，以满足 RESTful API 的任何自定义需求。&lt;/li&gt;
&lt;li&gt;REST 代表 Representational State Transfer。&lt;/li&gt;
&lt;li&gt;它依赖于无状态，客户端 - 服务器，可缓存的通信协议。几乎在所有情况下，都使用 HTTP 协议。&lt;/li&gt;
&lt;li&gt;REST 被定义为用于设计网络应用程序的体系结构样式。&lt;/li&gt;
&lt;li&gt;OData 可帮助您在构建 RESTful API 时专注于业务逻辑，而无需担心定义请求和响应头，状态代码，HTTP 方法，URL 约定，媒体类型，有效负载格式和查询选项等的方法。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;oData服务生命周期&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;OData 服务生命周期包括 OData 服务的范围。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;激活 OData 服务。&lt;/li&gt;
&lt;li&gt;维护 OData 服务。&lt;/li&gt;
&lt;li&gt;维护模型和服务，直至清理元数据缓存。&lt;/li&gt;
&lt;li&gt;RESTful 应用程序使用 HTTP 请求发布数据以创建或更新，读取数据和删除数据。REST 对所有四个 CRUD（创建 / 读取 / 更新 / 删除）操作使用 HTTP。&lt;/li&gt;
&lt;li&gt;REST 是 RPC（远程过程调用）和 Web 服务等机制的轻量级替代方法。
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;oData设置&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在manifest.json中配置服务器：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;   &amp;quot;sap.app&amp;quot;: {
   	...
   	&amp;quot;ach&amp;quot;: &amp;quot;CA-UI5-DOC&amp;quot;,
   	&amp;quot;dataSources&amp;quot;: {
   	  &amp;quot;invoiceRemote&amp;quot;: {
   		&amp;quot;uri&amp;quot;: &amp;quot;https://services.odata.org/V2/Northwind/Northwind.svc/&amp;quot;,
   		&amp;quot;type&amp;quot;: &amp;quot;OData&amp;quot;,
   		&amp;quot;settings&amp;quot;: {
   		  &amp;quot;odataVersion&amp;quot;: &amp;quot;2.0&amp;quot;
   		}
   	  }
   	}
    &amp;quot;sap.ui5&amp;quot;: {
   	...
   	&amp;quot;models&amp;quot;: {
   	  ...
   	  &amp;quot;invoice&amp;quot;: {
   		&amp;quot;dataSource&amp;quot;: &amp;quot;invoiceRemote&amp;quot;
   	  }
   	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;sap-fiori-launchpad&#34;&gt;SAP Fiori Launchpad&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;关于 SAP Fiori Launchpad 的要点如下。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;基于 Web 的入口点，可跨平台和设备使用 SAP Business 应用程序。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;作为 I HTML 客户端的开箱即用思想提供。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用主题，搜索集成，自定义等功能为最终用户提供高生产率。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为使用多种设备类型的最终用户提供单一入口点。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title> Python学习资源</title>
      <link>https://coldinfire.github.io/2019/PythonResource/</link>
      <pubDate>Tue, 16 Apr 2019 17:20:58 +0800</pubDate>
      
      <guid>https://coldinfire.github.io/2019/PythonResource/</guid>
      <description>

&lt;h1 id=&#34;资源&#34;&gt;资源&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.python.org/3/tutorial/classes.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Python 官网&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/vinta/awesome-python&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;包含了 Python 框架、Python 库和软件的 awesome 列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/aosabook/500lines&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Python 神书，里面有若干个项目，每个项目都是由业内大神所写，每个项目代码在 500 行左右&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pymotw.com/3/#python-3-module-of-the-week&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;介绍 Python3 中的标准库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jackfrued/Python-100-Days&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;一百天学Python,github开源&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/JeffPaine/beautiful_idiomatic_python&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;写出简洁的、优雅的 Python 代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jobbole.github.io/awesome-python-cn/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Python 资源大全，包含：Web 框架、网络爬虫、模板引擎和数据库等，由伯乐在线更新&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pycoders.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;优秀的免费邮件 Python 新闻周刊&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://python.jobbole.com/82399/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;伯乐在线翻译的 Python 学习资源&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.fullstackpython.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Python 资源汇总，从基础入门到各种 Web 开发框架，再到高级的 ORM，Docker 等等&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python-guide.org/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;kennethreitz介绍 Python 的最佳实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pymbook.readthedocs.io/en/latest/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;介绍 Python 的基本语法，特点等&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://districtdatalabs.silvrback.com/how-to-develop-quality-python-code&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;开发高质量的 Python 代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gist.github.com/sloria/7001839&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Python 最佳实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://python3-cookbook.readthedocs.io/zh_CN/latest/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Cook Book&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Yixiaohan/codeparkshare&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;推荐内容&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pypi.org/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://pypi.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pyvideo.org/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Python Video&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title> Python基础 </title>
      <link>https://coldinfire.github.io/2019/Linux/</link>
      <pubDate>Wed, 16 Jan 2019 17:20:58 +0800</pubDate>
      
      <guid>https://coldinfire.github.io/2019/Linux/</guid>
      <description>

&lt;h1 id=&#34;基本命令&#34;&gt;基本命令&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;man [command]:查看命令使用文档
1. 文件
  ex: -rw--w-r-- 1 user group day month time text.xx
  第一个文件代表意义(0)：
    [d]:目录
    [-]:文件
    [l]:链接文档
    [b]:可随机存储装置
    [c]:串行端口设备
  后续文字意义：
    &amp;lt;1&amp;gt;.三个为一组均为[rwx]组合(r:read w:write x:execute)
    u=第一组(123)：文件拥有者权限   g=第二组(456)：所属组权限   o=第三组(789)：其他用户权限
    &amp;lt;2&amp;gt;.文件硬链接个数
    &amp;lt;3&amp;gt;.文件拥有者
    &amp;lt;4&amp;gt;.同属者
    &amp;lt;5&amp;gt;.大小
    &amp;lt;6&amp;gt;.修改时间
  修改权限：
    chmod [xx] file:修改文件的权限 
                    [u=rwx,g=rwx,o=rwx]/[u+r,w,x...] :修改各自对应的权限 [a=rwx]:修改所有的权限
                    [777]:对应的权限值和，可修改权限
    chown user file:修改文件所有者
    chgrp group file:修改文件所属组
2. 处理文件常用命令：
    ls/ll -al ~:显示所有文件(~显示隐藏)
    cd:切换目录
    touch file.xxx:创建文件
    touch {1,2,3,..}.xxx :创建多个文件
    vi/vim file.xxx:创建并编辑文件
    pwd [-p]:显示当前所在目录 [p]:真是路径而非link路径
    mkdir [-mp]:创建新目录 [p]:递归创建 [m]:修改文件权限 777
    rmdir [-p]:删除空目录 [p]:删除上层空目录
    cp [-pdri]:复制  [p]:连同文件属性复制  [r]递归持续复制  [d]复制链接文档而非文件本身  [i]目标文档已存在，提示是否覆盖
    rm [-fir]:移除文件或目录 [f]忽略不存在文件 [i]互动模式 [r]递归删除
    创建回收站：myrm(){ D=/tmp/$(date +%Y%m%d%H%M%S); mkdir -p $D; mv &amp;quot;$@&amp;quot; $D &amp;amp;&amp;amp; echo &amp;quot;moved to $D ok&amp;quot;; }
            alias rm= &#39;myrm&#39;
            rm [1,2,3].xxx
    mv [-fiu]:移动文件或目录，修改名称 [f]强制 [i]互动模式 [u]source较新,update
3. 文件内容查看
    grep []:查找文件内出现
    find []:查找文件
    cat:从第一行显示 [n]:行号 [v]:列出特殊字符
    tac:从最后一行显示 
    nl:显示行号
    more:页显示
    less:页显示可以往前翻页
    head:头几行  [-n number]:显示几行
    tail:尾巴几行  [-n number]:显示几行
4. 链接创建
    ln f1 f2:创建f1的一个硬连接文件f2
    ln -s f1 f2:创建f1的一个符号连接文件f2
5. 压缩解压
    file.tar.gz   file.tar.bz2
    tar -cvf [tar_file.tar] [1,2,3,4]:打包
    tar -xvf [tar_file.tar]:解包
    tar -zcvf [tar_file.tar.gz] [1,2,3,4]:压缩打包
    tar -zxvf [tar_file.tar.gz]:当前目录解压包
    tar -zxvf [tar_file.tar.gz] -C [指定目录]：解压到指定目录
    tar -jcvf [tar_file.tar.bz2] [1,2,3,4]:压缩打包
    tar -jxvf [tar_file.tar.bz2]:解压
    zip [-r] 目标文件 源文件
    unzip [-d] 解压后目录文件 压缩文件
6. 管道
    cat /etc/group | grep &#39;sudo&#39; :将&#39;|&#39;前内容放到管道里，后面对管道进行操作
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;系统工具&#34;&gt;系统工具&lt;/h1&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;1. 磁盘分析
    df [-ah]:系统磁盘使用信息
    du [-ah]:当前文件的使用
    fdisk [-l] [name]:磁盘分区表操作工具
    mkfs [-t 文件格式] 装置文件名:磁盘格式化 
    mkfs [tab][tab]:查看mkfs支持文件格式
    fsck :磁盘检验
    mount 装置文件名 挂载点：磁盘挂载
    umount [-fn]:卸载 [-f]:强制卸除 [-n]:不升级/etc/mtab下卸除
2. 网络性能  
    ifconfig [card] [x]:网络状态 [-a]:显示全部接口信息 [up/down]:开启关闭网卡 
                                etho:第一块网卡   lo:回环地址
    ps [-aux]  进程
    top        动态进程
    kill [-9] pid:杀死进程 [-9]:强制杀死
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;远程 rcp: 远程拷贝文件 scp [] 原路径 目标路径：远程拷贝文件，secure copy wget [参数] URL 地址：下载&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;用户权限&#34;&gt;用户权限&lt;/h1&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;1. user:cat /home/...
    who     :查看用户
    whoami  :查看当前用户
    ssh username@ip：远程登录电脑
    useradd name [-mg] :添加用户并自动添加home目录 [-g]:用户组 [-m]:主目录
    passwd name  :修改密码
    su - user   :切换到指定用户(muiot)
    su  user    :to the user
    sudo -s     :切换到root
    su          :to root
    userdel     :del user [-r]:删除用户主目录
    usermod [-aG] group user :change user info  [-a]:添加组 [-g]:group修改默认组 [-aG]:添加其它组
2. user group:cat /etc/group
    查看组:cat /etc/group   groupmod [tab][tab]
    groupmod tabtabtab :check group
    groupadd g_name :add group
    groupdel g_name :del group
    groups username :user in which group
    newgrp root:用户在用户组之间进行切换
3. 重要文件
    /etc/passwd:用户管理涉及到的最重要的一个文件(用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell)
    /etc/group:用户组所有信息(组名:口令:组标识号:组内用户列表)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;vim&#34;&gt;vim&lt;/h1&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;1.使用
    vim/vi filename =====&amp;gt;命令模式=====&amp;gt;i,a,o=====&amp;gt;输入模式======&amp;gt;ESC=====&amp;gt;命令模式
    命令模式=====&amp;gt;:=====&amp;gt;底线命令模式=====&amp;gt;:wq!(退出)
    :set nu (显示行号)     :set nonu (取消行号)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;下载-yum&#34;&gt;下载 yum&lt;/h1&gt;

&lt;hr /&gt;
</description>
    </item>
    
    <item>
      <title> Python基础 </title>
      <link>https://coldinfire.github.io/2019/Python1/</link>
      <pubDate>Wed, 16 Jan 2019 17:20:58 +0800</pubDate>
      
      <guid>https://coldinfire.github.io/2019/Python1/</guid>
      <description>

&lt;h1 id=&#34;变量定义和数据类型&#34;&gt;变量定义和数据类型&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;变量定义&#34;&gt;变量定义&lt;/h2&gt;

&lt;p&gt;Python的变量命名规则：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;硬性规则：

&lt;ul&gt;
&lt;li&gt;变量由字母、数字和下划线构成，不能以数字开头&lt;/li&gt;
&lt;li&gt;大小写敏感&lt;/li&gt;
&lt;li&gt;不能跟python的关键字和系统保留字冲突&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;PEP8要求：

&lt;ul&gt;
&lt;li&gt;用小写字母拼写，多个单词用下划线连接&lt;/li&gt;
&lt;li&gt;受保护的实例属性用单个下划线开头&lt;/li&gt;
&lt;li&gt;私有实例属性用两个下划线开头&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Python关键字列表：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;strong&gt;False&lt;/strong&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;&lt;strong&gt;class&lt;/strong&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;&lt;strong&gt;finally&lt;/strong&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;&lt;strong&gt;is&lt;/strong&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;None&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;continue&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;lambda&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;try&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;True&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;def&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;from&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;nonlocal&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;while&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;and&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;del&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;global&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;not&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;with&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;as&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;if/else/elif&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;or&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;yield&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;assert&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;import&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;break&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;pass&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;except&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;raise&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;in&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;_*  __&lt;/strong&gt;*&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;*****&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;数据类型&#34;&gt;数据类型&lt;/h2&gt;

&lt;p&gt;基本数据类型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;整型：对整数的处理&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;浮点型：对小数的处理&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;字符串型：单引号和双引号引起来的任意文本&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;布尔型：True和False两种值，也可通过计算得出&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;复数型：数学表示法&lt;code&gt;7i+8j&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;int()&lt;/code&gt;：将一个数值或字符串转换成整数，可以指定进制。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;float()&lt;/code&gt;：将一个字符串转换成浮点数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;str()&lt;/code&gt;：将指定的对象转换成字符串形式，可以指定编码。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;chr()&lt;/code&gt;：将整数转换成该编码对应的字符串（一个字符）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;ord()&lt;/code&gt;：将字符串（一个字符）转换成对应的编码（整数）。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;复杂数据类型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;列表：[ ]，可以存储任意类型，任意数量的变量&lt;/li&gt;
&lt;li&gt;集合：{ }，可以存储任意类型变量，定以后不能更改其元素&lt;/li&gt;
&lt;li&gt;字典：{}，以键值对形式存储数据元素&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;运算操作符&#34;&gt;运算操作符&lt;/h1&gt;

&lt;hr /&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;strong&gt;+&lt;/strong&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;&lt;strong&gt;和&lt;/strong&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;&lt;strong&gt;/&lt;/strong&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;&lt;strong&gt;除&lt;/strong&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;&lt;strong&gt;&amp;lt;&amp;lt;&lt;/strong&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;&lt;strong&gt;左移&lt;/strong&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;&lt;strong&gt;&amp;amp;&lt;/strong&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;&lt;strong&gt;按位与&lt;/strong&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;&lt;strong&gt;&amp;lt;=&lt;/strong&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;&lt;strong&gt;&amp;hellip;&lt;/strong&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;is/is not&lt;/th&gt;
&lt;th&gt;身份运算符&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;差&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;//&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;模&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;&amp;gt;&amp;gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;右移&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;|&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;按位或&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;&amp;gt;=&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;&amp;hellip;&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;in/not in&lt;/td&gt;
&lt;td&gt;成员运算符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;*****&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;积&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;%&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;整除&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;&amp;lt;&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;小于&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;^&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;按位异或&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;==&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;&amp;hellip;&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;not/and/or&lt;/td&gt;
&lt;td&gt;逻辑运算符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;******&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;幂运算&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;@&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;大于&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;~&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;按位取反&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;!=&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;&amp;hellip;&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;在实际开发中，运算会有不同的优先级，可以用括号保证运算的执行顺序。&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&#34;delimiters&#34;&gt;Delimiters&lt;/h1&gt;

&lt;hr /&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;(  )&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;,&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;:&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;- &amp;gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;*=&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;%=&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;|=&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;&amp;lt;&amp;lt;=&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;[  ]&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;+=&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/=&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;@=&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;^=&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;**=&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;{   }&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;@&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;=&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-=&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;//=&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&amp;amp;=&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&amp;gt;&amp;gt;=&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;分支结构&#34;&gt;分支结构&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;​   在Python中，构造分支结构使用if、else和elif关键字。与其他语言不同Python没有使用花括号构建代码块，而是使用其独特的缩进方式来设置代码的层次结构。连续的代码保持相同的缩进那么就属于同一个代码块。&lt;/p&gt;

&lt;p&gt;​   分支结构是可以嵌套使用的。&lt;/p&gt;

&lt;h1 id=&#34;list&#34;&gt;List&lt;/h1&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;list.append(x)
list.extend(iterable)
list.insert(i,x)
list.remove(x)
list.pop([i])
from collections import deque  :  deque([])   deque.popleft()
list.clear()   =  del list
list.index(x[,start[,end]])
list.count(x)
list.sort(key = None,reverse=False)
list.reverse()
list.copy() = a[:]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;tuples-sequences&#34;&gt;Tuples &amp;amp; Sequences&lt;/h1&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;1. enumerate(): 
   for i, v in enumerate([&#39;tic&#39;, &#39;tac&#39;, &#39;toe&#39;]):
	...     print(i, v)
	...
	0 tic
	1 tac
	2 toe
2. zip()  reversed()  sorted()
3. 
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;json&#34;&gt;JSON&lt;/h1&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;python 与 JSON对照：
dict              {}
list              []
str               &#39;string&#39;
int/float         1234.56
True/False        true/false
None              null
&amp;gt;import json
&amp;gt;json.dumps([1, &#39;simple&#39;, &#39;list&#39;])
&amp;gt;&#39;[1, &amp;quot;simple&amp;quot;, &amp;quot;list&amp;quot;]&#39;

pickle : Pickle Module
	    pickle.dump().
	    pickle.load()
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;函数-fun&#34;&gt;函数(FUN)&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/python/pythonFun.png&#34; alt=&#34;Python内置函数&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;位置参数：
		 根据参数位置匹配
默认参数：def fun(arg1,arg2,arg = &#39;xxx&#39;)
		 1.定义默认参数时，，默认参数必须指向不变对象
		 2.当函数有多个参数时，将变化大的参数放前面，变化小的放后面。变化小的可以作为默认参数。
	     3. 默认按参数位置匹配，可以通过名字进行相应的默认字段赋值
可变参数：def  fun（arg1,arg2,*numbers）
		 允许传入多个参数，在函数调用时自动组装成一个tuple
		 当参数为list或则tuple时，可以使用*list,*tuple
关键字参数：def fun(arg1,arg2,**kw)
		 允许传入多个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。
		 传入dict时，只是将所有的参数传入函数，对参数的改变不会影响到函数外的dict
命名关键字参数：def fun (arg1,arg2,*,arg3,arg4)
		 对于关键字参数，需要在函数内部进行检查,使用命名关键字必须传入参数名
参数组合：
		参数定义的顺序（必选参数，默认参数，可变参数，命名关键字，关键字参数）
对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;递归函数&#34;&gt;递归函数&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;注意栈溢出问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;尾递归是指&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。&lt;/p&gt;

&lt;h1 id=&#34;迭代器-iterable&#34;&gt;迭代器（Iterable）&lt;/h1&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;1. 原理：
	For调用了var = iter(str)，next(var),当next()没有元素时，raise a StopIteration
2. 集合数据类型：list、tuple、dict、set、str等
generator:sum(i*i for i in range(10))
包括生成器和带yield的generator function
		def reverse(data):
		    for index in range(len(data)-1, -1, -1):
		        yield data[index]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;模块-mod&#34;&gt;模块(Mod)&lt;/h1&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;导入整个模块：import modname.   from modname import *.
导入模块部分：from modname import name1[, name2[, ... nameN]].
OS Interface:
	os:getcwd()  chdir()  system() open()
	shutil:copyfile(&#39;source&#39;,&#39;aim&#39;)     move(&#39;source&#39;,&#39;aim&#39;)
File Wildcards: 
	glob:glob.glog(&#39;*.py&#39;)
Output Formatting:
	reprlib: reprlib.repr(set(&#39;adfasfsadfsfsfsfs&#39;))
	pprint: pprint.pprint((source,width = vaule))
	textwrap:格式化输出段落适应屏幕宽度  textwrap.fill(source,width=value)
	locale:culture specific data formats	
			x = 1234567.8
			locale.format_string(&amp;quot;%s%.*f&amp;quot;, (conv[&#39;currency_symbol&#39;],conv[&#39;frac_digits&#39;], x), grouping=True)
			&#39;$1,234,567.80&#39;
Command Line Arg:	
	sys: sys. args  sys.stdin sys.stdout, sys.stderr.write(&#39;Error msg&#39;) , sys.exit()
	getopt:
	argparse:
String Pattern Matching:
	re:re.fundall(), re.sub  etc.
Templating:
	string(Template):t = Template(&#39;${village}folk send $$10 to $cause.&#39;)
						 t.substitute(village=&#39;Nottingham&#39;, cause=&#39;the ditch fund&#39;)
						&amp;gt;&amp;gt;&amp;gt;&#39;Nottinghamfolk send $10 to the ditch fund.&#39;
Mathematics:
	math:math.cos(),math.log() etc.
	random:random.choice([]),random.sample(range(100),10) etc,
	statistics:(mean,median,variance)etc.
Internet Access:
	urllim.request(retrieving data from URLs):
	smtplib(sending mail): server = smtplib.SMTP(&#39;xxx&#39;)   server.sendmail(&#39;from_email&#39;,&#39;to_email&#39;)  server.quit()
Dates and Times:
	datetime(date) :  date.today()  
Data Compression: (zlib,gzip,bz2,lzma,zipfile,tarfile)
	zlib:zlib.compress(&#39;source&#39;)   zlib.decompress(&#39;zlib_source&#39;)
Quality Control:
	doctest: doctest.testmod()
	unittest: unittest.TestCase   assertRaises():   unittest.amin()
Multi-threading:;
	threading: threading.Thread
Logging: 
	logging: sys.stderr(file)   logging.debug()  logging.info()  logging.warning()  logging.error() logging.critical()
Weak References:
	wearkref: 
Tools For Lists:
	array: a = array(&#39;H&#39;,[1213,1414,4124])   sum(a)-只计算list中的内容，对a的操作只对list有效
	collections(deque):
	bisect:manipulation sorder lists  bisect.insort(aim,source)
	heapq:use for repeatedly access the smallest element do not run a full list sort(堆排序)
			heapify(list)   heappush(list,value)   [headppop(list) for i in range(x)]   
Decimal Floating Point Ath:(精准计算)
	decimal:  
		help for(1)	financial applications and other uses which require exact decimal representation,
				(2)	control over precision,
				(3)	control over rounding to meet legal or regulatory requirements,
				(4)	tracking of significant decimal places, or
				(5)	applications where the user expects the results to match calculations done by hand
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;包管理-pip&#34;&gt;包管理(pip)&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;Virtual environments:
1. Create
	On Windows, invoke the venv command as follows:
		python -m venv c:\path\to\myenv
		venv [-h] [--system-site-packages] [--symlinks | --copies] [--clear]
      			  [--upgrade] [--without-pip]
       			  ENV_DIR [ENV_DIR ...]
2. Activate
	安装名\Scripts\activate.bat
3. Managing Packages  pip(On Virtual)
	https://pypi.org/
	pip search xxxx.(查找)
	pip install xxxx.(安装)
	pip install xxxx=version.(安装指定版本)
	pip install --upgrade xxxx.(更新到最新版本)
	pip show xxxxx.(显示包有关信息)
	pip list:(将显示虚拟环境中安装的所有软件包)
	pip uninstall xxx,xxxx,xxxx.(卸载)
	pip freeze &amp;gt; requirements.txt.(以指定文件格式显示已安装软件包)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;异常-error&#34;&gt;异常(Error)&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/fIWzpEQ.png&#34; alt=&#34;异常1&#34; /&gt;
&lt;img src=&#34;https://i.imgur.com/4B9otUe.png&#34; alt=&#34;异常2&#34; /&gt;
&lt;img src=&#34;https://i.imgur.com/xCmfhsi.png&#34; alt=&#34;异常3&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;1. 捕捉异常：
	try:
	&amp;lt;语句&amp;gt;        #运行别的代码
	except &amp;lt;名字&amp;gt;：
	&amp;lt;语句&amp;gt;        #如果在try部份引发了&#39;name&#39;异常
	except &amp;lt;name1,name2&amp;gt;，&amp;lt;数据&amp;gt;:
	&amp;lt;语句&amp;gt;        #如果引发了&#39;name&#39;异常，获得附加的数据
	else:
	&amp;lt;语句&amp;gt;        #如果没有异常发生
2. 最终处理
	try:
	
	finaly:

	raise:
3. 自定义异常
	class Error(Exception):
	    &amp;quot;&amp;quot;&amp;quot;Base class for exceptions in this module.&amp;quot;&amp;quot;&amp;quot;
	    pass
	
	class InputError(Error):
	    &amp;quot;&amp;quot;&amp;quot;Exception raised for errors in the input.
	
	    Attributes:
	        expression -- input expression in which the error occurred
	        message -- explanation of the error
	    &amp;quot;&amp;quot;&amp;quot;
	
	    def __init__(self, expression, message):
	        self.expression = expression
	        self.message = message
	
	class TransitionError(Error):
	    &amp;quot;&amp;quot;&amp;quot;Raised when an operation attempts a state transition that&#39;s not
	    allowed.
	
	    Attributes:
	        previous -- state at beginning of transition
	        next -- attempted new state
	        message -- explanation of why the specific transition is not allowed
	    &amp;quot;&amp;quot;&amp;quot;
	
	    def __init__(self, previous, next, message):
	        self.previous = previous
	        self.next = next
	        self.message = message
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;面向对象-oo&#34;&gt;面向对象(OO)&lt;/h1&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;1. 定义
	类帮助信息：ClassName._doc_查看
	class_suite：有数据属性，类成员，方法组成
	self：代表类的实例，当前对象的地址，而非类，self.class则指向类

	class ClassName:
	   &amp;quot;&amp;quot;&amp;quot;所有员工的基类&amp;quot;&amp;quot;&amp;quot;  #类文档字符串
	   empCount = 0    #数据属性
	   def __init__(self, name, salary):   #该方法接收参数
	      self.name = name
	      self.salary = salary
	      Employee.empCount += 1
	   
	   def displayCount(self):
	     print &amp;quot;Total Employee %d&amp;quot; % Employee.empCount
	 
	   def displayEmployee(self):
	      print &amp;quot;Name : &amp;quot;, self.name,  &amp;quot;, Salary: &amp;quot;, self.salary

2. 添加，删除，修改，访问类的属性
	demo.attr = value1：添加属性
	demo.attr = value2：修改属性
	del demo.attr：删除属性
	getattr(obj,name[,default])：访问对象的属性
	hasattr(obj,name[,default])：检查是否存在一个属性
	setattr(obj,name[,default])：设置一个属性。如果不存在，会创建一个新属性
	delattr(obj,name)：删除属性
3. 内置属性类
	__dict__：类的属性（包含一个字典，由类的数据属性组成）
	__doc__：类的文档字符串
	__name__：类名
	_module_：类定义所在的模块
	_bases_：类的所有父类构成元素
	__del__：析构函数，在队象销毁时被调用
	__class__:是实例的类
4. 对象销毁（垃圾回收）
	采用引用计数来跟踪和回收垃圾
5. 封装
	如果类具有__setattr__()或 __delattr__()方法，则调用此方法而不是直接更新实例字典。
	__getattr__(self,attr1,attr2):
		setattr(self,attr1,attr2)   
	object.__getattriabute__()
	get(self,实例,所有者)    set()  delete()  set_name()
	
	slots():为此变量分配字符串，可迭代，阻止每个实例自动创建__dict__和__weakref__
	
6. 类的继承
	(1) 语法：class 派生类名(basic1,basic2)：...
	      调用：__init_subclass__
	(2)Python内置的@property装饰器就是负责把一个方法变成属性调用
	(3)mixln:主线都是单一继承下来的，例如，Ostrich继承自Bird。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让Ostrich除了继承自Bird外，再同时继承Runnable
7. 元类
	class OrderedClass(type):
	
	    @classmethod
	    def __prepare__(metacls, name, bases, **kwds):
	        return collections.OrderedDict()
	
	    def __new__(cls, name, bases, namespace, **kwds):
	        result = type.__new__(cls, name, bases, dict(namespace))
	        result.members = tuple(namespace)
	        return result
	
	class A(metaclass=OrderedClass):
	    def one(self): pass
	    def two(self): pass
	    def three(self): pass
	    def four(self): pass
	
	&amp;gt;&amp;gt;&amp;gt; A.members
	(&#39;__module__&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;four&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;正则表达式&#34;&gt;正则表达式&lt;/h1&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;1. 匹配
	 \d:匹配一个数字
	 \w:匹配一个字母或数字
	 \s:匹配一个空格（TAB）
	 .:可以匹配任何字符
	 *:表示任意个字符（包括0个）
	 +:表示至少一个字符
	 ?:表示0个或1个字符
	 {n}:表示n个字符
	 {n,m}:表示n-m个字符
	 A|B：可以匹配A或B
	 ^:表示行的开头，^\d表示必须以数字开头。
	 $表示行的结束，\d$表示必须以数字结束。
	 [0-9a-zA-Z\_]：可以匹配一个数字、字母或者下划线；
	 [0-9a-zA-Z\_]+：可以匹配至少由一个数字、字母或者下划线组成的字符串，比如&#39;a100&#39;，&#39;0_Z&#39;，&#39;Py3000&#39;等等；
	 [a-zA-Z\_][0-9a-zA-Z\_]*：可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量；
	 [a-zA-Z\_][0-9a-zA-Z\_]{0, 19}：更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）
2. match()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None
	print(re.match(r&#39;^\d{3}\-\d{3,8}$&#39;, &#39;010-12345&#39;))
	re.match(r&#39;^\d{3}\-\d{3,8}$&#39;,&#39;010 12345&#39;)
3. 切割 re.split()
	st = re.split(r&#39;[\s\,\;]+&#39;, &#39;a,;;b, c  d&#39;)
	print(st)
4. 分组 如果正则表达式中定义了组，就可以在Match对象上用group()方法提取出子串来 0:原始，1:第几个字串
	m = re.match(r&#39;^(\d{3})-(\d{3,8})$&#39;,&#39;010-12314&#39;)
	print(m)
	print(m.group(0))
	print(m.group(1))
	print(m.group(2))
5. 贪婪匹配:正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符.
	print(re.match(r&#39;^(\d+)(0*)$&#39;, &#39;102300&#39;).groups())
 	加个?就可以让\d+采用非贪婪匹配
	print(re.match(r&#39;^(\d+?)(0*)$&#39;, &#39;102300&#39;).groups())
 6. 编译：
 	编译正则表达式，如果正则表达式的字符串本身不合法，会报错；
 	用编译后的正则表达式去匹配字符串。
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title> WebDynpro </title>
      <link>https://coldinfire.github.io/2019/WebDynpro/</link>
      <pubDate>Wed, 16 Jan 2019 17:20:58 +0800</pubDate>
      
      <guid>https://coldinfire.github.io/2019/WebDynpro/</guid>
      <description>

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code&gt;Web Dynpro&lt;/code&gt; 在业务应用程序的主要结构和视觉设计部分的方式，在很大程度上是独立于实现语言.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一个Web Dynpro 组件不是一个JAVA类，而是一系列类集合所有功能一起作为一个单元。每个控制器是一个独立的JAVA类，相互之间是独立的。不可以重用一个组件中的单个控制器，可以选择一组件为单位使用，也可以选择不使用。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数据结构用于保存在运行时的业务数据&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;UI元素的定义和属性&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;UI元素的聚集成的观点&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;意见聚集到视图集和窗口&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在响应用户操作执行商业任务活动&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;视图窗口之间的导航链接&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;功能可重用单元称为组件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过Web服务，企业级Java Bean使用持久后端数据和功能或ABAP远程函数调用。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   &lt;strong&gt;数据绑定&lt;/strong&gt;（Data Binding）：自动将数据从Controller的上下文传递到另一个Controller上下文。&lt;/p&gt;

&lt;p&gt;​   &lt;strong&gt;映射&lt;/strong&gt;可以分为内部映射（同一组件内不同控制器间的映射）和外部映射（不同组件之间的控制器间的映射）；上下文节点为数据源时称为映射源节点，其他的成为映射节点。&lt;/p&gt;

&lt;p&gt;​   &lt;strong&gt;数据绑定&lt;/strong&gt;（Data Binding）：自动将数据从View Controller的上下文传递到其布局的元素。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/webdynpro/webDyn1.png&#34; alt=&#34;图1：Web Dynpro Explorer1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/webdynpro/webDyn2.png&#34; alt=&#34;图2：Web Dynpro Explorer2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/webdynpro/webDyn3.png&#34; alt=&#34;图3：Web Dynpro 组件架构&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/webdynpro/webDyn4.png&#34; alt=&#34;图4：Web Dynpro 元素绑定&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Web Dynpro Component：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在Web Dynpro组件的代码在业务流程级别的可重复使用单元，而不是技术编码的水平&lt;/li&gt;
&lt;li&gt;在代码重用的性质所产生的变化产生的编码过程中的注意开发商的重心转移。它们不再是担心这么多的技术编码单元的重用; 相反，一个Web Dynpro组件的设计侧重于业务处理的原子单位的重用。&lt;/li&gt;
&lt;li&gt;一个组件是WebDynpro的可执行编码时所需要的最小单位 。&lt;/li&gt;
&lt;li&gt;Web Dynpro Component的controller分为四类：

&lt;ul&gt;
&lt;li&gt;Component controller:这种类型的controller在一个Web Dynpro component中只有一个，并且没有visual interface&lt;/li&gt;
&lt;li&gt;Custom controller:方便了代码的整合优化，并且其生命周期可以修改，而在Component中不能修改,封装sub-function&lt;/li&gt;
&lt;li&gt;View controller:每个View有且只有一个controller和context，负责与视图有关的逻辑，如检查用户输入和处理user action&lt;/li&gt;
&lt;li&gt;Windows controller:有且只有一个，用于通过inbound plugs 传输数据&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;图像化开发工具，允许定义以下内容：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;前端和后端之间的数据流&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;用户界面的布局&lt;/li&gt;
&lt;li&gt;用户界面元素的属性&lt;/li&gt;
&lt;li&gt;从一个视图到另一个导航&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;mvc&#34;&gt;MVC&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;Model：模型对象封装的界面一些后端系统。它的目的是充当分离从数据和功能在远程系统中找到的网页Dynpro应用程序的代理。封装访问业务数据和功能，驻留在远程后端系统。换句话说，在Web Dynpro应用程序不必与后端系统交互所需的特定通信技术。模型将接口封装到位于后端系统中的业务流程的某个步骤。这可以是BAPI调用，也可以是Web服务调用或Enterprise Java Bean。模型始终被视为数据生成器。接收一些数据也是为了完成业务流程的下一步。model会返回一些指示成功或失败的数据。&lt;/li&gt;
&lt;li&gt;View：视图用于定义业务数据的客户机中性可视化。&lt;/li&gt;
&lt;li&gt;Controller：在原来的MVC范例，控制器负责管理的视图（一个或多个）和模型（一个或多个）的相互作用，格式化将被显示在视图中的模型数据，并计算该视图（or views）中接下来的显示。所有的View中的Controller可以和Component Controller进行数据映射，从而达到View之间共享传递数据的功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/webdynpro/webDyn5.png&#34; alt=&#34;图5：MVC&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;无视图的-web-dynpro&#34;&gt;无视图的 Web Dynpro&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;Controllers having no visual interface：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/webdynpro/webDyn6.png&#34; alt=&#34;图6：Web Dynpro no visual interface&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/webdynpro/webDyn7.png&#34; alt=&#34;图7：Dynpro no visual interface&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;有视图的-web-dynpro&#34;&gt;有视图的 Web Dynpro&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;视图控制器&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;视图控制器是不负责业务数据的产生，视图控制器一直被认为是数据的消费者。&lt;/li&gt;
&lt;li&gt;视图控制器从model获得数据，通过加工后将数据放置到上下文，视图可以通过上下文获取信息。&lt;/li&gt;
&lt;li&gt;视图控制器可以访问由一个称为“上下文映射”技术来在组件控制器的上下文中保存的信息。&lt;/li&gt;
&lt;li&gt;视图控制器可以被认为是UI元素的集合，并且与那些UI元素相关联是执行各种数据呈现任务所必需的编码。&lt;/li&gt;
&lt;li&gt;数据绑定将视图控制器中的编码与实际UI元素对象分离。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;窗口控制器&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;​   与视图控制器处理UI元素聚合的处理的方式相同，因此窗口控制器处理视图聚合的处理。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;接口控制器&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;接口控制器是定义组件的编程接口的地方。 就像常规Java接口一样，您可以在接口控制器中定义方法，然后由组件控制器实现。&lt;/li&gt;
&lt;li&gt;除了能够在接口控制器中定义方法之外，您还可以定义事件和数据结构（这些数据结构的正确Web Dynpro术语是上下文节点）。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;组件控制器&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;组件控制器总是充当组件内的视图控制器数据（或数据生成器）的供应商; 因此，我们知道，组件控制器是存储这些信息的正确位置。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​    除了能够在 Interface Controller 中定义方法之外，还可以定义事件和数据结构（这些数据结构的正确 Web Dynpro 术语是上下文节点）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/webdynpro/webDyn8.png&#34; alt=&#34;图8：Web Dynpro having visual interface&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/webdynpro/webDyn9.png&#34; alt=&#34;图9：Web Dynpro having visual interface&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;​   (1)上下文中保存的数据仅存在于控制器的生命周期中。 控制器实例终止后，其上下文中保存的所有数据都将丢失。&lt;/p&gt;

&lt;p&gt;​   (2) 控制器通常不能够访问彼此的数据或功能。&lt;/p&gt;

&lt;p&gt;​   (3) 通过称为上下文映射的技术，可以使另一个控制器（视图或自定义）的上下文可以访问在自定义控制器的上下文中保存的信息。
使用此技术，两个或多个控制器可以访问相同的运行时数据。&lt;/p&gt;

&lt;p&gt;​   (4) 上下文映射是在单个组件内的控制器之间共享数据的主要机制。&lt;/p&gt;

&lt;p&gt;​   (5) 视图控制器不允许共享其上下文数据。不负责生成显示的数据，不应该在上下文映射关系中充当数据源。&lt;/p&gt;

&lt;p&gt;​   (6) 参数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;映射：通过引用不同控制器中的相应节点来获取节点的结构。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;模型绑定：节点的结构将从先前创建的模型对象中获取&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;结构绑定：节点的结构将从Java Dictionary中先前创建的结构中获得&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;手动：节点的结构将通过手动定义创建&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   (7)创建VIEW的CONTEXT，CONTEXT须和VIEWS上的某些控件的特定属性绑定，这样当我们改变了CONTEXT的某个节点的数据，那么相应控件的值也会跟着改变。
​   建立CONPONENT CONTROLLER中的CONTEXT节点并且和VIEW CONTEXT相应节点映射，这样就相当于把全局变量和局部变量相关联。&lt;/p&gt;

&lt;p&gt;​   (8) context是一个包含node和attribute的结构。每一个context都有一个默认的root node，一个node连同其子元素被合称为一个element。&lt;/p&gt;

&lt;h2 id=&#34;构建上下文&#34;&gt;构建上下文&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;​   (1) 节点基数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;0&amp;hellip;&amp;hellip;1：零个或一个元件允许&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;0&amp;hellip;&amp;hellip;N：零个或更多个元件允许&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;1&amp;hellip;&amp;hellip;1：一个且只允许一个元件允许&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;1&amp;hellip;&amp;hellip;N：一个或多个元件允许&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   &amp;lt; 对于那些它们的基数最低设置为1的节点，那么节点集合将被实例化，使得它已经包含了一个单一的空元素。这个元素被称为默认元素。&lt;/p&gt;

&lt;p&gt;​   &amp;lt; 具有其基数的最低设置为0，则该节点将一个空的集合实例化。Web Dynpro开发人员必须先编写代码来创建，然后插入第一个元素到集合。&lt;/p&gt;

&lt;p&gt;​   &amp;lt; 现在将Collection Cardinality值从默认的0..n更改为1..1。 这告诉Web Dynpro Framework在运行时，此上下文节点将包含一个且仅包含一个元素。 这就像说数据库表只能包含一行。&lt;/p&gt;

&lt;p&gt;​   &amp;lt; 编辑器窗口左侧的“创建数据链接”工具，然后将一行从FirstView拖到组件控制器。此操作的目的是声明视图控制器将从组件控制器充当数据使用者。&lt;/p&gt;

&lt;p&gt;​   &amp;lt; 从视图控制器指向组件控制器 - 从不相反。 这表示视图控制器充当数据消费者，组件控制器充当数据生成器.&lt;/p&gt;

&lt;p&gt;(2) singleton 属性&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;true|false：默认为true，不管有多少个元素存在于节点的父集合中; 只会永远是子节点LineItem的一个实例。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(3) 上下文映射机制&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;建立映射关系，以下两个条件必须满足：

&lt;ul&gt;
&lt;li&gt;必须有可以充当映射原点合适的节点&lt;/li&gt;
&lt;li&gt;上下文节点必须存在于使用控制器&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   &amp;lt; 所有的上下文节点是包含，除其他事项外，收集运行时对象。当的映射关系被声明，映射的节点的节点集合由在映射起源节点的参考节点集合代替。以这种方式，上下文映射永远不会导致数据被复制。只有一个数据副本，它的生命属于映射源节点的收藏&lt;/p&gt;

&lt;h2 id=&#34;ui-element&#34;&gt;UI Element&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;​   (1) 所有的UI元素有一个属性集，其中有许多可以接受硬编码值。然而，当在屏幕上要显示的数据在视图控制器的上下文中被保持，&lt;/p&gt;

&lt;p&gt;​   (2) 简单的声明性关系可以适当UI元素属性和保持所需要的数据视图控制器的上下文中的属性之间进行。&lt;/p&gt;

&lt;p&gt;​   (3) 这是被称为数据绑定关系，并且是用于呈现数据给用户的标准机制。&lt;/p&gt;

&lt;p&gt;​   (4) 在Web Dynpro开发人员只需要编写代码用于填充上下文属性。一旦数据是存在于该上下文中，Web Dynpro框架确保UI元素&lt;/p&gt;

&lt;p&gt;​   (5) 属性的值是从相关联的上下文属性获得。因此，一个Web Dynpro程序通常可以写一个不包含涉及渲染UI的任何代码！&lt;/p&gt;

&lt;p&gt;​   (6) UI元素对象仅仅是用于呈现在上下文中找到的数据的工具&lt;/p&gt;

&lt;p&gt;​   (7) UI元素是否运行在Web Dynpro框架，实际上具体决定需要编码来呈现在屏幕上。&lt;/p&gt;

&lt;p&gt;​   (8) 每个视图控制器中创建UI元素时，这些UI元素只能从视图控制器的上下文中获取它们的信息。&lt;/p&gt;

&lt;p&gt;​   (9) 使用模板向导使用上下文中找到属性添加表单。选择上下文属性后，不要在模板向导中单击“完成”，而是单击“下一步”，然后将用于显示数据的UI元素类型从InputField更改为TextView。现在，屏幕上的字段将是只读的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建一个Action对象，并为其指定文本值“Back”。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建Button UI元素，通过更改layoutData将其放置在新行的开头。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   (10) 按钮的功能回应&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/webdynpro/webDyn12.png&#34; alt=&#34;图10：事件绑定和响应&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;windows&#34;&gt;Windows&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;​   (1) 窗口定义了两件事：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可以为组件的一个特定可视界面显示的所有可能视图的超集&lt;/li&gt;
&lt;li&gt;这些视图之间存在的导航路径&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   (2) 视图一旦被创建，直到它第一次被嵌入到一个窗口它不会是前端装置上可见的。一旦一个视图被声明为任何特定的窗口中的一员，它可以在前端客户端设备上是否可见。&lt;/p&gt;

&lt;p&gt;​   (3) &lt;strong&gt;UI元素ViewContainer：&lt;/strong&gt;此UI元素，当添加到视图的布局，作为用于任何其它视图的容器。ViewContainers可以实现在屏幕上所需的布局被布置在大量的各种方式。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可嵌入到一个ViewContainer UI元素的条件:

&lt;ul&gt;
&lt;li&gt;当前组件的任何视图&lt;/li&gt;
&lt;li&gt;子Web Dynpro组件的任何可视化界面&lt;/li&gt;
&lt;li&gt;空视图（由Web Dynpro运行时自动地供给）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   (4) 持久数据应该总是被存储在组件控制器，或者是定制控制器，因为这种控制器持续整个组件的寿命。视图控制器的数据在器不是当前视图组件的一部分就会将其数据丢弃掉。&lt;/p&gt;

&lt;p&gt;​   (5) 简单窗口中，任何时候都只能看到其中一个视图。&lt;/p&gt;

&lt;h2 id=&#34;插件和导航链接&#34;&gt;插件和导航链接&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;​   &lt;strong&gt;在每个视图中定义导航插头，并将它们与一个导航链路链接在一起。导航插头有两种：入站和出站&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   &lt;strong&gt;(1) 出站：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   触发出站插件时，会向Web Dynpro框架发送“导航请求”消息。
​   Web Dynpro框架接受此请求并将其放在堆栈中，该堆栈仅在当前视图程序集中的所有视图都响应用户事件后才会被处理&lt;/p&gt;

&lt;p&gt;​   &lt;strong&gt;(2) 入站：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   入站插件是目标视图中的一种方法，它能够响应出站插件的“导航请求”。 一旦当前视图程序集中的所有视图都完成了处理，Web Dynpro Framework就会将注意力转移到导航堆栈上的请求。为了成功处理每个“导航请求”，必须已经在出站插件和入站插件之间声明了关联。 此关联称为导航链接。&lt;/p&gt;

&lt;p&gt;​   &lt;strong&gt;(3) 导航链接：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   是一个视图向另一个，每个出站插头都必须在目标目标视图的入站插头相关联。这种关联是已知的，并且能够仅在设计时定义。通过声明导航链接，您可以在窗口中的两个视图之间创建固定关联。 一旦您触发出站插件，“导航请求”将无条件地放置在导航堆栈上。在这个时间点之后，关于导航处理的唯一选项是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;处理导航堆栈中的所有请求&lt;/li&gt;
&lt;li&gt;中止整个导航堆栈的处理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   一旦将导航请求添加到导航堆栈，就不可能有选择地处理导航请求。 您要么处理整个堆栈，要么完全中止导航处理。因此，在编写导航编码时，在决定触发出站插件之前应该小心。&lt;/p&gt;

&lt;p&gt;​   &lt;strong&gt;(4) 创建&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   “创建链接”工具。单击此工具，然后首先从FirstView拖动一行到SecondView。这将为您创造三件事：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;FirstView中的出站导航插件&lt;/li&gt;
&lt;li&gt;SecondView中的入站导航插件&lt;/li&gt;
&lt;li&gt;从FirstView的出站插件开始并在SecondView的入站插件处完成的导航链接&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   &lt;strong&gt;(5) 按Ctrl-Shift-S保存所有更改&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   &lt;strong&gt;(6) 编码&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;​ 告诉Web Dynpro，当在FirstView中调用动作处理程序方法以响应客户端中的按钮时， 我们需要触发出站导航插头。这是我们需要在FirstView的动作处理程序方法中编写单行代码的地方。&lt;/li&gt;
&lt;li&gt;两个特殊注释标记：// @@ begin和// @@ end。 您只能在这些注释标记之间放置编码。&lt;/li&gt;
&lt;li&gt;(wdThis.wd&amp;hellip;)Ctrl-Space，代码完成弹出窗口&lt;/li&gt;
&lt;li&gt;当我们创建导航链接时，“创建导航链接”工具会自动为我们创建出站和入站插件。默认情况下，这些插件将被称为“Out”和“In”。通常，只要创建了任何出站插件，NWDS就会自动为您生成一个名为wdFirePlug $ {pout}（）的方法，其中$ {pout}是出站插件的名称。
要使导航发生所需要做的就是调用此方法，Web Dynpro Framework将为您处理剩下的工作。在这里，我们需要编写将调用出站导航插件的代码行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   &lt;strong&gt;(7) 交互&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用户单击按钮UI元素&lt;/li&gt;
&lt;li&gt;按钮UI元素引发一个名为onAction的客户端事件&lt;/li&gt;
&lt;li&gt;客户端事件导致往返服务器&lt;/li&gt;
&lt;li&gt;onAction事件已与名为DataEntered的运行时操作相关联，这又导致视图控制器中的onActionDataEntered（）方法被调用&lt;/li&gt;
&lt;li&gt;onActionDataEntered（）方法包含一行代码，用于触发出站导航插件&lt;/li&gt;
&lt;li&gt;Web Dynpro Framework然后处理删除FirstView所需的所有处理从屏幕上用SecondView替换它。**&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;用户访问&#34;&gt;用户访问&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;lt; 我们需要一些允许用户访问此组件功能的方法。&lt;/p&gt;

&lt;p&gt;&amp;lt; 这是通过创建一个名为Application的东西来实现的。&lt;/p&gt;

&lt;p&gt;&amp;lt; 应用程序只是URL与Web Dynpro组件的可视界面的关联。&lt;/p&gt;

&lt;p&gt;&amp;lt; 一旦创建了应用程序，您就已经创建了一种方法，来自客户端设备（例如浏览器）的用户可以通过该方式调用某些Web Dynpro功能。&lt;/p&gt;

&lt;p&gt;&amp;lt; 右键单击刚刚创建的应用程序的名称，然后从菜单中选择“Deploy new Archive and Run”。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;显示数据&#34;&gt;显示数据&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;​   (1) 表格显示的数据是从已知的作为上下文视图控制器的数据存储区域获得的。视图控制器反过来，从组件控制器的上下文获取数据。&lt;/p&gt;

&lt;p&gt;​   (2) 填充组件控制器需要写入代码控制（Context mapping relationship&amp;lt;上下文映射关系&amp;gt;, Data Binding relationship&amp;lt;视图控制器与显示界面进行绑定&amp;gt;）&lt;/p&gt;

&lt;p&gt;​   (3) 数据提供给UI元素：web Dynpro有用于控制UI元素的弯管和行为的一个更简单，更优雅的机制=》UI元件结合。&lt;/p&gt;

&lt;p&gt;​   (4) UI元素绑定：几乎所有UI元素属性可以是“绑定”到在视图控制器的上下文适当的属性。&lt;/p&gt;

&lt;p&gt;​   (5) 用户界面的行为可以控制如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在设计时，创建适当的数据类型的上下文属性持有UI元素的属性值。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;声明在视图布局UI元素和结合要控制到上下文属性在步骤1中声明的属性。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;现在，在视图控制器的编码不需要精确关心正在使用的用户界面元素。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所有这是需要关注的，设置适当的值到右键属性，UI元素属性将自动接收值。&lt;/p&gt;

&lt;p&gt;​   (6)设计优势：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通常，需要以控制它们的外观和/或行为的UI元素对象没有直接访问。&lt;/li&gt;
&lt;li&gt;在Web Dynpro开发人员需要以控制用户界面的行为写显著更少的代码。&lt;/li&gt;
&lt;li&gt;编码仍然不可知的客户端。无需更改应用程序代码，以考虑不同客户端设备中的技术差异。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://coldinfire.github.io/images/webdynpro/webDyn11.png&#34; alt=&#34;图11：UI元素&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;others&#34;&gt;Others&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;​   (1)可以使用提供的工具生成大部分Web Dynpro应用程序，而无需创建自己的源代码。这适用于本申请的以下部分：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;前端和后端之间的数据流&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用户界面的布局&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用户界面元素的属性&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Web Dynpro工具使您可以在生成的源文本中手动创建源文本区域。如果重新生成源代码，则不会更改这些区域。&lt;/p&gt;

&lt;p&gt;​   &lt;strong&gt;(2)业务分离与应用逻辑:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   使用Web Dynpro可以清晰地分离业务逻辑和显示逻辑。 Web Dynpro应用程序在前端运行，并通过服务对后端系统进行本地或远程访问。这意味着显示逻辑包含在Web Dynpro应用程序中，而业务逻辑和业务对象的持久性在后端系统中运行。以下选项目前可用于连接Web Dynpro应用程序和后端系统：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用自适应RFC生成的接口，用于调用SAP系统的BAPI&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;调用企业服务模式&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;调用使用SOAP协议的Web服务&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一个调用的Enterprise Java Bean  通过远程方法调用（RMI）协议&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一个自生成的界面&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;连接Web Dynpro应用程序所需的源代码可以从Web Dynpro接口的UML定义生成。可以将UML定义作为XML文件导入Web Dynpro工具。&lt;/p&gt;

&lt;p&gt;​   (3)&lt;strong&gt;模型 - 视图 - 控制器编程模型的转换：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​       每个Web Dynpro应用程序都是根据Model View Controller编程模型构建的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;该模型构成了后端系统的接口，从而使Web Dynpro应用程序能够访问数据。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;该视图负责在浏览器中表示数据。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;控制器位于视图和模型之间。控制器格式化要在视图中显示的模型数据，处理用户创建的用户条目，并将它们返回到模型。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   所有四种Web Dynpro控制器类型（组件，自定义，窗口和视图控制器）的类和接口参考基于以下结构：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;所有控制器类或控制器接口通用的所有冗余部件都记录在两个单独的部分中。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;公共控制器参考的控制器特定添加内容记录在附加部分中。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;控制器类和控制器接口分开描述。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   Common Controller Class Reference包含所有Web Dynpro控制器类共有的部分。&lt;/p&gt;

&lt;p&gt;​   附加部件（取决于特定的控制器类型）记录在四个Web Dynpro控制器类型组件，自定义，窗口和视图控制器的单独部分中。&lt;/p&gt;

&lt;p&gt;​   (4)&lt;strong&gt;预定义的钩子方法：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;public void wdDoExit（）在销毁控制器实例以进行清理之前，由Web Dynpro Runtime调用。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;public void wdDoInit（）由Web Dynpro Runtime调用以初始化控制器实例&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   &amp;lt; 基于声明的其他公共方法:&lt;/p&gt;

&lt;p&gt;​       &lt;code&gt;public &amp;lt;type&amp;gt; &amp;lt;method name&amp;gt;（[parameter {“，”parameter}]）[throws {checked exception class type}]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​   具有任意签名的控制器方法（参数和返回类型）。可以为应用程序开发人员声明的所有控制器方法定义已检查或编译器强制执行的异常。在Web Dynpro Tools中，已检查的异常被添加到方法定义中，类似于添加方法参数。调用公共控制器方法必须通过在自己的方法定义中捕获或添加它们来处理这些异常（在其throws子句中声明它们）在View Controllers中，基于声明的其他方法的类型为public。然而，它们无法从其他控制器调用，因为视图控制器不公开IPublic -API。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;public void &amp;lt;事件处理程序名称&amp;gt;（IWDCustomEvent wdEvent，[“，”parameter {“，”parameter}]）&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​   事件处理程序方法。参数必须与所描述事件的参数兼容。事件处理程序的名称应以前缀on开头。&lt;/p&gt;

&lt;p&gt;​   &amp;lt; 其他私人方法:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;private &amp;lt;type&amp;gt; &amp;lt;method name&amp;gt;([parameter {“，”parameter}])&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​   可以在最终用户编码区域中添加其他私有方法：// @@ begin others - // @@ end code。这些方法不会添加到控制器的IPublic -API中，因此即使使用公共可见性语句指定它们，它们也不会向其他控制器公开。&lt;/p&gt;

&lt;p&gt;​   &lt;strong&gt;(5) 成员变量&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;预定义的快捷方式变量，&lt;/p&gt;

&lt;p&gt;​       &lt;code&gt;private final IPrivate &amp;lt;controller nam&amp;gt; wdThis&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​       &lt;code&gt;private final IPrivate &amp;lt;controller name&amp;gt; .IContextNode wdContext&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​   引用控制器上下文中的根节点。不仅提供对根节点元素的类型访问，还提供对上下文中所有节点（&lt;code&gt;method note&amp;lt;node name&amp;gt;（）&lt;/code&gt;）及其当前所选元素（&lt;code&gt;method current &amp;lt;node name&amp;gt; Element（）&lt;/code&gt;）的类型访问。它还有助于为所有节点创建新元素（&lt;code&gt;method create &amp;lt;node name&amp;gt; Element（）&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;​   引用内部控制器类生成的IPrivate接口&lt;/p&gt;

&lt;p&gt;​   &lt;code&gt;private final com.sap.tc.webdynpro.progmodel.api.IWDComponent wdComponentAPI wdThis.wdGetAPI（）&lt;/code&gt;getComponent（）的快捷方式。&lt;/p&gt;

&lt;p&gt;​   表示此控制器所属的Web Dynpro组件的通用API。可用于访问与IWDComponent -API关联的其他Web Dynpro Runtime API，如消息管理器，窗口管理器或动态添加/删除事件处理程序。&lt;/p&gt;

&lt;p&gt;​   &lt;code&gt;private final &amp;lt;generic controller API&amp;gt; wdControllerAPI&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​   wdThis.wdGetAPI（）的快捷方式。表示此控制器的通用Web Dynpro对应的通用控制器API（IWDController，IWDComponent，IWDViewController和IWDWindowController）。&lt;/p&gt;

&lt;p&gt;​   &lt;strong&gt;(6)预定义变量:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;记录器记录位置&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;serialVersionUID此变量与应用程序代码开发无关。 SAP NetWeaver序列化框架需要检查序列化对象的二进制兼容性。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;私人会员变量&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;private &lt;type&gt; &lt;variable name&gt;可以在最终用户编码区域中添加任意数量的私有成员变量：// @@ begin others - // @@ end code&lt;/li&gt;
&lt;li&gt;对于此上下文节点，生成两个接口IContextNode和IContextElement，以允许在应用程序代码中进行上下文编程和动态上下文修改（添加属性或内部节点）。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title> Pycharm </title>
      <link>https://coldinfire.github.io/2019/Pycharm/</link>
      <pubDate>Thu, 03 Jan 2019 17:20:58 +0800</pubDate>
      
      <guid>https://coldinfire.github.io/2019/Pycharm/</guid>
      <description>

&lt;h1 id=&#34;paycharm&#34;&gt;Paycharm&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;常用快捷键&#34;&gt;常用快捷键&lt;/h2&gt;

&lt;p&gt;1、Ctrl + Enter：在下方新建行但不移动光标&lt;/p&gt;

&lt;p&gt;2、Shift + Enter：在下方新建行并移到新行行首&lt;/p&gt;

&lt;p&gt;3、Ctrl + /：注释(取消注释)选择的行&lt;/p&gt;

&lt;p&gt;4、Ctrl + Alt + L：格式化代码(与QQ锁定热键冲突，关闭QQ的热键)&lt;/p&gt;

&lt;p&gt;5、Ctrl + Shift + +：展开所有的代码块&lt;/p&gt;

&lt;p&gt;6、Ctrl + Shift + -：收缩所有的代码块&lt;/p&gt;

&lt;p&gt;7、Ctrl + Alt + I：自动缩进行&lt;/p&gt;

&lt;p&gt;8、Alt + Enter：优化代码，添加包&lt;/p&gt;

&lt;p&gt;9、Ctrl + Shift + F：高级查找&lt;/p&gt;

&lt;p&gt;10、Alt + Shift + Q：更新代码到远程服务器&lt;/p&gt;

&lt;p&gt;11、Alt + Insert：创建万物&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>报表开发(四)</title>
      <link>https://coldinfire.github.io/2018/ABAPTable4/</link>
      <pubDate>Wed, 19 Sep 2018 17:20:58 +0800</pubDate>
      
      <guid>https://coldinfire.github.io/2018/ABAPTable4/</guid>
      <description>

&lt;h2 id=&#34;执行程序的使用范围-报表事件&#34;&gt;执行程序的使用范围，报表事件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;LOAD-OF-PROGRAM.
INITIALIZATION.          （Before display the selection screen）
  AT-SELECTION SCREEN ON fiedl.（在PAI事件结束后执行，进行校验和检查输入值）
  AT SELECTION-SCREEN ON VALUE-REQUEST FOR Z_XXX.
AT SELECTION-SCREEN. //After enter the option data check
   PERFORM check_input.
START-OF-SELECTION.//Begin the main programer
  xxxx
END-OF-SELECTION.
Interactive Eventrs. (User for interactive reporting)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;报表程序大体逻辑结构&#34;&gt;报表程序大体逻辑结构&lt;/h2&gt;

&lt;p&gt;​   &lt;strong&gt;抬  头:&lt;/strong&gt; 报表的主要信息(抬头信息)&lt;/p&gt;

&lt;p&gt;​   &lt;strong&gt;行项目:&lt;/strong&gt; 查询出的每行记录信息&lt;/p&gt;

&lt;p&gt;​   &lt;strong&gt;明  细:&lt;/strong&gt; 每个行项目出关键字外其他明细内容&lt;/p&gt;

&lt;h2 id=&#34;字段符号&#34;&gt;字段符号&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt; FIELD-SYMBOLS &lt;FS&gt; LIKE structure.&lt;/p&gt;

&lt;p&gt;​    &lt;1&gt; FS必须和某个变量，结构或者内表绑定后才能使用，这点和C语言里的指针
​     （在ABAP里最接近指针的是TYPE REF TO）不同，在使用FS前必须分配给某个变量，不然会发生
​      FS未分配的运行时错误。如果LOOP内表时ASSIGNING到FS，之后假如有REFRESH内表的操作的话，
​      FS也会再次回到初始未被ASSIGN的状态，这时如果使用FS也会发生FS未分配的RUNTIME ERROR。
​    &lt;2&gt; ASSIGN structure TO &lt;fs&gt;:将某个内存区域分配给字段符号，这样字段符号就代表了该内存
​      区域，即该内存区域别名字段符号可以看作仅是已经被解引用的指针，即某个变量的别名。
  ASSIGN &lt;Val&gt; TO &lt;fs&gt;: 将某个内存区域分配给字段符号，这样字段符号就代表了该内存区域。
  UNASSIGN: 该语句是初始化&lt;FS&gt;字段符号，执行后字段符号将不再引用内存区域，
​            &lt;fs&gt; is assigned返回假。
  CLEAR: 与UNASSIGN不同的是，只有一个作用就是初始化它所指向的内存区域，而不是解除分配。
3.2 LOOP内表INTO结构（工作区）和LOOP内表ASSIGNING&amp;lt;结构&amp;gt;的比较
​    LOOP内表INTO结构时，系统会把先把当前行的数据复制到结构，如果结构的值改了，还需要使用
  MODIFY语句把更改后的值传回内表。也就是说，结构是内表里的数据的一个副本，操作这个副本不会
  影响内表里的数据。为了提高效率，可以使用FS，FS直接指向内表数据，省去了复制数据到结构的过程
  修改FS的值也就是相当于直接修改内表里的数据，不需要再使用MODIFY语句。
3.3 READ TABLE内表
3.4 ASSIGN隐式强转
TYPES: BEGIN OF t_date,
​    year(4) TYPE  n,
​        month(2) TYPE n,
​    day(2) TYPE n,
  END OF t_date.
FIELD-SYMBOLS &lt;fs&gt; TYPE t_date.&amp;ldquo;将&lt;fs&gt;定义成了具体限定类型
ASSIGN sy-datum TO &lt;fs&gt; CASTING. &amp;ldquo;后面没有指定具体类型，所以使用定义时的类型进行隐式转换
3.5 ASSIGN显示强转
  DATA txt(8) TYPE c VALUE &amp;lsquo;19980606&amp;rsquo;.
  FIELD-SYMBOLS &lt;fs&gt;.
  ASSIGN txt TO &lt;fs&gt; CASTING TYPE d.&amp;ldquo;由于定义时未指定具体的类型，所以这里需要显示强转
3.6 动态引用，通过循环赋值给定义的字段符号，对其进行修改，等于直接修改原内表。
  field-symbols:&lt;l_shortageqty&gt; type mng01.
  loop at &lt;dyn_table&gt; assigning &lt;dyn_wa&gt;.
​    assign component &amp;lsquo;SHORTAGEQTY&amp;rsquo; of structure &lt;dyn_wa&gt; to &lt;l_shortageqty&gt;.
​    &lt;l_shortageqty&gt; = &lt;l_shortageqty&gt; - &lt;l_fvalue&gt;.&lt;/p&gt;

&lt;h2 id=&#34;选择屏幕&#34;&gt;选择屏幕&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/foxting/archive/2012/07/01/2572243.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;引用链接&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;1&amp;gt;SELECT-SCREEN 框架结构
  SELECT-SCREEN语句用于创建屏幕的框架结构,主要包括屏幕元素的创建、子屏幕的创建等。
  定义屏幕对象：
    SELECTION-SCREEN BEGIN OF SCREEN src.
      .......
    SELECTION-SCREEN END OF SCREEN src.
    该语法用于定义一个INCLUDE SUREEN，可通过CALL方法在Report程序中引用。
   CALL SCREEN &amp;lt;num&amp;gt; STARTING AT [1 2] ENDING AT [1 2].
   参数可以将所定义屏幕窗体作为一个新的对话框窗体来引用，并指定期创建的具体大小及位置。
  注意：当从一个主屏幕中来调用其程序中的另一窗体时，必须使用CALL SELECTION-SCREEN方法.
  定义屏幕块：
    SELECTION-SCREEN BEGIN OF BLOCK block.
      ......
    SELECTION-SCREEN END OF BLOCK.
    该语法在屏幕中定义一个BLOCK，其扩展语法包括：
      ...WITH FRAME：创建一个框架
      ...TITLE title：创建一个带标题的框架。
      ...NO INTERVALS：所创建的框架中限制SELECT只有一个输入项。 
 其他元素：
  SELECTION-SCREEN INCLUDE BLOCKS &amp;lt;block1&amp;gt;.  调用已存在屏幕元素
  SELECTION-SCREEN ULINE.  划出横线，必须用在BLOCK中才能生效。
  SELECTION-SCREEN SKIP &amp;lt;n&amp;gt;.  在BLOCK中产生换行&amp;lt;n&amp;gt;。
  SELECTION-SCREEN POSITION &amp;lt;pos&amp;gt;. 在BLOCK中产生空格。
  SELECTION-SCREEN BEGIN OF LINE.
    ......
  SELECTION-SCREEN END OF LINE. 将所生成的屏幕元素控制在一行.
&amp;lt;2&amp;gt;PARAMETERS 单值输入
  PARAMETERS 参照数据字典具体字段或者自定义数据类型创建单值文本输入域以及单选/复选框等：
  PARAMETERS: &amp;lt;P_1&amp;gt; LIKE &amp;lt;field&amp;gt;    &amp;quot;文本域
            TYPE AS CHECKBOX.       &amp;quot;复选框
            RADIOBUTTON GROUP GRP1, &amp;quot;单选域 
            P2 RADIOBUTTON GROUP GRP1 DEFAULT &#39;X&#39;,  &amp;quot;默认选中 ”X“
            P3 RADIOBUTTON GROUP GRP1. &amp;quot;GRP1单选组
  默认值：
    ...DEFAULT f:定义默认值。
    ...TYPE type:参照某一类型对象定义PARAMETERS。
    ...DECIMALS dec：定义小数位，对输入参数自动格式化，该语法只对P类型有效(参数某一类型定义关键字TYPE)。 
    ...LIKE g：參照某一字典对象定义PARAMETERS。
    ...MEMORY ID pi：将PARAMETERS存储在SAP内存，参数名长度不能超过三位。
    ...NO-DISPLAY：将PARAMETERS设置为隐藏，不会的屏幕上输出。
    ...LOWER CASE：输入值中不允许输入小写字符，否则会自动转换为大写。
    ...OBLIGATORY：限制该PARAMETERS为必填，否则会提示输入。
    ...AS CHECKBOX：创建CHECKBOX对象。
    ...RADIO BUTTON GROUP radi：创建（RADIO）单选框。
    ...VISIBLE LENGTH vlen：定义显示长度。
    ...USER-COMMAND ucom：为创建对象分配对象名，该值保存在内表中可供其它对象操作。
    ...AS LISTBOX VISIBLE LENGTH vlen：创建一个下拉框，并指定长度。
 下拉框实现：
  *定义一个下拉框对象，其可视数据长度一般比输出数据长度大2用于放置下拉图标
    PARAMETERS:P_LANG(20) AS LISTBOX VISIBLE LENGTH 22.
  *该变量用于记录下拉列表数值是否初始化，否则每次屏幕初始化都会重新加载重复数据
    DATA:INIT.
    AT SELECTION-SCREEN OUTPUT.
    PERFORM SETLIST.
  *子程序用于加载下拉框的数据
    FORM SETLIST.
      TYPE-POOLS VRM. 
      DATA MYVALUE TYPE VRM_VALUES WITH HEADER LINE.
    *对内表加载值
      MYVALUE-KEY = &#39;CHINESE&#39;. MYVALUE-TEXT = &#39;中国&#39;.    
      APPEND MYVALUE.
      MYVALUE-KEY = &#39;AMERICAN&#39;. MYVALUE-TEXT = &#39;美国&#39;.         
      APPEND MYVALUE.
      MYVALUE-KEY = &#39;ENGLISH&#39;. MYVALUE-TEXT = &#39;英国&#39;. 
      APPEND MYVALUE.
      MYVALUE-KEY = &#39;FRENCH&#39;. MYVALUE-TEXT = &#39;法国&#39;.   
      APPEND MYVALUE.
    IF INIT IS INITIAL.
        CALL FUNCTION &#39;VRM_SET_VALUES&#39; &amp;quot;调用函数对下拉框对象传递数据
          EXPORTING
            ID = &#39;P_LANG&#39; &amp;quot;下拉框对象名
            VALUES = MYVALUE[]  &amp;quot;下拉框中加载的数据
         EXCEPTIONS
           ID_ILLEGAL_NAME = 1
           OTHERS = 2.
    ENDIF.
    INIT = &#39;X&#39;. &amp;quot;记录初始化状态
  ENDFORM.
&amp;lt;3&amp;gt; SELECT-OPTIONS 输入域
  SELECT-OPTIONS 参照数据库字段来建立输入域，命名不能超过8位，最大输入长度为18位：
  SELECT-OPTIONS： &amp;lt;S_1&amp;gt; FOR &amp;lt;dbtab-ele&amp;gt;.... .
  内表结构：
    SIGN：I , E
    OPTION: EQ,NE,CP（模糊查询）,NP,GE,LT,LE,GT
    LOW : 范围较小值
    HIGH: 范围较大值
  默认值设定：
    ...DEFAULT g:定义单一默认值。
    ...DEFAULT g...OPTION  xxx ... SIGN s:定义含判断条件的单一默认值。
    ...DEFAULT g TO h:定义默认值的取值范围。
    ...DEFAULT g TO h ... OPTION op ... SIGN s:设置默认值的聚会范围及判断条件。
    ...MEMORY ID pid:将SELECT-OPTIONS分配参数名并存储在SAP内存，参数名长度不能超过三位。
    ...NO-DISPLAY:将SELECT-OPTIONS设置为隐藏，不会在屏幕上输出。
    ...LOWER CASE:输入值中不允许输入小写字符，否则会自动转换为大写。
    ...OBLIGATORY:限制该SELECT-OPTIONS为必须输入的项目，执行中系统会提示。
    ...NO-EXTENSION:限制该SELECT-OPTIONS只能输入一行数据，输入多行按钮（上图最右边按钮）被隐藏。
    ...VISIBLE LENGTH vlen:定义所显示数据的长度。
 &amp;lt;4&amp;gt; GOTO--&amp;gt;Text Elements   (TCode:SE32)
    前台界面显示的为PARAMETERS和SELECTION-OPTION定义的字段，不便于理解需。
    提供某一字段的完整名称以方便用户理解。
    GOTO --&amp;gt;Translation：可进行多语言显示的维护
  包含字段：
    Selection Texts：定义已存在并且激活的屏幕元素的名称。
    Text Symbols：实现自定义文本及符号,该文本使用对象为SELECTION-SCREEN，以三位字符表示(TEXT-001)。
         图标符号:可以在Text Symbols通过@符号来进行引用，如&amp;quot;@01@&amp;quot;,可通过程序RSTXICON查看所有的图标
 &amp;lt;5&amp;gt; 屏幕事件处理
   INITIALIZATION. &amp;quot;程序初始化事件，該事件在程序屏幕未顯示之前執行。對程序設置值及屏幕元素進行初始化設置.
   START-OF-SELECTION事件：该事件在单击按钮后触发。
   END-OF-SELECTION事件：该事件应用于所有数据处理完成，即START-OF-SELECTION相关执行事件执行完成。
    但输出屏幕还未显示之前，在实际的应用于一些执行结果的检验等。
   AT SELECTION-SCREEN：选择屏幕显示之后，用来响应回车，F8，F1，F4等事件。
    ...ON &amp;lt;field&amp;gt;：检查具体输入字段(SELECTION-OPTIONS或PARAMETERS)是否完整或正确。
    ...ON VALUE-REQUEST FOR &amp;lt;field low/high&amp;gt;：SELECT-OPTIONS按选择帮助&amp;lt;F4&amp;gt;键时触发该事件。
    ...ON HELP-REQUEST FOR &amp;lt;field low/high&amp;gt;：SELECTION-OPTIONS按选择帮助&amp;lt;F1&amp;gt;键时键发该事件。
    ...ON RADIOBUTTON GROUP &amp;lt;radio&amp;gt;：单选按钮事件，必须进行整体输入检查。
    ...ON BLOCK &amp;lt;block&amp;gt;：框架的触发事件（控制框架中的屏幕元素值的输入）。
    ...OUTPUT：用于屏幕输出时的各屏幕元素值的管控（PBO处理，在选择屏幕显示之前就被调用；响应屏幕上的事件，用户回车或F8后也被调用；通过modify screen可以修改选择屏幕字段）。
    ...ON EXIT-COMMAND：用于&amp;quot;BACK&amp;quot;,&amp;quot;CANCEL&amp;quot;,&amp;quot;EXIT&amp;quot;等事件。
 &amp;lt;6&amp;gt;屏幕内创建按钮
  SELECTION-SCREEN PUSHBUTTON [/n] &amp;lt;pos(len)&amp;gt; &amp;lt;name&amp;gt; USER-COMMAND &amp;lt;ucom&amp;gt; [MODIF ID &amp;lt;key&amp;gt;].
    [/n] :按钮初始时距离屏幕左边的位置
    &amp;lt;pos(len)&amp;gt;：PUSHBUTTON按钮在屏幕生成的位置与长度。
    &amp;lt;name&amp;gt;：PUSHBUTTON按钮的名称，给按钮赋值时要用到名字。
    &amp;lt;ucom&amp;gt;：必须指定的字符代码，当用户在选择屏幕上触发按钮时，&amp;lt;ucom&amp;gt;被输入到词典对象字段：
            SSCRFIELDS-UCOMM中，必须显式使用语句TABLES引用SSCRFIELDS。
  实例：  
   TABLES SSCRFIELDS.&amp;quot;引用词典对象
   INCLUDE:&amp;lt;icon&amp;gt;.  &amp;quot;按钮中加入图标必须调用该类型库,图标请参考T-CODE：ICON
   SELECTION-SCREEN PUSHBUTTON /1(20) PUBU1 USER-COMMAND ABCD.
   SELECTION-SCREEN SKIP.&amp;quot;换行
   SELECTION-SCREEN PUSHBUTTON /10(25) PUBU2 USER-COMMAND ABCE. &amp;quot;位置从10开始
   AT SELECTION-SCREEN OUTPUT.
     MOVE &#39;CALL NEXT SCREEN&#39; TO PUBU1. &amp;quot;给PUBU1按钮赋值描述
     WRITE ICON_OKAY AS ICON TO PUBU2. &amp;quot;给PUBU2按钮添加图标，并且在给按钮赋值之前，否则将会把文字替换。
     CONCATENATE PUBU2 &#39;My Second Button&#39; INTO PUBU2 SEPARATED BY SPACE. &amp;quot;给第二个按钮添加赋值描述
   AT SELECTION-SCREEN.
    IF SSCRFIELDS-UCOMM = &#39;ABCD&#39;.
        PERFORM xxxx.  &amp;quot;调用子程序
    ENDIF.
 &amp;lt;7&amp;gt; 在工具栏上新增一个功能按钮
    SELECTION-SCREEN FUNCTION KEY n.
      该按钮的定义保存在系统结构体SSCRFIELDS中，n为一个整数序数最大至5。
    当n等于1时，其按钮描述保存在字段SSCRFIELDS-FUNCTXT_01中，其按钮对象命名为
    &amp;quot;FC01&amp;quot;,保存在字段SSCRFIELDS-UCOMM中。
  实例：
     TYPE-POOLS ICON. &amp;quot;Program Icon Library
     TABLES SSCRFIELDS.
     DATA functxt TYPE SMP_DYNTXT. &amp;quot;SMP_DYNTXT(菜单制作器:动态文本的程序接口)
     PARAMETERS: p_carrid TYPE s_carr_id,
                 p_cityfr TYPE s_from_cit.
     SELECTION-SCREEN: FUNCTION KEY 1,
                       FUNCTION KEY 2.
     INITIALIZATION. &amp;quot;屏幕初始化
       functxt-icon_id   = icon_ws_plane.  &amp;quot;文本字段中的图标（替换显示，别名） 
       functxt-quickinfo = &#39;Preselected Carrier&#39;.  &amp;quot;菜单制作器：信息文本 (4.0)，滑鼠移去过去显示的信息TIP
       functxt-icon_text = &#39;LH&#39;.  &amp;quot;菜单制作器：图标文本 (4.0)，菜单名称
       sscrfields-functxt_01 = functxt.
       functxt-icon_text = &#39;UA&#39;.
       sscrfields-functxt_02 = functxt.
     AT SELECTION-SCREEN.
       CASE SSCRFIELDS-UCOMM.
          WHEN &#39;FC01&#39;.
            p_carrid = &#39;LH&#39;.
            p_cityfr = &#39;Frankfurt&#39;.
          WHEN &#39;FC02&#39;.
            p_carrid = &#39;UA&#39;.
            p_cityfr = &#39;Chicago&#39;.
       ENDCASE.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;字段符号-filed-symbols&#34;&gt;字段符号：filed-symbols&lt;/h2&gt;

&lt;h2 id=&#34;内表操作&#34;&gt;内表操作&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;【增删改】
  &amp;lt;1&amp;gt; Loop AT循环(sy-tabix:索引号)
     LOOP AT itab {INTO wa}|{ASSIGNING &amp;lt;fs&amp;gt; [CASTING]} | {TRANSPORTING NO FILDS} 
        [[USING KEY key_name] [FROM idx1] [TO idx2] [WHERE log_exp|(cond_syntax)]].
     ENDLOOP.
  &amp;lt;2&amp;gt; INSERT &amp;lt;wa&amp;gt; INTO TABLE &amp;lt;itab&amp;gt;.[单条]
      INSERT &amp;lt;wa&amp;gt; INTO &amp;lt;itab&amp;gt; INDEX &amp;lt;idx&amp;gt;.[索引]
      INSERT LINES OF &amp;lt;itab&amp;gt; [FROM &amp;lt;n1&amp;gt;] [TO &amp;lt;n2&amp;gt;] INTO TABLE &amp;lt;itab&amp;gt;.[批量插入]
      APPEND &amp;lt;wa&amp;gt; TO &amp;lt;itab&amp;gt;.
      APPEND LINES OF &amp;lt;itab1&amp;gt; [FROM&amp;lt;n1&amp;gt;] [TO&amp;lt;n2&amp;gt;] TO &amp;lt;itab2&amp;gt;.
  &amp;lt;3&amp;gt; READ TABLE &amp;lt;itab&amp;gt; WITH KEY {&amp;lt;k1&amp;gt;=&amp;lt;f1&amp;gt;...[BINARY SEARCH]} INTO &amp;lt;wa&amp;gt;}
      [COMPARING &amp;lt;f1&amp;gt;&amp;lt;f2&amp;gt;...|ALL FIELDS]  [TRANSPORTING &amp;lt;f1&amp;gt; &amp;lt;f2&amp;gt; ...|ALL FIELDS
                                          |NO FIELDS] | ASSIGNING &amp;lt;fs&amp;gt;.
   COMPARING:根据关键字读取指定的单行与工作区&amp;lt;wa&amp;gt;中的相应组件进行比较。内容相同SY-SUBRC=0
  &amp;lt;4&amp;gt; MODIFY itab1.
      MODIFY itab INDEX idx FROM &amp;lt;wa&amp;gt; [TRANSPORTING &amp;lt;f1&amp;gt; &amp;lt;f2&amp;gt; ...].
      MODIFY TABLE &amp;lt;itab&amp;gt; FROM &amp;lt;wa&amp;gt; [TRANSPORTING &amp;lt;f1&amp;gt; &amp;lt;f2&amp;gt;...].[修改单条]
      MODIFY &amp;lt;itab&amp;gt; FROM &amp;lt;wa&amp;gt; TRANSPORTING &amp;lt;f1&amp;gt; &amp;lt;f2&amp;gt; ... WHERE &amp;lt;cond&amp;gt;.[修改多条]

      UPDATE dbtab SET f1=g1 ... fi=gi WHERE &amp;lt;con&amp;gt;.
  &amp;lt;5&amp;gt; DELETE TABLE &amp;lt;itab&amp;gt; FROM &amp;lt;wa&amp;gt; [USING KEY key_name].[删除单条]
      DELETE TABLE &amp;lt;itab&amp;gt; WITH TABLE KEY &amp;lt;k1&amp;gt;=&amp;lt;f1&amp;gt;.. .
      DELETE &amp;lt;itab&amp;gt; WHERE &amp;lt;cond&amp;gt;.[删除多行]
      DELETE &amp;lt;itab&amp;gt; [INDEX &amp;lt;idx&amp;gt;].
      删除重复
  (1)SORT record_tab. //首先进行排序处理
      (2)DELETE ADJACENT DUPLICATES ENTRIES FROM itab [USING KEY key_name] 
                                         [COMPARING K1 K2...] [ALL FIELDS].//删除
  &amp;lt;6&amp;gt; COLLECT &amp;lt;wa&amp;gt; INTO &amp;lt;itab&amp;gt;.
  &amp;lt;7&amp;gt; 第二索引
     UNIQUE KEY.唯一升序第二索引
     NON-UNIQUE KEY.非唯一升序第二索引
     通过第二索引在无法使用主键时，可以加快大量处理数据的速度。
【查】
  SELECT SINGLE ... INTO [CORRESPONDING FIELDS OF] &amp;lt;wa&amp;gt; WHERE ...
  SELECT ... INTO|APPENDING CORRESPONDING FIELDS OF TABLE &amp;lt;itab&amp;gt;...
  RANG条件内.表：
    RANGES sel FOR obj [OCCURS n].
    SELECT-OPTIONS selcrit FOR {dobj|(name)}.
  FOR ALLENTRIES:
    1:会自动删除重复行   2:WHERE后还有其他条件，会忽略后续条件
  表连接：
    INNER JOIN、LEFT OUTER JOIN.
【SAP锁】
  通用数据库表锁函数：ENQUEUE_E_TABLE、DEQUEUE_E_TABLE、DEQUEUE_ALL
  特定数据库表函数：ENQUEUE_&amp;lt;LOCK OBJ&amp;gt;、DEQUEUE_&amp;lt;LOCK OBJ&amp;gt;
  自定义锁对象：EZ_/EY_命名
  S:共享锁     E:可重入的排他锁     X:排他锁
  1、在SE11里创建锁对象，自定义的锁对象都必须以EZ或者EY开头来命名。一个锁对象里只包含一个
     PRIMARY TABLE，可以包含若干个SECONDARY TABLE，锁的模式有三种：E，S，X。
   模式E：当更改数据的时候设置为此模式。   (Shared lock, read lock) 【一般使用E】
   模式S：本身不需更改数据，但是希望显示的数据不被别人更改 (Exclusive lock, write lock)
   模式X：和E类似，但是不允许累加，完全独占。 
          (Exclusive lock, extended write lock, cannot be cumulated)
  2、上锁的一般步骤
      先上锁，上锁成功之后，从数据库取数据，然后更改数据，接着更新到数据库，最后解锁。
   按照这个步骤，才能保证更改完全运行在锁的保护机制下。
  3、上锁与解锁
   ENQUEUE_&amp;lt;lock object的名字&amp;gt; 对象 EZZSOPR0032 要求的锁定
   DEQUEUE_&amp;lt;lock object的名字&amp;gt; 释放对象 EZZSOPR0032 的锁定
     有些情况下，程序中设置成功的逻辑锁会隐式的自己解锁。比如说程序结束发生的时候
  （MESSAGE TYPE为A或者X的时候），使用语句LEAVE PROGRAM，LEAVE TO TRANSACTION，或者在
   命令行输入/n回车以后。使用DEQUEUE FUNCTION MODULE来解锁的时候，不会产生EXCEPTION。
   要解开你在程序中创建的所有的逻辑锁，可以用FM：DEQUEUE_ALL.
【事务处理】
  COMMIT WORK.         异步更新。
  COMMIT WORK AND WAIT.同步跟新，执行结果可通过sy-subrc判断是否提交成功。
  ROLLBACK WORK.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;message-se91&#34;&gt;MESSAGE ：SE91&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;1&amp;gt; 消息类的操作
  使用T-CODE:SE91对Message定义，还能够对Message进行创建，修改及删除等维护操作。
  Message Short Text字段为类描述，可以定义输入参数&amp;amp;，如&amp;quot;1&amp;amp;2&amp;amp;3&amp;amp;&amp;quot;表示有三个输入参数。
  Message共分以下几种类型：E:错误、W:警告、I：信息、A：异常中止、S:成功。
  引用语法为: Message W000(00)，表示调用&#39;00&#39;类的&#39;000&#39; Message类型为警告。
    EX: Message W001(ZTEST) WITH &#39;P1&#39; &#39;P2&#39; &#39;P3&#39;.
1. 消息ID MESSAGE e001(00) WITH &#39;12345678&#39;. //利用定义的参数
2. MESSAGE &#39;XXXXXXXXXX&#39; TYPE &#39;X&#39;.          //直接附加消息
3. MESSAGE s001(00) WITH &#39;No data&#39; DISPLAY LIKE &#39;E&#39;.
   EXIT.                                   //Screen 界面查询数据无，则返回原界面
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;alv常使用的bapi&#34;&gt;ALV常使用的BAPI&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;在ALV开发中有两个重要的对象：LAYOUT和FIELDCAT,它们同属于类型池SLIS。
   LAYOUT主要用于设置ALV的输出格式，如输出字段的颜色、表格中的线条等；
   FIELDCAT主要用于ALV结构定义，包括具体字段的名称、类型、格式等属性.
常使用的开发类:
   &amp;lt;1&amp;gt; REUSE_ALV_FIENDCATALOG_MERGE：根据内表结构返回FIELDCAT字段结构信息.
   &amp;lt;2&amp;gt; REUSE_ALV_GRID_DISPLAY/REUSE_ALV_LIST_DISPLAY：输出ALV报表，定义其为GRID模式还是LIST模式。参数结构一样。
   &amp;lt;3&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;alv-报表的表头字段显示设置&#34;&gt;ALV 报表的表头字段显示设置&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;call function &#39;LVC_FIELDCATALOG_MERGE&#39;
exporting
  I_BUFFER_ACTIVE        = I_BUFFER_ACTIVE
  I_structure_name       = &#39;ZALV_FEED&#39; &amp;quot;ALV需要显示的字段结构
  I_CLIENT_NEVER_DISPLAY = &#39;X&#39;
  I_BYPASSING_BUFFER     = I_BYPASSING_BUFFER
  I_INTERNAL_TABNAME     = I_INTERNAL_TABNAME
    changing
      ct_fieldcat         = lt_fieldcat  &amp;quot;对应ALV显示的字段结构
exceptions
  inconsistent_interface = 1
  program_error          = 2.
 可以通过loop对相应的ALV字段描述进行自定义设置
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;layout-字段&#34;&gt;Layout 字段&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;DATA wa_alv_field TYPE SLIS_LAYOUT_ALV.
LAYOUT主要用于设置ALV的输出格式，如输出字段的颜色、表格中的线条等；
  0.COLTAB_fieldname type slis_fieldname: 设置单元格颜色
  1.EDIT：设置ALV是否为可编辑模式。
  2.COLWIDTH_OPTIMIZE：将ALV字段宽度设置为最优化，按实际输出内容宽度自动匹配。
  3.NO_VLINE：输出ALV表格不显示垂直格式。
  4.NO_ULINE_HS：输出ALV表格不显示水平格线。
  5.INFO_FIELDNAME：设置颜色属性。
  6.KEY_HOTSPOT：设置关键字段热点。
  7.NO_COLNAME：是否显示字段名。
  8.ZEBRA：使ALV表格按斑马线间隔条纹方式显示，以便显示效果更有美观。
  9.BOX_FIELDNAME：设置ALV表格是否显示选择按钮字段。
  10.f2code  like   sy-ucomn. gs_layout-f2code=&#39;&amp;amp;ETA&#39;[双击时触发的funcode]
  11.INFO_FIELDNAME：用于设置ALV输出报表每一行的颜色，其参数为输出内表的字段名称，
    要注意的是使用该属性需要同时在内表中定义一个与该参数所定义字段名相同的字段，例如：
  LAYOUT-INFO_FIELDNAME = &#39;COLOR&#39;.倘若其数据输出内表名为LT_OUT,则需要在该内表增加一字段
  “COLOR”，并为其内表每行复制，颜色参数范围C000~C999，例如：LT_OUT-COLOR = &#39;C012&#39;.

【颜色】
  行颜色:gs_layout-&amp;lt;info_fieldname&amp;gt; = &#39;COLOR&#39;
  列颜色:gt_fieldcat-emphasize = &#39;C510&#39;.[1：C固定，2：颜色值0~7,3：高亮0、1(X)，
                                         4：颜色反转，0、1]
  单元格颜色:gs_layout-&amp;lt;coltab_fieldname&amp;gt;=&#39;COLORTABLE&#39;.
【可编辑】
  整体可编辑：gs_layout-edit = &#39;X&#39; 
  某列可编辑：gt_fieldcat-edit = &#39;X&#39;
  单元格可编辑：
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;9-fieldcatalog-字段&#34;&gt;9.Fieldcatalog 字段&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;FIELDCAT主要用于ALV结构定义，包括具体字段的名称、类型、格式等属性.
  DATA lt_alv_fieldcat TYPE SLIS_T_FIELDCAT_ALV WITH HEADER LINE.
　　1.KEY：将定义字段设置为KEY值。
    2.ICON：将定义字段以ICON的形式显示。
    3.CHECKBOX：将定义字段以CHECKBOX的形式显示。
    4.JUST：定义字段对齐方式(R)RIGHT、(L)LEFT、(C)CENTER。
    5.IZERO：将定义字段以前导&amp;quot;0&amp;quot;的形式显示。
    6.NO_SIGN：将定义字段符号设置为不显示。
    7.NO_ZERO：定义字段是否显示。
    8.EMPHASIZE：设置字段的颜色。
    9.DO_SUM：对字段进行汇总。
    10.SELTEXT_L/M/S：设置字段名称描述长/中/短。
    11.DDICTXT：设置字段显示字符串。
    12.HOTSPOT：设置字段是否有热点(热点字段显示有下划线)。
    13.NO_OUT: 隐藏不需要的字段(NO_OUT = &#39;X&#39;)。
    14.EDIT(1) type c: 是否可编辑
    15:COL_POS like sy-cucol: 列输出位置
    16:FIX_COLUMN(1) type c: 列固定不滚动，颜色不会发生变化
    17:convexit : 设置转换规则，对应于Domain中的转换规则    

fieldname  type slis_fieldname    (列显示的设置)
cfieldname type slis_fieldname  (金额字段所参照的货币单位字段名)
ctabname   type slis_tabname      (金额字段所参照的货币单位表名)
qfieldname type slis_fieldname  (数量字段所参照的货币单位字段名)
qtabname   type slis_tabname      (数量字段所参照的货币单位表名)

自定义FIELDCAT字段结构：
  &amp;quot;定义宏来设置FIELDAT属性 &amp;amp;1 &amp;amp;2 &amp;amp;3分别为参数
    DEFINE fieldcatset.
      lt_alv_fieldcat-REF_TABNAME =&#39;LSPFLI&#39;.
      lt_alv_fieldcat-FIELDNAME = &amp;amp;1.
      lt_alv_fieldcat-SELTEXT_L = &amp;amp;2.
      lt_alv_fieldcat-COL_POS = &amp;amp;3.
      APPEND lt_alv_fieldcat.
    END-OF-DEFINITION.
    fieldcatset &#39;CARRID&#39; &#39;航线承运人&#39; SY-TABIX.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;10-单元格中的数据被修改后-将alv单元格中的数据立即刷新到abap对应的内表中&#34;&gt;10.单元格中的数据被修改后，将ALV单元格中的数据立即刷新到ABAP对应的内表中&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;方法一：通过对REUSE_ALV_GRID_DISPLAY函数参数i_grid_settings-edt_cll_cb进行设置：
i_grid_settings-edt_cll_cb  = &#39;X&#39; .
CALL FUNCTION &#39;REUSE_ALV_GRID_DISPLAY&#39;
EXPORTING i_grid_settings = i_grid_settings
方法二：通过函数参数I_CALLBACK_USER_COMMAND指定的回调Form的参数slis_selfield进行设置：
FORM user_command USING ucomm LIKE sy-ucommselfield selfield TYPE slis_selfield.
    selfield-refresh = &#39;X&#39;.
  CASE ucomm.
    WHEN &#39;UPDATE&#39;.
    PERFORM frm_update.
  ENDCASE.
ENDFORM. 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;11-自定义按钮使用后刷新alv&#34;&gt;11 自定义按钮使用后刷新ALV&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt; form frm_user_command using r_ucomm     like sy-ucomm
                        rs_selfield type slis_selfield.
  case r_ucomm.
   when &#39;PROFIT&#39;.
      perform frm_cycle_count_profit.
   when others.
  endcase.
     rs_selfield-refresh = &#39;X&#39;.
 endform.                    &amp;quot;frm_user_command
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;12-设置工具导航栏-gui-status&#34;&gt;12 设置工具导航栏 GUI Status&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;GUI Status参数设置共包括3个部分：
  1.菜单栏(Menu Bar)：用于设置主菜单选项。
  2.应用工具条(Application ToolBar)：用于设置应用工具栏按钮，包括按钮名称、按钮描述、及按钮所对的ICON图标。
  3.功能键(Function Key)：为按钮分配功能键代码，包括系统标题按钮(如返回、退出、关闭等)及通过Application ToolBar所定义的客制化按钮。
  4. 对于定义的按钮，我们可以通过系统变量SY-UCOMM来获取它的功能代码。
    AT USER-COMMAND.   &amp;quot;当单击某个按钮时，触发该事件
      CASE sy-ucomm.  &amp;quot;获取所操作按钮的功能代码(FUNCTION Code)
  5.调用显示，应用于START-OF-SELECTION事件
     SET PF-STATUS &amp;lt;STATUS_NAME&amp;gt;.
     不显示某些按钮：SET PF-STATUS &amp;lt;STATUS_NAME&amp;gt; EXCLUDING &amp;lt;extab&amp;gt;.
 6.在ALV函数中使用
  call function &#39;REUSE_ALV_GRID_DISPLAY_LVC&#39;
    exporting
      i_callback_program       = sy-repid 
      i_callback_pf_status_set = &#39;FRM_SET_STATUS&#39;
      i_callback_user_command  = &#39;FRM_USER_COMMAND&#39;
      is_layout_lvc            = lw_layout
      it_fieldcat_lvc          = gt_fieldcat
      i_default                = &#39;X&#39;
      i_save                   = &#39;X&#39;
   tables
      t_outtab                 = gt_alv_pi_diffs
   exceptions
      program_error            = 1.

  form frm_set_status using extab type slis_t_extab.
     data: ls_slis_extab type slis_extab.
      SET PF-STATUS &amp;lt;STATUS_NAME&amp;gt;.
  endform.                    &amp;quot;frm_set_status
GUI TITLE设置：
    GUI TITLE 用于定义Report标题栏内容.
  定义：
    Create--&amp;gt;GUI Titles：可以输入&amp;amp;符号作为Title,当程序运行时对其填充动态文本。
  在程序中调用：
    SET TITLEBAR &#39;TITLE_BAR&#39; WITH SY-DATUM &#39;IFENER&#39; &#39;BAR TEST&#39;.&amp;quot;设置TITLEBAR，并赋参数列表
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;13-oo-alv&#34;&gt;13. OO ALV&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;相关类：
  CL_GUI_CUSTOM_CONTAINER   ：用户自己定义控件区域
  CL_GUI_DOCKING_CONTAINER  : 动态创建容器，不需要在创建时绑定到预先绘制好的自定义控件中
  CL_GUI_SPLITTER_CONTAINER ：可在同一屏幕创建多个ALV显示
  CL_GUI_ALV_GRID           ：ALV控制类

  DATA : obj_wcl_container TYPE REF TO cl_gui_custom_container, &amp;quot;控制容器类
         obj_wcl_alv TYPE REF TO cl_gui_alv_grid . &amp;quot;ALV控制类
  DATA GS_LAYOUT1 TYPE LVC_S_LAYO. &amp;quot;布局结构
  DATA GT_FIELDCAT TYPE LVC_T_FCAT. &amp;quot;存放字段目录的内表
  DATA GS_FIELDCAT TYPE LVC_S_FCAT.
  DATA lt_exclude TYPE ui_functions. &amp;quot;alv不需要的图标按钮
1、控制区域、容器、Grid关系
   先在屏幕绘制一个用户自定义控件区域，然后以自定义区域为基础创建 CL_GUI_CUSTOM_CONTAINER
 容器实例,最后以此容器实例来创建 CL_GUI_ALV_GRID实例。
    DATA : obj_wcl_container TYPE REF TO cl_gui_custom_container, &amp;quot;控制容器类
           obj_wcl_alv TYPE REF TO cl_gui_alv_grid . &amp;quot;ALV控制类
    IF obj_wcl_alv IS INITIAL.
       CREATE OBJECT obj_wcl_container
          EXPORTING
             container_name  =  &#39;OBJ_WCL_CONTAINER&#39;.
       CREATE OBJECT obj_wcl_alv
          EXPORTING
             i_parent  = obj_wcl_container.
2、给ALV对象注册事件
  (1) HANDLE_TOOLBAR:这个事件用于给ALV加自定义工具条按钮。
  (2) HANDLE_CLICK:用于给ALV点击其中一行后处理代码段。
  (3) HANDLE_COMMAND:事件用于接收用户按了自定义按钮后，触发的代码段。
  (4) HANDLE_DOUBLE_CLICK：双击事件
  (5) 
  事件的使用：
    &amp;lt;1&amp;gt; 定义事件方法
    &amp;lt;2&amp;gt; 指定事件的执行方法代码
    &amp;lt;3&amp;gt; 事件变量实例化
    &amp;lt;4&amp;gt; 把事件指定到ALV控制中(注册事件)

    CREATE OBJECT event_receiver.
    SET HANDLER event_receiver -&amp;gt; handle_double_click FOR obj_wcl_alv.
3、CL_GUI_ALV_GRID重要方法
  *-----显示ALV 
     CALL METHOD obj_wcl_alv-&amp;gt;set_table_for_first_display 
        EXPORTING 
           is_variant                    = ls_variant   :指定布局变式
           is_layout                     = ls_layout 
           i_save                        = &#39;A&#39;          :保存表格布局
           it_toolbar_excluding          = lt_exclude 
        CHANGING 
           it_outtab                     = gt_list[]    :需要显示的内表数据
           it_fieldcatalog               = lt_fieldcat  :结构字段
        EXCEPTIONS 
           invalid_parameter_combination = 1 
           program_error                 = 2 
           too_many_lines                = 3 
           OTHERS                        = 4.

   ENDFORM.                    &amp;quot; FRM_ALV_DISPLAY

  XXX -&amp;gt; REFRESH_TABLE_DISPLAY.
    IS_STABLE : 刷新的稳定性，就是滚动条保持不动
    I_SOFT_REFRESH:  软刷新，临时给ALV创建的合计，排序，等保持不变
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;14-前导零问题&#34;&gt;14.前导零问题&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;加上p_in的前导零
  FORM add_zero  CHANGING p_in.
CALL FUNCTION &#39;CONVERSION_EXIT_ALPHA_INPUT&#39;
  EXPORTING
    input  = p_in
    IMPORTING
      output = p_in.
 ENDFORM.
去除p_out的前导零
  FORM del_zero CHANGING p_out.
    CALL FUNCTION &#39;CONVERSION_EXIT_ALPHA_OUTPUT&#39;
    EXPORTING
      input  = p_out
    IMPORTING
     output = p_out.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;15-hash-table-sort-table-standy-table&#34;&gt;15.Hash table, sort table, standy table&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;   对于排序内表，不要使用append，append lines附加数据，使用insert、insert lines向
排序内表中插入数据
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;16-search-help-的创建&#34;&gt;16.search help 的创建&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;PARAMETERS p_cur TYPE XXX VALUE CHECK .
PROCESS ON VALUE-REQUEST ， AT SELECTION-SCREEN ON VALUE-REQUEST。
在屏幕的 ON VALUE-REQUEST 事件里可以通过下面几个函数来创建搜索帮助：
  F4IF_ FIELD _VALUE_REQUEST ： 函数的作用是在运行时，可以动态的为某个屏幕字段指定 
     Search Help ，这个被引用的 Help 来自某个表（或结构）字段上绑定的 Help
  F4IF_ INT_TABLE _VALUE_REQUEST : 在程序运行时， 将某个内表动态的用作 Search help 的
     数据来源,即使用该函数可以将某个内表转换为 Search help ，可实现联动效果
  TR_F4_HELP ： 简单实现 Search Help ，数据来源于内表。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;17-sql-语句的执行顺序&#34;&gt;17. SQL 语句的执行顺序&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;书写顺序：SELECT[DISTINCT]--&amp;gt;FROM--&amp;gt;WHERE--&amp;gt;GROUP BY--&amp;gt;HAVING--&amp;gt;UNION--&amp;gt;ORDER BY
其执行顺序为：FROM--&amp;gt;WHERE--&amp;gt;GROUP BY--&amp;gt;HAVING--&amp;gt;SELECT--&amp;gt;DISTINCT--&amp;gt;UNION-&amp;gt;ORDER BY
1、FROM 才是 SQL 语句执行的第一步，并非 SELECT 
2、SELECT 是在大部分语句执行了之后才执行的，严格的说是在 FROM 和 GROUP BY 之后执行的。
3、无论在语法上还是在执行顺序上， UNION 总是排在在 ORDER BY 之前。
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;open-sql&#34;&gt;Open SQL&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;focus&#34;&gt;Focus&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;1. 多表的结合的查询，首先进行各自的关键字查询，然后进行表与表转换可以提升效率
2. 表相应字段非关键字时，寻找有该关键字的相对应的关联表进行查询并合并表数据
3. binary search 和 sort 进行使用时注意sort的关键字与binary search 保持统一
4. MODIFY itab1 INDEX sy-tabix.进行修改时最好定义变量记录sy-tabix.
5. inner join 和 left outer join 的连接条件最好都是关键字.
6. 双层loop循环时，第二个内部表定义为SORTED TABLE会大大的提高处理速度
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>报表开发(三)</title>
      <link>https://coldinfire.github.io/2018/ABAPTable3/</link>
      <pubDate>Wed, 12 Sep 2018 17:20:58 +0800</pubDate>
      
      <guid>https://coldinfire.github.io/2018/ABAPTable3/</guid>
      <description>

&lt;h2 id=&#34;执行程序的使用范围-报表事件&#34;&gt;执行程序的使用范围，报表事件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;LOAD-OF-PROGRAM.
INITIALIZATION.          （Before display the selection screen）
  AT-SELECTION SCREEN ON fiedl.（在PAI事件结束后执行，进行校验和检查输入值）
  AT SELECTION-SCREEN ON VALUE-REQUEST FOR Z_XXX.
AT SELECTION-SCREEN. //After enter the option data check
   PERFORM check_input.
START-OF-SELECTION.//Begin the main programer
  xxxx
END-OF-SELECTION.
Interactive Eventrs. (User for interactive reporting)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;报表程序大体逻辑结构&#34;&gt;报表程序大体逻辑结构&lt;/h2&gt;

&lt;p&gt;​   &lt;strong&gt;抬  头:&lt;/strong&gt; 报表的主要信息(抬头信息)&lt;/p&gt;

&lt;p&gt;​   &lt;strong&gt;行项目:&lt;/strong&gt; 查询出的每行记录信息&lt;/p&gt;

&lt;p&gt;​   &lt;strong&gt;明  细:&lt;/strong&gt; 每个行项目出关键字外其他明细内容&lt;/p&gt;

&lt;h2 id=&#34;字段符号&#34;&gt;字段符号&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt; FIELD-SYMBOLS &lt;FS&gt; LIKE structure.&lt;/p&gt;

&lt;p&gt;​    &lt;1&gt; FS必须和某个变量，结构或者内表绑定后才能使用，这点和C语言里的指针
​     （在ABAP里最接近指针的是TYPE REF TO）不同，在使用FS前必须分配给某个变量，不然会发生
​      FS未分配的运行时错误。如果LOOP内表时ASSIGNING到FS，之后假如有REFRESH内表的操作的话，
​      FS也会再次回到初始未被ASSIGN的状态，这时如果使用FS也会发生FS未分配的RUNTIME ERROR。
​    &lt;2&gt; ASSIGN structure TO &lt;fs&gt;:将某个内存区域分配给字段符号，这样字段符号就代表了该内存
​      区域，即该内存区域别名字段符号可以看作仅是已经被解引用的指针，即某个变量的别名。
  ASSIGN &lt;Val&gt; TO &lt;fs&gt;: 将某个内存区域分配给字段符号，这样字段符号就代表了该内存区域。
  UNASSIGN: 该语句是初始化&lt;FS&gt;字段符号，执行后字段符号将不再引用内存区域，
​            &lt;fs&gt; is assigned返回假。
  CLEAR: 与UNASSIGN不同的是，只有一个作用就是初始化它所指向的内存区域，而不是解除分配。
3.2 LOOP内表INTO结构（工作区）和LOOP内表ASSIGNING&amp;lt;结构&amp;gt;的比较
​    LOOP内表INTO结构时，系统会把先把当前行的数据复制到结构，如果结构的值改了，还需要使用
  MODIFY语句把更改后的值传回内表。也就是说，结构是内表里的数据的一个副本，操作这个副本不会
  影响内表里的数据。为了提高效率，可以使用FS，FS直接指向内表数据，省去了复制数据到结构的过程
  修改FS的值也就是相当于直接修改内表里的数据，不需要再使用MODIFY语句。
3.3 READ TABLE内表
3.4 ASSIGN隐式强转
TYPES: BEGIN OF t_date,
​    year(4) TYPE  n,
​        month(2) TYPE n,
​    day(2) TYPE n,
  END OF t_date.
FIELD-SYMBOLS &lt;fs&gt; TYPE t_date.&amp;ldquo;将&lt;fs&gt;定义成了具体限定类型
ASSIGN sy-datum TO &lt;fs&gt; CASTING. &amp;ldquo;后面没有指定具体类型，所以使用定义时的类型进行隐式转换
3.5 ASSIGN显示强转
  DATA txt(8) TYPE c VALUE &amp;lsquo;19980606&amp;rsquo;.
  FIELD-SYMBOLS &lt;fs&gt;.
  ASSIGN txt TO &lt;fs&gt; CASTING TYPE d.&amp;ldquo;由于定义时未指定具体的类型，所以这里需要显示强转
3.6 动态引用，通过循环赋值给定义的字段符号，对其进行修改，等于直接修改原内表。
  field-symbols:&lt;l_shortageqty&gt; type mng01.
  loop at &lt;dyn_table&gt; assigning &lt;dyn_wa&gt;.
​    assign component &amp;lsquo;SHORTAGEQTY&amp;rsquo; of structure &lt;dyn_wa&gt; to &lt;l_shortageqty&gt;.
​    &lt;l_shortageqty&gt; = &lt;l_shortageqty&gt; - &lt;l_fvalue&gt;.&lt;/p&gt;

&lt;h2 id=&#34;选择屏幕&#34;&gt;选择屏幕&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/foxting/archive/2012/07/01/2572243.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;引用链接&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;1&amp;gt;SELECT-SCREEN 框架结构
  SELECT-SCREEN语句用于创建屏幕的框架结构,主要包括屏幕元素的创建、子屏幕的创建等。
  定义屏幕对象：
    SELECTION-SCREEN BEGIN OF SCREEN src.
      .......
    SELECTION-SCREEN END OF SCREEN src.
    该语法用于定义一个INCLUDE SUREEN，可通过CALL方法在Report程序中引用。
   CALL SCREEN &amp;lt;num&amp;gt; STARTING AT [1 2] ENDING AT [1 2].
   参数可以将所定义屏幕窗体作为一个新的对话框窗体来引用，并指定期创建的具体大小及位置。
  注意：当从一个主屏幕中来调用其程序中的另一窗体时，必须使用CALL SELECTION-SCREEN方法.
  定义屏幕块：
    SELECTION-SCREEN BEGIN OF BLOCK block.
      ......
    SELECTION-SCREEN END OF BLOCK.
    该语法在屏幕中定义一个BLOCK，其扩展语法包括：
      ...WITH FRAME：创建一个框架
      ...TITLE title：创建一个带标题的框架。
      ...NO INTERVALS：所创建的框架中限制SELECT只有一个输入项。 
 其他元素：
  SELECTION-SCREEN INCLUDE BLOCKS &amp;lt;block1&amp;gt;.  调用已存在屏幕元素
  SELECTION-SCREEN ULINE.  划出横线，必须用在BLOCK中才能生效。
  SELECTION-SCREEN SKIP &amp;lt;n&amp;gt;.  在BLOCK中产生换行&amp;lt;n&amp;gt;。
  SELECTION-SCREEN POSITION &amp;lt;pos&amp;gt;. 在BLOCK中产生空格。
  SELECTION-SCREEN BEGIN OF LINE.
    ......
  SELECTION-SCREEN END OF LINE. 将所生成的屏幕元素控制在一行.
&amp;lt;2&amp;gt;PARAMETERS 单值输入
  PARAMETERS 参照数据字典具体字段或者自定义数据类型创建单值文本输入域以及单选/复选框等：
  PARAMETERS: &amp;lt;P_1&amp;gt; LIKE &amp;lt;field&amp;gt;    &amp;quot;文本域
            TYPE AS CHECKBOX.       &amp;quot;复选框
            RADIOBUTTON GROUP GRP1, &amp;quot;单选域 
            P2 RADIOBUTTON GROUP GRP1 DEFAULT &#39;X&#39;,  &amp;quot;默认选中 ”X“
            P3 RADIOBUTTON GROUP GRP1. &amp;quot;GRP1单选组
  默认值：
    ...DEFAULT f:定义默认值。
    ...TYPE type:参照某一类型对象定义PARAMETERS。
    ...DECIMALS dec：定义小数位，对输入参数自动格式化，该语法只对P类型有效(参数某一类型定义关键字TYPE)。 
    ...LIKE g：參照某一字典对象定义PARAMETERS。
    ...MEMORY ID pi：将PARAMETERS存储在SAP内存，参数名长度不能超过三位。
    ...NO-DISPLAY：将PARAMETERS设置为隐藏，不会的屏幕上输出。
    ...LOWER CASE：输入值中不允许输入小写字符，否则会自动转换为大写。
    ...OBLIGATORY：限制该PARAMETERS为必填，否则会提示输入。
    ...AS CHECKBOX：创建CHECKBOX对象。
    ...RADIO BUTTON GROUP radi：创建（RADIO）单选框。
    ...VISIBLE LENGTH vlen：定义显示长度。
    ...USER-COMMAND ucom：为创建对象分配对象名，该值保存在内表中可供其它对象操作。
    ...AS LISTBOX VISIBLE LENGTH vlen：创建一个下拉框，并指定长度。
 下拉框实现：
  *定义一个下拉框对象，其可视数据长度一般比输出数据长度大2用于放置下拉图标
    PARAMETERS:P_LANG(20) AS LISTBOX VISIBLE LENGTH 22.
  *该变量用于记录下拉列表数值是否初始化，否则每次屏幕初始化都会重新加载重复数据
    DATA:INIT.
    AT SELECTION-SCREEN OUTPUT.
    PERFORM SETLIST.
  *子程序用于加载下拉框的数据
    FORM SETLIST.
      TYPE-POOLS VRM. 
      DATA MYVALUE TYPE VRM_VALUES WITH HEADER LINE.
    *对内表加载值
      MYVALUE-KEY = &#39;CHINESE&#39;. MYVALUE-TEXT = &#39;中国&#39;.    
      APPEND MYVALUE.
      MYVALUE-KEY = &#39;AMERICAN&#39;. MYVALUE-TEXT = &#39;美国&#39;.         
      APPEND MYVALUE.
      MYVALUE-KEY = &#39;ENGLISH&#39;. MYVALUE-TEXT = &#39;英国&#39;. 
      APPEND MYVALUE.
      MYVALUE-KEY = &#39;FRENCH&#39;. MYVALUE-TEXT = &#39;法国&#39;.   
      APPEND MYVALUE.
    IF INIT IS INITIAL.
        CALL FUNCTION &#39;VRM_SET_VALUES&#39; &amp;quot;调用函数对下拉框对象传递数据
          EXPORTING
            ID = &#39;P_LANG&#39; &amp;quot;下拉框对象名
            VALUES = MYVALUE[]  &amp;quot;下拉框中加载的数据
         EXCEPTIONS
           ID_ILLEGAL_NAME = 1
           OTHERS = 2.
    ENDIF.
    INIT = &#39;X&#39;. &amp;quot;记录初始化状态
  ENDFORM.
&amp;lt;3&amp;gt; SELECT-OPTIONS 输入域
  SELECT-OPTIONS 参照数据库字段来建立输入域，命名不能超过8位，最大输入长度为18位：
  SELECT-OPTIONS： &amp;lt;S_1&amp;gt; FOR &amp;lt;dbtab-ele&amp;gt;.... .
  内表结构：
    SIGN：I , E
    OPTION: EQ,NE,CP（模糊查询）,NP,GE,LT,LE,GT
    LOW : 范围较小值
    HIGH: 范围较大值
  默认值设定：
    ...DEFAULT g:定义单一默认值。
    ...DEFAULT g...OPTION  xxx ... SIGN s:定义含判断条件的单一默认值。
    ...DEFAULT g TO h:定义默认值的取值范围。
    ...DEFAULT g TO h ... OPTION op ... SIGN s:设置默认值的聚会范围及判断条件。
    ...MEMORY ID pid:将SELECT-OPTIONS分配参数名并存储在SAP内存，参数名长度不能超过三位。
    ...NO-DISPLAY:将SELECT-OPTIONS设置为隐藏，不会在屏幕上输出。
    ...LOWER CASE:输入值中不允许输入小写字符，否则会自动转换为大写。
    ...OBLIGATORY:限制该SELECT-OPTIONS为必须输入的项目，执行中系统会提示。
    ...NO-EXTENSION:限制该SELECT-OPTIONS只能输入一行数据，输入多行按钮（上图最右边按钮）被隐藏。
    ...VISIBLE LENGTH vlen:定义所显示数据的长度。
 &amp;lt;4&amp;gt; GOTO--&amp;gt;Text Elements   (TCode:SE32)
    前台界面显示的为PARAMETERS和SELECTION-OPTION定义的字段，不便于理解需。
    提供某一字段的完整名称以方便用户理解。
    GOTO --&amp;gt;Translation：可进行多语言显示的维护
  包含字段：
    Selection Texts：定义已存在并且激活的屏幕元素的名称。
    Text Symbols：实现自定义文本及符号,该文本使用对象为SELECTION-SCREEN，以三位字符表示(TEXT-001)。
         图标符号:可以在Text Symbols通过@符号来进行引用，如&amp;quot;@01@&amp;quot;,可通过程序RSTXICON查看所有的图标
 &amp;lt;5&amp;gt; 屏幕事件处理
   INITIALIZATION. &amp;quot;程序初始化事件，該事件在程序屏幕未顯示之前執行。對程序設置值及屏幕元素進行初始化設置.
   START-OF-SELECTION事件：该事件在单击按钮后触发。
   END-OF-SELECTION事件：该事件应用于所有数据处理完成，即START-OF-SELECTION相关执行事件执行完成。
    但输出屏幕还未显示之前，在实际的应用于一些执行结果的检验等。
   AT SELECTION-SCREEN：选择屏幕显示之后，用来响应回车，F8，F1，F4等事件。
    ...ON &amp;lt;field&amp;gt;：检查具体输入字段(SELECTION-OPTIONS或PARAMETERS)是否完整或正确。
    ...ON VALUE-REQUEST FOR &amp;lt;field low/high&amp;gt;：SELECT-OPTIONS按选择帮助&amp;lt;F4&amp;gt;键时触发该事件。
    ...ON HELP-REQUEST FOR &amp;lt;field low/high&amp;gt;：SELECTION-OPTIONS按选择帮助&amp;lt;F1&amp;gt;键时键发该事件。
    ...ON RADIOBUTTON GROUP &amp;lt;radio&amp;gt;：单选按钮事件，必须进行整体输入检查。
    ...ON BLOCK &amp;lt;block&amp;gt;：框架的触发事件（控制框架中的屏幕元素值的输入）。
    ...OUTPUT：用于屏幕输出时的各屏幕元素值的管控（PBO处理，在选择屏幕显示之前就被调用；响应屏幕上的事件，用户回车或F8后也被调用；通过modify screen可以修改选择屏幕字段）。
    ...ON EXIT-COMMAND：用于&amp;quot;BACK&amp;quot;,&amp;quot;CANCEL&amp;quot;,&amp;quot;EXIT&amp;quot;等事件。
 &amp;lt;6&amp;gt;屏幕内创建按钮
  SELECTION-SCREEN PUSHBUTTON [/n] &amp;lt;pos(len)&amp;gt; &amp;lt;name&amp;gt; USER-COMMAND &amp;lt;ucom&amp;gt; [MODIF ID &amp;lt;key&amp;gt;].
    [/n] :按钮初始时距离屏幕左边的位置
    &amp;lt;pos(len)&amp;gt;：PUSHBUTTON按钮在屏幕生成的位置与长度。
    &amp;lt;name&amp;gt;：PUSHBUTTON按钮的名称，给按钮赋值时要用到名字。
    &amp;lt;ucom&amp;gt;：必须指定的字符代码，当用户在选择屏幕上触发按钮时，&amp;lt;ucom&amp;gt;被输入到词典对象字段：
            SSCRFIELDS-UCOMM中，必须显式使用语句TABLES引用SSCRFIELDS。
  实例：  
   TABLES SSCRFIELDS.&amp;quot;引用词典对象
   INCLUDE:&amp;lt;icon&amp;gt;.  &amp;quot;按钮中加入图标必须调用该类型库,图标请参考T-CODE：ICON
   SELECTION-SCREEN PUSHBUTTON /1(20) PUBU1 USER-COMMAND ABCD.
   SELECTION-SCREEN SKIP.&amp;quot;换行
   SELECTION-SCREEN PUSHBUTTON /10(25) PUBU2 USER-COMMAND ABCE. &amp;quot;位置从10开始
   AT SELECTION-SCREEN OUTPUT.
     MOVE &#39;CALL NEXT SCREEN&#39; TO PUBU1. &amp;quot;给PUBU1按钮赋值描述
     WRITE ICON_OKAY AS ICON TO PUBU2. &amp;quot;给PUBU2按钮添加图标，并且在给按钮赋值之前，否则将会把文字替换。
     CONCATENATE PUBU2 &#39;My Second Button&#39; INTO PUBU2 SEPARATED BY SPACE. &amp;quot;给第二个按钮添加赋值描述
   AT SELECTION-SCREEN.
    IF SSCRFIELDS-UCOMM = &#39;ABCD&#39;.
        PERFORM xxxx.  &amp;quot;调用子程序
    ENDIF.
 &amp;lt;7&amp;gt; 在工具栏上新增一个功能按钮
    SELECTION-SCREEN FUNCTION KEY n.
      该按钮的定义保存在系统结构体SSCRFIELDS中，n为一个整数序数最大至5。
    当n等于1时，其按钮描述保存在字段SSCRFIELDS-FUNCTXT_01中，其按钮对象命名为
    &amp;quot;FC01&amp;quot;,保存在字段SSCRFIELDS-UCOMM中。
  实例：
     TYPE-POOLS ICON. &amp;quot;Program Icon Library
     TABLES SSCRFIELDS.
     DATA functxt TYPE SMP_DYNTXT. &amp;quot;SMP_DYNTXT(菜单制作器:动态文本的程序接口)
     PARAMETERS: p_carrid TYPE s_carr_id,
                 p_cityfr TYPE s_from_cit.
     SELECTION-SCREEN: FUNCTION KEY 1,
                       FUNCTION KEY 2.
     INITIALIZATION. &amp;quot;屏幕初始化
       functxt-icon_id   = icon_ws_plane.  &amp;quot;文本字段中的图标（替换显示，别名） 
       functxt-quickinfo = &#39;Preselected Carrier&#39;.  &amp;quot;菜单制作器：信息文本 (4.0)，滑鼠移去过去显示的信息TIP
       functxt-icon_text = &#39;LH&#39;.  &amp;quot;菜单制作器：图标文本 (4.0)，菜单名称
       sscrfields-functxt_01 = functxt.
       functxt-icon_text = &#39;UA&#39;.
       sscrfields-functxt_02 = functxt.
     AT SELECTION-SCREEN.
       CASE SSCRFIELDS-UCOMM.
          WHEN &#39;FC01&#39;.
            p_carrid = &#39;LH&#39;.
            p_cityfr = &#39;Frankfurt&#39;.
          WHEN &#39;FC02&#39;.
            p_carrid = &#39;UA&#39;.
            p_cityfr = &#39;Chicago&#39;.
       ENDCASE.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;字段符号-filed-symbols&#34;&gt;字段符号：filed-symbols&lt;/h2&gt;

&lt;h2 id=&#34;内表操作&#34;&gt;内表操作&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;【增删改】
  &amp;lt;1&amp;gt; Loop AT循环(sy-tabix:索引号)
     LOOP AT itab {INTO wa}|{ASSIGNING &amp;lt;fs&amp;gt; [CASTING]} | {TRANSPORTING NO FILDS} 
        [[USING KEY key_name] [FROM idx1] [TO idx2] [WHERE log_exp|(cond_syntax)]].
     ENDLOOP.
  &amp;lt;2&amp;gt; INSERT &amp;lt;wa&amp;gt; INTO TABLE &amp;lt;itab&amp;gt;.[单条]
      INSERT &amp;lt;wa&amp;gt; INTO &amp;lt;itab&amp;gt; INDEX &amp;lt;idx&amp;gt;.[索引]
      INSERT LINES OF &amp;lt;itab&amp;gt; [FROM &amp;lt;n1&amp;gt;] [TO &amp;lt;n2&amp;gt;] INTO TABLE &amp;lt;itab&amp;gt;.[批量插入]
      APPEND &amp;lt;wa&amp;gt; TO &amp;lt;itab&amp;gt;.
      APPEND LINES OF &amp;lt;itab1&amp;gt; [FROM&amp;lt;n1&amp;gt;] [TO&amp;lt;n2&amp;gt;] TO &amp;lt;itab2&amp;gt;.
  &amp;lt;3&amp;gt; READ TABLE &amp;lt;itab&amp;gt; WITH KEY {&amp;lt;k1&amp;gt;=&amp;lt;f1&amp;gt;...[BINARY SEARCH]} INTO &amp;lt;wa&amp;gt;}
      [COMPARING &amp;lt;f1&amp;gt;&amp;lt;f2&amp;gt;...|ALL FIELDS]  [TRANSPORTING &amp;lt;f1&amp;gt; &amp;lt;f2&amp;gt; ...|ALL FIELDS
                                          |NO FIELDS] | ASSIGNING &amp;lt;fs&amp;gt;.
   COMPARING:根据关键字读取指定的单行与工作区&amp;lt;wa&amp;gt;中的相应组件进行比较。内容相同SY-SUBRC=0
  &amp;lt;4&amp;gt; MODIFY itab1.
      MODIFY itab INDEX idx FROM &amp;lt;wa&amp;gt; [TRANSPORTING &amp;lt;f1&amp;gt; &amp;lt;f2&amp;gt; ...].
      MODIFY TABLE &amp;lt;itab&amp;gt; FROM &amp;lt;wa&amp;gt; [TRANSPORTING &amp;lt;f1&amp;gt; &amp;lt;f2&amp;gt;...].[修改单条]
      MODIFY &amp;lt;itab&amp;gt; FROM &amp;lt;wa&amp;gt; TRANSPORTING &amp;lt;f1&amp;gt; &amp;lt;f2&amp;gt; ... WHERE &amp;lt;cond&amp;gt;.[修改多条]

      UPDATE dbtab SET f1=g1 ... fi=gi WHERE &amp;lt;con&amp;gt;.
  &amp;lt;5&amp;gt; DELETE TABLE &amp;lt;itab&amp;gt; FROM &amp;lt;wa&amp;gt; [USING KEY key_name].[删除单条]
      DELETE TABLE &amp;lt;itab&amp;gt; WITH TABLE KEY &amp;lt;k1&amp;gt;=&amp;lt;f1&amp;gt;.. .
      DELETE &amp;lt;itab&amp;gt; WHERE &amp;lt;cond&amp;gt;.[删除多行]
      DELETE &amp;lt;itab&amp;gt; [INDEX &amp;lt;idx&amp;gt;].
      删除重复
  (1)SORT record_tab. //首先进行排序处理
      (2)DELETE ADJACENT DUPLICATES ENTRIES FROM itab [USING KEY key_name] 
                                         [COMPARING K1 K2...] [ALL FIELDS].//删除
  &amp;lt;6&amp;gt; COLLECT &amp;lt;wa&amp;gt; INTO &amp;lt;itab&amp;gt;.
  &amp;lt;7&amp;gt; 第二索引
     UNIQUE KEY.唯一升序第二索引
     NON-UNIQUE KEY.非唯一升序第二索引
     通过第二索引在无法使用主键时，可以加快大量处理数据的速度。
【查】
  SELECT SINGLE ... INTO [CORRESPONDING FIELDS OF] &amp;lt;wa&amp;gt; WHERE ...
  SELECT ... INTO|APPENDING CORRESPONDING FIELDS OF TABLE &amp;lt;itab&amp;gt;...
  RANG条件内.表：
    RANGES sel FOR obj [OCCURS n].
    SELECT-OPTIONS selcrit FOR {dobj|(name)}.
  FOR ALLENTRIES:
    1:会自动删除重复行   2:WHERE后还有其他条件，会忽略后续条件
  表连接：
    INNER JOIN、LEFT OUTER JOIN.
【SAP锁】
  通用数据库表锁函数：ENQUEUE_E_TABLE、DEQUEUE_E_TABLE、DEQUEUE_ALL
  特定数据库表函数：ENQUEUE_&amp;lt;LOCK OBJ&amp;gt;、DEQUEUE_&amp;lt;LOCK OBJ&amp;gt;
  自定义锁对象：EZ_/EY_命名
  S:共享锁     E:可重入的排他锁     X:排他锁
  1、在SE11里创建锁对象，自定义的锁对象都必须以EZ或者EY开头来命名。一个锁对象里只包含一个
     PRIMARY TABLE，可以包含若干个SECONDARY TABLE，锁的模式有三种：E，S，X。
   模式E：当更改数据的时候设置为此模式。   (Shared lock, read lock) 【一般使用E】
   模式S：本身不需更改数据，但是希望显示的数据不被别人更改 (Exclusive lock, write lock)
   模式X：和E类似，但是不允许累加，完全独占。 
          (Exclusive lock, extended write lock, cannot be cumulated)
  2、上锁的一般步骤
      先上锁，上锁成功之后，从数据库取数据，然后更改数据，接着更新到数据库，最后解锁。
   按照这个步骤，才能保证更改完全运行在锁的保护机制下。
  3、上锁与解锁
   ENQUEUE_&amp;lt;lock object的名字&amp;gt; 对象 EZZSOPR0032 要求的锁定
   DEQUEUE_&amp;lt;lock object的名字&amp;gt; 释放对象 EZZSOPR0032 的锁定
     有些情况下，程序中设置成功的逻辑锁会隐式的自己解锁。比如说程序结束发生的时候
  （MESSAGE TYPE为A或者X的时候），使用语句LEAVE PROGRAM，LEAVE TO TRANSACTION，或者在
   命令行输入/n回车以后。使用DEQUEUE FUNCTION MODULE来解锁的时候，不会产生EXCEPTION。
   要解开你在程序中创建的所有的逻辑锁，可以用FM：DEQUEUE_ALL.
【事务处理】
  COMMIT WORK.         异步更新。
  COMMIT WORK AND WAIT.同步跟新，执行结果可通过sy-subrc判断是否提交成功。
  ROLLBACK WORK.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;message-se91&#34;&gt;MESSAGE ：SE91&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;1&amp;gt; 消息类的操作
  使用T-CODE:SE91对Message定义，还能够对Message进行创建，修改及删除等维护操作。
  Message Short Text字段为类描述，可以定义输入参数&amp;amp;，如&amp;quot;1&amp;amp;2&amp;amp;3&amp;amp;&amp;quot;表示有三个输入参数。
  Message共分以下几种类型：E:错误、W:警告、I：信息、A：异常中止、S:成功。
  引用语法为: Message W000(00)，表示调用&#39;00&#39;类的&#39;000&#39; Message类型为警告。
    EX: Message W001(ZTEST) WITH &#39;P1&#39; &#39;P2&#39; &#39;P3&#39;.
1. 消息ID MESSAGE e001(00) WITH &#39;12345678&#39;. //利用定义的参数
2. MESSAGE &#39;XXXXXXXXXX&#39; TYPE &#39;X&#39;.          //直接附加消息
3. MESSAGE s001(00) WITH &#39;No data&#39; DISPLAY LIKE &#39;E&#39;.
   EXIT.                                   //Screen 界面查询数据无，则返回原界面
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;alv常使用的bapi&#34;&gt;ALV常使用的BAPI&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;在ALV开发中有两个重要的对象：LAYOUT和FIELDCAT,它们同属于类型池SLIS。
   LAYOUT主要用于设置ALV的输出格式，如输出字段的颜色、表格中的线条等；
   FIELDCAT主要用于ALV结构定义，包括具体字段的名称、类型、格式等属性.
常使用的开发类:
   &amp;lt;1&amp;gt; REUSE_ALV_FIENDCATALOG_MERGE：根据内表结构返回FIELDCAT字段结构信息.
   &amp;lt;2&amp;gt; REUSE_ALV_GRID_DISPLAY/REUSE_ALV_LIST_DISPLAY：输出ALV报表，定义其为GRID模式还是LIST模式。参数结构一样。
   &amp;lt;3&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;alv-报表的表头字段显示设置&#34;&gt;ALV 报表的表头字段显示设置&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;call function &#39;LVC_FIELDCATALOG_MERGE&#39;
exporting
  I_BUFFER_ACTIVE        = I_BUFFER_ACTIVE
  I_structure_name       = &#39;ZALV_FEED&#39; &amp;quot;ALV需要显示的字段结构
  I_CLIENT_NEVER_DISPLAY = &#39;X&#39;
  I_BYPASSING_BUFFER     = I_BYPASSING_BUFFER
  I_INTERNAL_TABNAME     = I_INTERNAL_TABNAME
    changing
      ct_fieldcat         = lt_fieldcat  &amp;quot;对应ALV显示的字段结构
exceptions
  inconsistent_interface = 1
  program_error          = 2.
 可以通过loop对相应的ALV字段描述进行自定义设置
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;layout-字段&#34;&gt;Layout 字段&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;DATA wa_alv_field TYPE SLIS_LAYOUT_ALV.
LAYOUT主要用于设置ALV的输出格式，如输出字段的颜色、表格中的线条等；
  0.COLTAB_fieldname type slis_fieldname: 设置单元格颜色
  1.EDIT：设置ALV是否为可编辑模式。
  2.COLWIDTH_OPTIMIZE：将ALV字段宽度设置为最优化，按实际输出内容宽度自动匹配。
  3.NO_VLINE：输出ALV表格不显示垂直格式。
  4.NO_ULINE_HS：输出ALV表格不显示水平格线。
  5.INFO_FIELDNAME：设置颜色属性。
  6.KEY_HOTSPOT：设置关键字段热点。
  7.NO_COLNAME：是否显示字段名。
  8.ZEBRA：使ALV表格按斑马线间隔条纹方式显示，以便显示效果更有美观。
  9.BOX_FIELDNAME：设置ALV表格是否显示选择按钮字段。
  10.f2code  like   sy-ucomn. gs_layout-f2code=&#39;&amp;amp;ETA&#39;[双击时触发的funcode]
  11.INFO_FIELDNAME：用于设置ALV输出报表每一行的颜色，其参数为输出内表的字段名称，
    要注意的是使用该属性需要同时在内表中定义一个与该参数所定义字段名相同的字段，例如：
  LAYOUT-INFO_FIELDNAME = &#39;COLOR&#39;.倘若其数据输出内表名为LT_OUT,则需要在该内表增加一字段
  “COLOR”，并为其内表每行复制，颜色参数范围C000~C999，例如：LT_OUT-COLOR = &#39;C012&#39;.

【颜色】
  行颜色:gs_layout-&amp;lt;info_fieldname&amp;gt; = &#39;COLOR&#39;
  列颜色:gt_fieldcat-emphasize = &#39;C510&#39;.[1：C固定，2：颜色值0~7,3：高亮0、1(X)，
                                         4：颜色反转，0、1]
  单元格颜色:gs_layout-&amp;lt;coltab_fieldname&amp;gt;=&#39;COLORTABLE&#39;.
【可编辑】
  整体可编辑：gs_layout-edit = &#39;X&#39; 
  某列可编辑：gt_fieldcat-edit = &#39;X&#39;
  单元格可编辑：
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;9-fieldcatalog-字段&#34;&gt;9.Fieldcatalog 字段&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;FIELDCAT主要用于ALV结构定义，包括具体字段的名称、类型、格式等属性.
  DATA lt_alv_fieldcat TYPE SLIS_T_FIELDCAT_ALV WITH HEADER LINE.
　　1.KEY：将定义字段设置为KEY值。
    2.ICON：将定义字段以ICON的形式显示。
    3.CHECKBOX：将定义字段以CHECKBOX的形式显示。
    4.JUST：定义字段对齐方式(R)RIGHT、(L)LEFT、(C)CENTER。
    5.IZERO：将定义字段以前导&amp;quot;0&amp;quot;的形式显示。
    6.NO_SIGN：将定义字段符号设置为不显示。
    7.NO_ZERO：定义字段是否显示。
    8.EMPHASIZE：设置字段的颜色。
    9.DO_SUM：对字段进行汇总。
    10.SELTEXT_L/M/S：设置字段名称描述长/中/短。
    11.DDICTXT：设置字段显示字符串。
    12.HOTSPOT：设置字段是否有热点(热点字段显示有下划线)。
    13.NO_OUT: 隐藏不需要的字段(NO_OUT = &#39;X&#39;)。
    14.EDIT(1) type c: 是否可编辑
    15:COL_POS like sy-cucol: 列输出位置
    16:FIX_COLUMN(1) type c: 列固定不滚动，颜色不会发生变化
    17:convexit : 设置转换规则，对应于Domain中的转换规则    

fieldname  type slis_fieldname    (列显示的设置)
cfieldname type slis_fieldname  (金额字段所参照的货币单位字段名)
ctabname   type slis_tabname      (金额字段所参照的货币单位表名)
qfieldname type slis_fieldname  (数量字段所参照的货币单位字段名)
qtabname   type slis_tabname      (数量字段所参照的货币单位表名)

自定义FIELDCAT字段结构：
  &amp;quot;定义宏来设置FIELDAT属性 &amp;amp;1 &amp;amp;2 &amp;amp;3分别为参数
    DEFINE fieldcatset.
      lt_alv_fieldcat-REF_TABNAME =&#39;LSPFLI&#39;.
      lt_alv_fieldcat-FIELDNAME = &amp;amp;1.
      lt_alv_fieldcat-SELTEXT_L = &amp;amp;2.
      lt_alv_fieldcat-COL_POS = &amp;amp;3.
      APPEND lt_alv_fieldcat.
    END-OF-DEFINITION.
    fieldcatset &#39;CARRID&#39; &#39;航线承运人&#39; SY-TABIX.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;10-单元格中的数据被修改后-将alv单元格中的数据立即刷新到abap对应的内表中&#34;&gt;10.单元格中的数据被修改后，将ALV单元格中的数据立即刷新到ABAP对应的内表中&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;方法一：通过对REUSE_ALV_GRID_DISPLAY函数参数i_grid_settings-edt_cll_cb进行设置：
i_grid_settings-edt_cll_cb  = &#39;X&#39; .
CALL FUNCTION &#39;REUSE_ALV_GRID_DISPLAY&#39;
EXPORTING i_grid_settings = i_grid_settings
方法二：通过函数参数I_CALLBACK_USER_COMMAND指定的回调Form的参数slis_selfield进行设置：
FORM user_command USING ucomm LIKE sy-ucommselfield selfield TYPE slis_selfield.
    selfield-refresh = &#39;X&#39;.
  CASE ucomm.
    WHEN &#39;UPDATE&#39;.
    PERFORM frm_update.
  ENDCASE.
ENDFORM. 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;11-自定义按钮使用后刷新alv&#34;&gt;11 自定义按钮使用后刷新ALV&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt; form frm_user_command using r_ucomm     like sy-ucomm
                        rs_selfield type slis_selfield.
  case r_ucomm.
   when &#39;PROFIT&#39;.
      perform frm_cycle_count_profit.
   when others.
  endcase.
     rs_selfield-refresh = &#39;X&#39;.
 endform.                    &amp;quot;frm_user_command
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;12-设置工具导航栏-gui-status&#34;&gt;12 设置工具导航栏 GUI Status&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;GUI Status参数设置共包括3个部分：
  1.菜单栏(Menu Bar)：用于设置主菜单选项。
  2.应用工具条(Application ToolBar)：用于设置应用工具栏按钮，包括按钮名称、按钮描述、及按钮所对的ICON图标。
  3.功能键(Function Key)：为按钮分配功能键代码，包括系统标题按钮(如返回、退出、关闭等)及通过Application ToolBar所定义的客制化按钮。
  4. 对于定义的按钮，我们可以通过系统变量SY-UCOMM来获取它的功能代码。
    AT USER-COMMAND.   &amp;quot;当单击某个按钮时，触发该事件
      CASE sy-ucomm.  &amp;quot;获取所操作按钮的功能代码(FUNCTION Code)
  5.调用显示，应用于START-OF-SELECTION事件
     SET PF-STATUS &amp;lt;STATUS_NAME&amp;gt;.
     不显示某些按钮：SET PF-STATUS &amp;lt;STATUS_NAME&amp;gt; EXCLUDING &amp;lt;extab&amp;gt;.
 6.在ALV函数中使用
  call function &#39;REUSE_ALV_GRID_DISPLAY_LVC&#39;
    exporting
      i_callback_program       = sy-repid 
      i_callback_pf_status_set = &#39;FRM_SET_STATUS&#39;
      i_callback_user_command  = &#39;FRM_USER_COMMAND&#39;
      is_layout_lvc            = lw_layout
      it_fieldcat_lvc          = gt_fieldcat
      i_default                = &#39;X&#39;
      i_save                   = &#39;X&#39;
   tables
      t_outtab                 = gt_alv_pi_diffs
   exceptions
      program_error            = 1.

  form frm_set_status using extab type slis_t_extab.
     data: ls_slis_extab type slis_extab.
      SET PF-STATUS &amp;lt;STATUS_NAME&amp;gt;.
  endform.                    &amp;quot;frm_set_status
GUI TITLE设置：
    GUI TITLE 用于定义Report标题栏内容.
  定义：
    Create--&amp;gt;GUI Titles：可以输入&amp;amp;符号作为Title,当程序运行时对其填充动态文本。
  在程序中调用：
    SET TITLEBAR &#39;TITLE_BAR&#39; WITH SY-DATUM &#39;IFENER&#39; &#39;BAR TEST&#39;.&amp;quot;设置TITLEBAR，并赋参数列表
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;13-oo-alv&#34;&gt;13. OO ALV&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;相关类：
  CL_GUI_CUSTOM_CONTAINER   ：用户自己定义控件区域
  CL_GUI_DOCKING_CONTAINER  : 动态创建容器，不需要在创建时绑定到预先绘制好的自定义控件中
  CL_GUI_SPLITTER_CONTAINER ：可在同一屏幕创建多个ALV显示
  CL_GUI_ALV_GRID           ：ALV控制类

  DATA : obj_wcl_container TYPE REF TO cl_gui_custom_container, &amp;quot;控制容器类
         obj_wcl_alv TYPE REF TO cl_gui_alv_grid . &amp;quot;ALV控制类
  DATA GS_LAYOUT1 TYPE LVC_S_LAYO. &amp;quot;布局结构
  DATA GT_FIELDCAT TYPE LVC_T_FCAT. &amp;quot;存放字段目录的内表
  DATA GS_FIELDCAT TYPE LVC_S_FCAT.
  DATA lt_exclude TYPE ui_functions. &amp;quot;alv不需要的图标按钮
1、控制区域、容器、Grid关系
   先在屏幕绘制一个用户自定义控件区域，然后以自定义区域为基础创建 CL_GUI_CUSTOM_CONTAINER
 容器实例,最后以此容器实例来创建 CL_GUI_ALV_GRID实例。
    DATA : obj_wcl_container TYPE REF TO cl_gui_custom_container, &amp;quot;控制容器类
           obj_wcl_alv TYPE REF TO cl_gui_alv_grid . &amp;quot;ALV控制类
    IF obj_wcl_alv IS INITIAL.
       CREATE OBJECT obj_wcl_container
          EXPORTING
             container_name  =  &#39;OBJ_WCL_CONTAINER&#39;.
       CREATE OBJECT obj_wcl_alv
          EXPORTING
             i_parent  = obj_wcl_container.
2、给ALV对象注册事件
  (1) HANDLE_TOOLBAR:这个事件用于给ALV加自定义工具条按钮。
  (2) HANDLE_CLICK:用于给ALV点击其中一行后处理代码段。
  (3) HANDLE_COMMAND:事件用于接收用户按了自定义按钮后，触发的代码段。
  (4) HANDLE_DOUBLE_CLICK：双击事件
  (5) 
  事件的使用：
    &amp;lt;1&amp;gt; 定义事件方法
    &amp;lt;2&amp;gt; 指定事件的执行方法代码
    &amp;lt;3&amp;gt; 事件变量实例化
    &amp;lt;4&amp;gt; 把事件指定到ALV控制中(注册事件)

    CREATE OBJECT event_receiver.
    SET HANDLER event_receiver -&amp;gt; handle_double_click FOR obj_wcl_alv.
3、CL_GUI_ALV_GRID重要方法
  *-----显示ALV 
     CALL METHOD obj_wcl_alv-&amp;gt;set_table_for_first_display 
        EXPORTING 
           is_variant                    = ls_variant   :指定布局变式
           is_layout                     = ls_layout 
           i_save                        = &#39;A&#39;          :保存表格布局
           it_toolbar_excluding          = lt_exclude 
        CHANGING 
           it_outtab                     = gt_list[]    :需要显示的内表数据
           it_fieldcatalog               = lt_fieldcat  :结构字段
        EXCEPTIONS 
           invalid_parameter_combination = 1 
           program_error                 = 2 
           too_many_lines                = 3 
           OTHERS                        = 4.

   ENDFORM.                    &amp;quot; FRM_ALV_DISPLAY

  XXX -&amp;gt; REFRESH_TABLE_DISPLAY.
    IS_STABLE : 刷新的稳定性，就是滚动条保持不动
    I_SOFT_REFRESH:  软刷新，临时给ALV创建的合计，排序，等保持不变
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;14-前导零问题&#34;&gt;14.前导零问题&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;加上p_in的前导零
  FORM add_zero  CHANGING p_in.
CALL FUNCTION &#39;CONVERSION_EXIT_ALPHA_INPUT&#39;
  EXPORTING
    input  = p_in
    IMPORTING
      output = p_in.
 ENDFORM.
去除p_out的前导零
  FORM del_zero CHANGING p_out.
    CALL FUNCTION &#39;CONVERSION_EXIT_ALPHA_OUTPUT&#39;
    EXPORTING
      input  = p_out
    IMPORTING
     output = p_out.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;15-hash-table-sort-table-standy-table&#34;&gt;15.Hash table, sort table, standy table&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;   对于排序内表，不要使用append，append lines附加数据，使用insert、insert lines向
排序内表中插入数据
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;16-search-help-的创建&#34;&gt;16.search help 的创建&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;PARAMETERS p_cur TYPE XXX VALUE CHECK .
PROCESS ON VALUE-REQUEST ， AT SELECTION-SCREEN ON VALUE-REQUEST。
在屏幕的 ON VALUE-REQUEST 事件里可以通过下面几个函数来创建搜索帮助：
  F4IF_ FIELD _VALUE_REQUEST ： 函数的作用是在运行时，可以动态的为某个屏幕字段指定 
     Search Help ，这个被引用的 Help 来自某个表（或结构）字段上绑定的 Help
  F4IF_ INT_TABLE _VALUE_REQUEST : 在程序运行时， 将某个内表动态的用作 Search help 的
     数据来源,即使用该函数可以将某个内表转换为 Search help ，可实现联动效果
  TR_F4_HELP ： 简单实现 Search Help ，数据来源于内表。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;17-sql-语句的执行顺序&#34;&gt;17. SQL 语句的执行顺序&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;书写顺序：SELECT[DISTINCT]--&amp;gt;FROM--&amp;gt;WHERE--&amp;gt;GROUP BY--&amp;gt;HAVING--&amp;gt;UNION--&amp;gt;ORDER BY
其执行顺序为：FROM--&amp;gt;WHERE--&amp;gt;GROUP BY--&amp;gt;HAVING--&amp;gt;SELECT--&amp;gt;DISTINCT--&amp;gt;UNION-&amp;gt;ORDER BY
1、FROM 才是 SQL 语句执行的第一步，并非 SELECT 
2、SELECT 是在大部分语句执行了之后才执行的，严格的说是在 FROM 和 GROUP BY 之后执行的。
3、无论在语法上还是在执行顺序上， UNION 总是排在在 ORDER BY 之前。
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;open-sql&#34;&gt;Open SQL&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;focus&#34;&gt;Focus&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;1. 多表的结合的查询，首先进行各自的关键字查询，然后进行表与表转换可以提升效率
2. 表相应字段非关键字时，寻找有该关键字的相对应的关联表进行查询并合并表数据
3. binary search 和 sort 进行使用时注意sort的关键字与binary search 保持统一
4. MODIFY itab1 INDEX sy-tabix.进行修改时最好定义变量记录sy-tabix.
5. inner join 和 left outer join 的连接条件最好都是关键字.
6. 双层loop循环时，第二个内部表定义为SORTED TABLE会大大的提高处理速度
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>报表开发(二)</title>
      <link>https://coldinfire.github.io/2018/ABAPTable2/</link>
      <pubDate>Mon, 03 Sep 2018 17:20:58 +0800</pubDate>
      
      <guid>https://coldinfire.github.io/2018/ABAPTable2/</guid>
      <description>

&lt;h2 id=&#34;执行程序的使用范围-报表事件&#34;&gt;执行程序的使用范围，报表事件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;LOAD-OF-PROGRAM.
INITIALIZATION.          （Before display the selection screen）
  AT-SELECTION SCREEN ON fiedl.（在PAI事件结束后执行，进行校验和检查输入值）
  AT SELECTION-SCREEN ON VALUE-REQUEST FOR Z_XXX.
AT SELECTION-SCREEN. //After enter the option data check
   PERFORM check_input.
START-OF-SELECTION.//Begin the main programer
  xxxx
END-OF-SELECTION.
Interactive Eventrs. (User for interactive reporting)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;报表程序大体逻辑结构&#34;&gt;报表程序大体逻辑结构&lt;/h2&gt;

&lt;p&gt;​   &lt;strong&gt;抬  头:&lt;/strong&gt; 报表的主要信息(抬头信息)&lt;/p&gt;

&lt;p&gt;​   &lt;strong&gt;行项目:&lt;/strong&gt; 查询出的每行记录信息&lt;/p&gt;

&lt;p&gt;​   &lt;strong&gt;明  细:&lt;/strong&gt; 每个行项目出关键字外其他明细内容&lt;/p&gt;

&lt;h2 id=&#34;字段符号&#34;&gt;字段符号&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt; FIELD-SYMBOLS &lt;FS&gt; LIKE structure.&lt;/p&gt;

&lt;p&gt;​    &lt;1&gt; FS必须和某个变量，结构或者内表绑定后才能使用，这点和C语言里的指针
​     （在ABAP里最接近指针的是TYPE REF TO）不同，在使用FS前必须分配给某个变量，不然会发生
​      FS未分配的运行时错误。如果LOOP内表时ASSIGNING到FS，之后假如有REFRESH内表的操作的话，
​      FS也会再次回到初始未被ASSIGN的状态，这时如果使用FS也会发生FS未分配的RUNTIME ERROR。
​    &lt;2&gt; ASSIGN structure TO &lt;fs&gt;:将某个内存区域分配给字段符号，这样字段符号就代表了该内存
​      区域，即该内存区域别名字段符号可以看作仅是已经被解引用的指针，即某个变量的别名。
  ASSIGN &lt;Val&gt; TO &lt;fs&gt;: 将某个内存区域分配给字段符号，这样字段符号就代表了该内存区域。
  UNASSIGN: 该语句是初始化&lt;FS&gt;字段符号，执行后字段符号将不再引用内存区域，
​            &lt;fs&gt; is assigned返回假。
  CLEAR: 与UNASSIGN不同的是，只有一个作用就是初始化它所指向的内存区域，而不是解除分配。
3.2 LOOP内表INTO结构（工作区）和LOOP内表ASSIGNING&amp;lt;结构&amp;gt;的比较
​    LOOP内表INTO结构时，系统会把先把当前行的数据复制到结构，如果结构的值改了，还需要使用
  MODIFY语句把更改后的值传回内表。也就是说，结构是内表里的数据的一个副本，操作这个副本不会
  影响内表里的数据。为了提高效率，可以使用FS，FS直接指向内表数据，省去了复制数据到结构的过程
  修改FS的值也就是相当于直接修改内表里的数据，不需要再使用MODIFY语句。
3.3 READ TABLE内表
3.4 ASSIGN隐式强转
TYPES: BEGIN OF t_date,
​    year(4) TYPE  n,
​        month(2) TYPE n,
​    day(2) TYPE n,
  END OF t_date.
FIELD-SYMBOLS &lt;fs&gt; TYPE t_date.&amp;ldquo;将&lt;fs&gt;定义成了具体限定类型
ASSIGN sy-datum TO &lt;fs&gt; CASTING. &amp;ldquo;后面没有指定具体类型，所以使用定义时的类型进行隐式转换
3.5 ASSIGN显示强转
  DATA txt(8) TYPE c VALUE &amp;lsquo;19980606&amp;rsquo;.
  FIELD-SYMBOLS &lt;fs&gt;.
  ASSIGN txt TO &lt;fs&gt; CASTING TYPE d.&amp;ldquo;由于定义时未指定具体的类型，所以这里需要显示强转
3.6 动态引用，通过循环赋值给定义的字段符号，对其进行修改，等于直接修改原内表。
  field-symbols:&lt;l_shortageqty&gt; type mng01.
  loop at &lt;dyn_table&gt; assigning &lt;dyn_wa&gt;.
​    assign component &amp;lsquo;SHORTAGEQTY&amp;rsquo; of structure &lt;dyn_wa&gt; to &lt;l_shortageqty&gt;.
​    &lt;l_shortageqty&gt; = &lt;l_shortageqty&gt; - &lt;l_fvalue&gt;.&lt;/p&gt;

&lt;h2 id=&#34;选择屏幕&#34;&gt;选择屏幕&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/foxting/archive/2012/07/01/2572243.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;引用链接&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;1&amp;gt;SELECT-SCREEN 框架结构
  SELECT-SCREEN语句用于创建屏幕的框架结构,主要包括屏幕元素的创建、子屏幕的创建等。
  定义屏幕对象：
    SELECTION-SCREEN BEGIN OF SCREEN src.
      .......
    SELECTION-SCREEN END OF SCREEN src.
    该语法用于定义一个INCLUDE SUREEN，可通过CALL方法在Report程序中引用。
   CALL SCREEN &amp;lt;num&amp;gt; STARTING AT [1 2] ENDING AT [1 2].
   参数可以将所定义屏幕窗体作为一个新的对话框窗体来引用，并指定期创建的具体大小及位置。
  注意：当从一个主屏幕中来调用其程序中的另一窗体时，必须使用CALL SELECTION-SCREEN方法.
  定义屏幕块：
    SELECTION-SCREEN BEGIN OF BLOCK block.
      ......
    SELECTION-SCREEN END OF BLOCK.
    该语法在屏幕中定义一个BLOCK，其扩展语法包括：
      ...WITH FRAME：创建一个框架
      ...TITLE title：创建一个带标题的框架。
      ...NO INTERVALS：所创建的框架中限制SELECT只有一个输入项。 
 其他元素：
  SELECTION-SCREEN INCLUDE BLOCKS &amp;lt;block1&amp;gt;.  调用已存在屏幕元素
  SELECTION-SCREEN ULINE.  划出横线，必须用在BLOCK中才能生效。
  SELECTION-SCREEN SKIP &amp;lt;n&amp;gt;.  在BLOCK中产生换行&amp;lt;n&amp;gt;。
  SELECTION-SCREEN POSITION &amp;lt;pos&amp;gt;. 在BLOCK中产生空格。
  SELECTION-SCREEN BEGIN OF LINE.
    ......
  SELECTION-SCREEN END OF LINE. 将所生成的屏幕元素控制在一行.
&amp;lt;2&amp;gt;PARAMETERS 单值输入
  PARAMETERS 参照数据字典具体字段或者自定义数据类型创建单值文本输入域以及单选/复选框等：
  PARAMETERS: &amp;lt;P_1&amp;gt; LIKE &amp;lt;field&amp;gt;    &amp;quot;文本域
            TYPE AS CHECKBOX.       &amp;quot;复选框
            RADIOBUTTON GROUP GRP1, &amp;quot;单选域 
            P2 RADIOBUTTON GROUP GRP1 DEFAULT &#39;X&#39;,  &amp;quot;默认选中 ”X“
            P3 RADIOBUTTON GROUP GRP1. &amp;quot;GRP1单选组
  默认值：
    ...DEFAULT f:定义默认值。
    ...TYPE type:参照某一类型对象定义PARAMETERS。
    ...DECIMALS dec：定义小数位，对输入参数自动格式化，该语法只对P类型有效(参数某一类型定义关键字TYPE)。 
    ...LIKE g：參照某一字典对象定义PARAMETERS。
    ...MEMORY ID pi：将PARAMETERS存储在SAP内存，参数名长度不能超过三位。
    ...NO-DISPLAY：将PARAMETERS设置为隐藏，不会的屏幕上输出。
    ...LOWER CASE：输入值中不允许输入小写字符，否则会自动转换为大写。
    ...OBLIGATORY：限制该PARAMETERS为必填，否则会提示输入。
    ...AS CHECKBOX：创建CHECKBOX对象。
    ...RADIO BUTTON GROUP radi：创建（RADIO）单选框。
    ...VISIBLE LENGTH vlen：定义显示长度。
    ...USER-COMMAND ucom：为创建对象分配对象名，该值保存在内表中可供其它对象操作。
    ...AS LISTBOX VISIBLE LENGTH vlen：创建一个下拉框，并指定长度。
 下拉框实现：
  *定义一个下拉框对象，其可视数据长度一般比输出数据长度大2用于放置下拉图标
    PARAMETERS:P_LANG(20) AS LISTBOX VISIBLE LENGTH 22.
  *该变量用于记录下拉列表数值是否初始化，否则每次屏幕初始化都会重新加载重复数据
    DATA:INIT.
    AT SELECTION-SCREEN OUTPUT.
    PERFORM SETLIST.
  *子程序用于加载下拉框的数据
    FORM SETLIST.
      TYPE-POOLS VRM. 
      DATA MYVALUE TYPE VRM_VALUES WITH HEADER LINE.
    *对内表加载值
      MYVALUE-KEY = &#39;CHINESE&#39;. MYVALUE-TEXT = &#39;中国&#39;.    
      APPEND MYVALUE.
      MYVALUE-KEY = &#39;AMERICAN&#39;. MYVALUE-TEXT = &#39;美国&#39;.         
      APPEND MYVALUE.
      MYVALUE-KEY = &#39;ENGLISH&#39;. MYVALUE-TEXT = &#39;英国&#39;. 
      APPEND MYVALUE.
      MYVALUE-KEY = &#39;FRENCH&#39;. MYVALUE-TEXT = &#39;法国&#39;.   
      APPEND MYVALUE.
    IF INIT IS INITIAL.
        CALL FUNCTION &#39;VRM_SET_VALUES&#39; &amp;quot;调用函数对下拉框对象传递数据
          EXPORTING
            ID = &#39;P_LANG&#39; &amp;quot;下拉框对象名
            VALUES = MYVALUE[]  &amp;quot;下拉框中加载的数据
         EXCEPTIONS
           ID_ILLEGAL_NAME = 1
           OTHERS = 2.
    ENDIF.
    INIT = &#39;X&#39;. &amp;quot;记录初始化状态
  ENDFORM.
&amp;lt;3&amp;gt; SELECT-OPTIONS 输入域
  SELECT-OPTIONS 参照数据库字段来建立输入域，命名不能超过8位，最大输入长度为18位：
  SELECT-OPTIONS： &amp;lt;S_1&amp;gt; FOR &amp;lt;dbtab-ele&amp;gt;.... .
  内表结构：
    SIGN：I , E
    OPTION: EQ,NE,CP（模糊查询）,NP,GE,LT,LE,GT
    LOW : 范围较小值
    HIGH: 范围较大值
  默认值设定：
    ...DEFAULT g:定义单一默认值。
    ...DEFAULT g...OPTION  xxx ... SIGN s:定义含判断条件的单一默认值。
    ...DEFAULT g TO h:定义默认值的取值范围。
    ...DEFAULT g TO h ... OPTION op ... SIGN s:设置默认值的聚会范围及判断条件。
    ...MEMORY ID pid:将SELECT-OPTIONS分配参数名并存储在SAP内存，参数名长度不能超过三位。
    ...NO-DISPLAY:将SELECT-OPTIONS设置为隐藏，不会在屏幕上输出。
    ...LOWER CASE:输入值中不允许输入小写字符，否则会自动转换为大写。
    ...OBLIGATORY:限制该SELECT-OPTIONS为必须输入的项目，执行中系统会提示。
    ...NO-EXTENSION:限制该SELECT-OPTIONS只能输入一行数据，输入多行按钮（上图最右边按钮）被隐藏。
    ...VISIBLE LENGTH vlen:定义所显示数据的长度。
 &amp;lt;4&amp;gt; GOTO--&amp;gt;Text Elements   (TCode:SE32)
    前台界面显示的为PARAMETERS和SELECTION-OPTION定义的字段，不便于理解需。
    提供某一字段的完整名称以方便用户理解。
    GOTO --&amp;gt;Translation：可进行多语言显示的维护
  包含字段：
    Selection Texts：定义已存在并且激活的屏幕元素的名称。
    Text Symbols：实现自定义文本及符号,该文本使用对象为SELECTION-SCREEN，以三位字符表示(TEXT-001)。
         图标符号:可以在Text Symbols通过@符号来进行引用，如&amp;quot;@01@&amp;quot;,可通过程序RSTXICON查看所有的图标
 &amp;lt;5&amp;gt; 屏幕事件处理
   INITIALIZATION. &amp;quot;程序初始化事件，該事件在程序屏幕未顯示之前執行。對程序設置值及屏幕元素進行初始化設置.
   START-OF-SELECTION事件：该事件在单击按钮后触发。
   END-OF-SELECTION事件：该事件应用于所有数据处理完成，即START-OF-SELECTION相关执行事件执行完成。
    但输出屏幕还未显示之前，在实际的应用于一些执行结果的检验等。
   AT SELECTION-SCREEN：选择屏幕显示之后，用来响应回车，F8，F1，F4等事件。
    ...ON &amp;lt;field&amp;gt;：检查具体输入字段(SELECTION-OPTIONS或PARAMETERS)是否完整或正确。
    ...ON VALUE-REQUEST FOR &amp;lt;field low/high&amp;gt;：SELECT-OPTIONS按选择帮助&amp;lt;F4&amp;gt;键时触发该事件。
    ...ON HELP-REQUEST FOR &amp;lt;field low/high&amp;gt;：SELECTION-OPTIONS按选择帮助&amp;lt;F1&amp;gt;键时键发该事件。
    ...ON RADIOBUTTON GROUP &amp;lt;radio&amp;gt;：单选按钮事件，必须进行整体输入检查。
    ...ON BLOCK &amp;lt;block&amp;gt;：框架的触发事件（控制框架中的屏幕元素值的输入）。
    ...OUTPUT：用于屏幕输出时的各屏幕元素值的管控（PBO处理，在选择屏幕显示之前就被调用；响应屏幕上的事件，用户回车或F8后也被调用；通过modify screen可以修改选择屏幕字段）。
    ...ON EXIT-COMMAND：用于&amp;quot;BACK&amp;quot;,&amp;quot;CANCEL&amp;quot;,&amp;quot;EXIT&amp;quot;等事件。
 &amp;lt;6&amp;gt;屏幕内创建按钮
  SELECTION-SCREEN PUSHBUTTON [/n] &amp;lt;pos(len)&amp;gt; &amp;lt;name&amp;gt; USER-COMMAND &amp;lt;ucom&amp;gt; [MODIF ID &amp;lt;key&amp;gt;].
    [/n] :按钮初始时距离屏幕左边的位置
    &amp;lt;pos(len)&amp;gt;：PUSHBUTTON按钮在屏幕生成的位置与长度。
    &amp;lt;name&amp;gt;：PUSHBUTTON按钮的名称，给按钮赋值时要用到名字。
    &amp;lt;ucom&amp;gt;：必须指定的字符代码，当用户在选择屏幕上触发按钮时，&amp;lt;ucom&amp;gt;被输入到词典对象字段：
            SSCRFIELDS-UCOMM中，必须显式使用语句TABLES引用SSCRFIELDS。
  实例：  
   TABLES SSCRFIELDS.&amp;quot;引用词典对象
   INCLUDE:&amp;lt;icon&amp;gt;.  &amp;quot;按钮中加入图标必须调用该类型库,图标请参考T-CODE：ICON
   SELECTION-SCREEN PUSHBUTTON /1(20) PUBU1 USER-COMMAND ABCD.
   SELECTION-SCREEN SKIP.&amp;quot;换行
   SELECTION-SCREEN PUSHBUTTON /10(25) PUBU2 USER-COMMAND ABCE. &amp;quot;位置从10开始
   AT SELECTION-SCREEN OUTPUT.
     MOVE &#39;CALL NEXT SCREEN&#39; TO PUBU1. &amp;quot;给PUBU1按钮赋值描述
     WRITE ICON_OKAY AS ICON TO PUBU2. &amp;quot;给PUBU2按钮添加图标，并且在给按钮赋值之前，否则将会把文字替换。
     CONCATENATE PUBU2 &#39;My Second Button&#39; INTO PUBU2 SEPARATED BY SPACE. &amp;quot;给第二个按钮添加赋值描述
   AT SELECTION-SCREEN.
    IF SSCRFIELDS-UCOMM = &#39;ABCD&#39;.
        PERFORM xxxx.  &amp;quot;调用子程序
    ENDIF.
 &amp;lt;7&amp;gt; 在工具栏上新增一个功能按钮
    SELECTION-SCREEN FUNCTION KEY n.
      该按钮的定义保存在系统结构体SSCRFIELDS中，n为一个整数序数最大至5。
    当n等于1时，其按钮描述保存在字段SSCRFIELDS-FUNCTXT_01中，其按钮对象命名为
    &amp;quot;FC01&amp;quot;,保存在字段SSCRFIELDS-UCOMM中。
  实例：
     TYPE-POOLS ICON. &amp;quot;Program Icon Library
     TABLES SSCRFIELDS.
     DATA functxt TYPE SMP_DYNTXT. &amp;quot;SMP_DYNTXT(菜单制作器:动态文本的程序接口)
     PARAMETERS: p_carrid TYPE s_carr_id,
                 p_cityfr TYPE s_from_cit.
     SELECTION-SCREEN: FUNCTION KEY 1,
                       FUNCTION KEY 2.
     INITIALIZATION. &amp;quot;屏幕初始化
       functxt-icon_id   = icon_ws_plane.  &amp;quot;文本字段中的图标（替换显示，别名） 
       functxt-quickinfo = &#39;Preselected Carrier&#39;.  &amp;quot;菜单制作器：信息文本 (4.0)，滑鼠移去过去显示的信息TIP
       functxt-icon_text = &#39;LH&#39;.  &amp;quot;菜单制作器：图标文本 (4.0)，菜单名称
       sscrfields-functxt_01 = functxt.
       functxt-icon_text = &#39;UA&#39;.
       sscrfields-functxt_02 = functxt.
     AT SELECTION-SCREEN.
       CASE SSCRFIELDS-UCOMM.
          WHEN &#39;FC01&#39;.
            p_carrid = &#39;LH&#39;.
            p_cityfr = &#39;Frankfurt&#39;.
          WHEN &#39;FC02&#39;.
            p_carrid = &#39;UA&#39;.
            p_cityfr = &#39;Chicago&#39;.
       ENDCASE.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;字段符号-filed-symbols&#34;&gt;字段符号：filed-symbols&lt;/h2&gt;

&lt;h2 id=&#34;内表操作&#34;&gt;内表操作&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;【增删改】
  &amp;lt;1&amp;gt; Loop AT循环(sy-tabix:索引号)
     LOOP AT itab {INTO wa}|{ASSIGNING &amp;lt;fs&amp;gt; [CASTING]} | {TRANSPORTING NO FILDS} 
        [[USING KEY key_name] [FROM idx1] [TO idx2] [WHERE log_exp|(cond_syntax)]].
     ENDLOOP.
  &amp;lt;2&amp;gt; INSERT &amp;lt;wa&amp;gt; INTO TABLE &amp;lt;itab&amp;gt;.[单条]
      INSERT &amp;lt;wa&amp;gt; INTO &amp;lt;itab&amp;gt; INDEX &amp;lt;idx&amp;gt;.[索引]
      INSERT LINES OF &amp;lt;itab&amp;gt; [FROM &amp;lt;n1&amp;gt;] [TO &amp;lt;n2&amp;gt;] INTO TABLE &amp;lt;itab&amp;gt;.[批量插入]
      APPEND &amp;lt;wa&amp;gt; TO &amp;lt;itab&amp;gt;.
      APPEND LINES OF &amp;lt;itab1&amp;gt; [FROM&amp;lt;n1&amp;gt;] [TO&amp;lt;n2&amp;gt;] TO &amp;lt;itab2&amp;gt;.
  &amp;lt;3&amp;gt; READ TABLE &amp;lt;itab&amp;gt; WITH KEY {&amp;lt;k1&amp;gt;=&amp;lt;f1&amp;gt;...[BINARY SEARCH]} INTO &amp;lt;wa&amp;gt;}
      [COMPARING &amp;lt;f1&amp;gt;&amp;lt;f2&amp;gt;...|ALL FIELDS]  [TRANSPORTING &amp;lt;f1&amp;gt; &amp;lt;f2&amp;gt; ...|ALL FIELDS
                                          |NO FIELDS] | ASSIGNING &amp;lt;fs&amp;gt;.
   COMPARING:根据关键字读取指定的单行与工作区&amp;lt;wa&amp;gt;中的相应组件进行比较。内容相同SY-SUBRC=0
  &amp;lt;4&amp;gt; MODIFY itab1.
      MODIFY itab INDEX idx FROM &amp;lt;wa&amp;gt; [TRANSPORTING &amp;lt;f1&amp;gt; &amp;lt;f2&amp;gt; ...].
      MODIFY TABLE &amp;lt;itab&amp;gt; FROM &amp;lt;wa&amp;gt; [TRANSPORTING &amp;lt;f1&amp;gt; &amp;lt;f2&amp;gt;...].[修改单条]
      MODIFY &amp;lt;itab&amp;gt; FROM &amp;lt;wa&amp;gt; TRANSPORTING &amp;lt;f1&amp;gt; &amp;lt;f2&amp;gt; ... WHERE &amp;lt;cond&amp;gt;.[修改多条]

      UPDATE dbtab SET f1=g1 ... fi=gi WHERE &amp;lt;con&amp;gt;.
  &amp;lt;5&amp;gt; DELETE TABLE &amp;lt;itab&amp;gt; FROM &amp;lt;wa&amp;gt; [USING KEY key_name].[删除单条]
      DELETE TABLE &amp;lt;itab&amp;gt; WITH TABLE KEY &amp;lt;k1&amp;gt;=&amp;lt;f1&amp;gt;.. .
      DELETE &amp;lt;itab&amp;gt; WHERE &amp;lt;cond&amp;gt;.[删除多行]
      DELETE &amp;lt;itab&amp;gt; [INDEX &amp;lt;idx&amp;gt;].
      删除重复
  (1)SORT record_tab. //首先进行排序处理
      (2)DELETE ADJACENT DUPLICATES ENTRIES FROM itab [USING KEY key_name] 
                                         [COMPARING K1 K2...] [ALL FIELDS].//删除
  &amp;lt;6&amp;gt; COLLECT &amp;lt;wa&amp;gt; INTO &amp;lt;itab&amp;gt;.
  &amp;lt;7&amp;gt; 第二索引
     UNIQUE KEY.唯一升序第二索引
     NON-UNIQUE KEY.非唯一升序第二索引
     通过第二索引在无法使用主键时，可以加快大量处理数据的速度。
【查】
  SELECT SINGLE ... INTO [CORRESPONDING FIELDS OF] &amp;lt;wa&amp;gt; WHERE ...
  SELECT ... INTO|APPENDING CORRESPONDING FIELDS OF TABLE &amp;lt;itab&amp;gt;...
  RANG条件内.表：
    RANGES sel FOR obj [OCCURS n].
    SELECT-OPTIONS selcrit FOR {dobj|(name)}.
  FOR ALLENTRIES:
    1:会自动删除重复行   2:WHERE后还有其他条件，会忽略后续条件
  表连接：
    INNER JOIN、LEFT OUTER JOIN.
【SAP锁】
  通用数据库表锁函数：ENQUEUE_E_TABLE、DEQUEUE_E_TABLE、DEQUEUE_ALL
  特定数据库表函数：ENQUEUE_&amp;lt;LOCK OBJ&amp;gt;、DEQUEUE_&amp;lt;LOCK OBJ&amp;gt;
  自定义锁对象：EZ_/EY_命名
  S:共享锁     E:可重入的排他锁     X:排他锁
  1、在SE11里创建锁对象，自定义的锁对象都必须以EZ或者EY开头来命名。一个锁对象里只包含一个
     PRIMARY TABLE，可以包含若干个SECONDARY TABLE，锁的模式有三种：E，S，X。
   模式E：当更改数据的时候设置为此模式。   (Shared lock, read lock) 【一般使用E】
   模式S：本身不需更改数据，但是希望显示的数据不被别人更改 (Exclusive lock, write lock)
   模式X：和E类似，但是不允许累加，完全独占。 
          (Exclusive lock, extended write lock, cannot be cumulated)
  2、上锁的一般步骤
      先上锁，上锁成功之后，从数据库取数据，然后更改数据，接着更新到数据库，最后解锁。
   按照这个步骤，才能保证更改完全运行在锁的保护机制下。
  3、上锁与解锁
   ENQUEUE_&amp;lt;lock object的名字&amp;gt; 对象 EZZSOPR0032 要求的锁定
   DEQUEUE_&amp;lt;lock object的名字&amp;gt; 释放对象 EZZSOPR0032 的锁定
     有些情况下，程序中设置成功的逻辑锁会隐式的自己解锁。比如说程序结束发生的时候
  （MESSAGE TYPE为A或者X的时候），使用语句LEAVE PROGRAM，LEAVE TO TRANSACTION，或者在
   命令行输入/n回车以后。使用DEQUEUE FUNCTION MODULE来解锁的时候，不会产生EXCEPTION。
   要解开你在程序中创建的所有的逻辑锁，可以用FM：DEQUEUE_ALL.
【事务处理】
  COMMIT WORK.         异步更新。
  COMMIT WORK AND WAIT.同步跟新，执行结果可通过sy-subrc判断是否提交成功。
  ROLLBACK WORK.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;message-se91&#34;&gt;MESSAGE ：SE91&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;1&amp;gt; 消息类的操作
  使用T-CODE:SE91对Message定义，还能够对Message进行创建，修改及删除等维护操作。
  Message Short Text字段为类描述，可以定义输入参数&amp;amp;，如&amp;quot;1&amp;amp;2&amp;amp;3&amp;amp;&amp;quot;表示有三个输入参数。
  Message共分以下几种类型：E:错误、W:警告、I：信息、A：异常中止、S:成功。
  引用语法为: Message W000(00)，表示调用&#39;00&#39;类的&#39;000&#39; Message类型为警告。
    EX: Message W001(ZTEST) WITH &#39;P1&#39; &#39;P2&#39; &#39;P3&#39;.
1. 消息ID MESSAGE e001(00) WITH &#39;12345678&#39;. //利用定义的参数
2. MESSAGE &#39;XXXXXXXXXX&#39; TYPE &#39;X&#39;.          //直接附加消息
3. MESSAGE s001(00) WITH &#39;No data&#39; DISPLAY LIKE &#39;E&#39;.
   EXIT.                                   //Screen 界面查询数据无，则返回原界面
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;alv常使用的bapi&#34;&gt;ALV常使用的BAPI&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;在ALV开发中有两个重要的对象：LAYOUT和FIELDCAT,它们同属于类型池SLIS。
   LAYOUT主要用于设置ALV的输出格式，如输出字段的颜色、表格中的线条等；
   FIELDCAT主要用于ALV结构定义，包括具体字段的名称、类型、格式等属性.
常使用的开发类:
   &amp;lt;1&amp;gt; REUSE_ALV_FIENDCATALOG_MERGE：根据内表结构返回FIELDCAT字段结构信息.
   &amp;lt;2&amp;gt; REUSE_ALV_GRID_DISPLAY/REUSE_ALV_LIST_DISPLAY：输出ALV报表，定义其为GRID模式还是LIST模式。参数结构一样。
   &amp;lt;3&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;alv-报表的表头字段显示设置&#34;&gt;ALV 报表的表头字段显示设置&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;call function &#39;LVC_FIELDCATALOG_MERGE&#39;
exporting
  I_BUFFER_ACTIVE        = I_BUFFER_ACTIVE
  I_structure_name       = &#39;ZALV_FEED&#39; &amp;quot;ALV需要显示的字段结构
  I_CLIENT_NEVER_DISPLAY = &#39;X&#39;
  I_BYPASSING_BUFFER     = I_BYPASSING_BUFFER
  I_INTERNAL_TABNAME     = I_INTERNAL_TABNAME
    changing
      ct_fieldcat         = lt_fieldcat  &amp;quot;对应ALV显示的字段结构
exceptions
  inconsistent_interface = 1
  program_error          = 2.
 可以通过loop对相应的ALV字段描述进行自定义设置
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;layout-字段&#34;&gt;Layout 字段&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;DATA wa_alv_field TYPE SLIS_LAYOUT_ALV.
LAYOUT主要用于设置ALV的输出格式，如输出字段的颜色、表格中的线条等；
  0.COLTAB_fieldname type slis_fieldname: 设置单元格颜色
  1.EDIT：设置ALV是否为可编辑模式。
  2.COLWIDTH_OPTIMIZE：将ALV字段宽度设置为最优化，按实际输出内容宽度自动匹配。
  3.NO_VLINE：输出ALV表格不显示垂直格式。
  4.NO_ULINE_HS：输出ALV表格不显示水平格线。
  5.INFO_FIELDNAME：设置颜色属性。
  6.KEY_HOTSPOT：设置关键字段热点。
  7.NO_COLNAME：是否显示字段名。
  8.ZEBRA：使ALV表格按斑马线间隔条纹方式显示，以便显示效果更有美观。
  9.BOX_FIELDNAME：设置ALV表格是否显示选择按钮字段。
  10.f2code  like   sy-ucomn. gs_layout-f2code=&#39;&amp;amp;ETA&#39;[双击时触发的funcode]
  11.INFO_FIELDNAME：用于设置ALV输出报表每一行的颜色，其参数为输出内表的字段名称，
    要注意的是使用该属性需要同时在内表中定义一个与该参数所定义字段名相同的字段，例如：
  LAYOUT-INFO_FIELDNAME = &#39;COLOR&#39;.倘若其数据输出内表名为LT_OUT,则需要在该内表增加一字段
  “COLOR”，并为其内表每行复制，颜色参数范围C000~C999，例如：LT_OUT-COLOR = &#39;C012&#39;.

【颜色】
  行颜色:gs_layout-&amp;lt;info_fieldname&amp;gt; = &#39;COLOR&#39;
  列颜色:gt_fieldcat-emphasize = &#39;C510&#39;.[1：C固定，2：颜色值0~7,3：高亮0、1(X)，
                                         4：颜色反转，0、1]
  单元格颜色:gs_layout-&amp;lt;coltab_fieldname&amp;gt;=&#39;COLORTABLE&#39;.
【可编辑】
  整体可编辑：gs_layout-edit = &#39;X&#39; 
  某列可编辑：gt_fieldcat-edit = &#39;X&#39;
  单元格可编辑：
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;9-fieldcatalog-字段&#34;&gt;9.Fieldcatalog 字段&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;FIELDCAT主要用于ALV结构定义，包括具体字段的名称、类型、格式等属性.
  DATA lt_alv_fieldcat TYPE SLIS_T_FIELDCAT_ALV WITH HEADER LINE.
　　1.KEY：将定义字段设置为KEY值。
    2.ICON：将定义字段以ICON的形式显示。
    3.CHECKBOX：将定义字段以CHECKBOX的形式显示。
    4.JUST：定义字段对齐方式(R)RIGHT、(L)LEFT、(C)CENTER。
    5.IZERO：将定义字段以前导&amp;quot;0&amp;quot;的形式显示。
    6.NO_SIGN：将定义字段符号设置为不显示。
    7.NO_ZERO：定义字段是否显示。
    8.EMPHASIZE：设置字段的颜色。
    9.DO_SUM：对字段进行汇总。
    10.SELTEXT_L/M/S：设置字段名称描述长/中/短。
    11.DDICTXT：设置字段显示字符串。
    12.HOTSPOT：设置字段是否有热点(热点字段显示有下划线)。
    13.NO_OUT: 隐藏不需要的字段(NO_OUT = &#39;X&#39;)。
    14.EDIT(1) type c: 是否可编辑
    15:COL_POS like sy-cucol: 列输出位置
    16:FIX_COLUMN(1) type c: 列固定不滚动，颜色不会发生变化
    17:convexit : 设置转换规则，对应于Domain中的转换规则    

fieldname  type slis_fieldname    (列显示的设置)
cfieldname type slis_fieldname  (金额字段所参照的货币单位字段名)
ctabname   type slis_tabname      (金额字段所参照的货币单位表名)
qfieldname type slis_fieldname  (数量字段所参照的货币单位字段名)
qtabname   type slis_tabname      (数量字段所参照的货币单位表名)

自定义FIELDCAT字段结构：
  &amp;quot;定义宏来设置FIELDAT属性 &amp;amp;1 &amp;amp;2 &amp;amp;3分别为参数
    DEFINE fieldcatset.
      lt_alv_fieldcat-REF_TABNAME =&#39;LSPFLI&#39;.
      lt_alv_fieldcat-FIELDNAME = &amp;amp;1.
      lt_alv_fieldcat-SELTEXT_L = &amp;amp;2.
      lt_alv_fieldcat-COL_POS = &amp;amp;3.
      APPEND lt_alv_fieldcat.
    END-OF-DEFINITION.
    fieldcatset &#39;CARRID&#39; &#39;航线承运人&#39; SY-TABIX.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;10-单元格中的数据被修改后-将alv单元格中的数据立即刷新到abap对应的内表中&#34;&gt;10.单元格中的数据被修改后，将ALV单元格中的数据立即刷新到ABAP对应的内表中&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;方法一：通过对REUSE_ALV_GRID_DISPLAY函数参数i_grid_settings-edt_cll_cb进行设置：
i_grid_settings-edt_cll_cb  = &#39;X&#39; .
CALL FUNCTION &#39;REUSE_ALV_GRID_DISPLAY&#39;
EXPORTING i_grid_settings = i_grid_settings
方法二：通过函数参数I_CALLBACK_USER_COMMAND指定的回调Form的参数slis_selfield进行设置：
FORM user_command USING ucomm LIKE sy-ucommselfield selfield TYPE slis_selfield.
    selfield-refresh = &#39;X&#39;.
  CASE ucomm.
    WHEN &#39;UPDATE&#39;.
    PERFORM frm_update.
  ENDCASE.
ENDFORM. 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;11-自定义按钮使用后刷新alv&#34;&gt;11 自定义按钮使用后刷新ALV&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt; form frm_user_command using r_ucomm     like sy-ucomm
                        rs_selfield type slis_selfield.
  case r_ucomm.
   when &#39;PROFIT&#39;.
      perform frm_cycle_count_profit.
   when others.
  endcase.
     rs_selfield-refresh = &#39;X&#39;.
 endform.                    &amp;quot;frm_user_command
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;12-设置工具导航栏-gui-status&#34;&gt;12 设置工具导航栏 GUI Status&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;GUI Status参数设置共包括3个部分：
  1.菜单栏(Menu Bar)：用于设置主菜单选项。
  2.应用工具条(Application ToolBar)：用于设置应用工具栏按钮，包括按钮名称、按钮描述、及按钮所对的ICON图标。
  3.功能键(Function Key)：为按钮分配功能键代码，包括系统标题按钮(如返回、退出、关闭等)及通过Application ToolBar所定义的客制化按钮。
  4. 对于定义的按钮，我们可以通过系统变量SY-UCOMM来获取它的功能代码。
    AT USER-COMMAND.   &amp;quot;当单击某个按钮时，触发该事件
      CASE sy-ucomm.  &amp;quot;获取所操作按钮的功能代码(FUNCTION Code)
  5.调用显示，应用于START-OF-SELECTION事件
     SET PF-STATUS &amp;lt;STATUS_NAME&amp;gt;.
     不显示某些按钮：SET PF-STATUS &amp;lt;STATUS_NAME&amp;gt; EXCLUDING &amp;lt;extab&amp;gt;.
 6.在ALV函数中使用
  call function &#39;REUSE_ALV_GRID_DISPLAY_LVC&#39;
    exporting
      i_callback_program       = sy-repid 
      i_callback_pf_status_set = &#39;FRM_SET_STATUS&#39;
      i_callback_user_command  = &#39;FRM_USER_COMMAND&#39;
      is_layout_lvc            = lw_layout
      it_fieldcat_lvc          = gt_fieldcat
      i_default                = &#39;X&#39;
      i_save                   = &#39;X&#39;
   tables
      t_outtab                 = gt_alv_pi_diffs
   exceptions
      program_error            = 1.

  form frm_set_status using extab type slis_t_extab.
     data: ls_slis_extab type slis_extab.
      SET PF-STATUS &amp;lt;STATUS_NAME&amp;gt;.
  endform.                    &amp;quot;frm_set_status
GUI TITLE设置：
    GUI TITLE 用于定义Report标题栏内容.
  定义：
    Create--&amp;gt;GUI Titles：可以输入&amp;amp;符号作为Title,当程序运行时对其填充动态文本。
  在程序中调用：
    SET TITLEBAR &#39;TITLE_BAR&#39; WITH SY-DATUM &#39;IFENER&#39; &#39;BAR TEST&#39;.&amp;quot;设置TITLEBAR，并赋参数列表
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;13-oo-alv&#34;&gt;13. OO ALV&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;相关类：
  CL_GUI_CUSTOM_CONTAINER   ：用户自己定义控件区域
  CL_GUI_DOCKING_CONTAINER  : 动态创建容器，不需要在创建时绑定到预先绘制好的自定义控件中
  CL_GUI_SPLITTER_CONTAINER ：可在同一屏幕创建多个ALV显示
  CL_GUI_ALV_GRID           ：ALV控制类

  DATA : obj_wcl_container TYPE REF TO cl_gui_custom_container, &amp;quot;控制容器类
         obj_wcl_alv TYPE REF TO cl_gui_alv_grid . &amp;quot;ALV控制类
  DATA GS_LAYOUT1 TYPE LVC_S_LAYO. &amp;quot;布局结构
  DATA GT_FIELDCAT TYPE LVC_T_FCAT. &amp;quot;存放字段目录的内表
  DATA GS_FIELDCAT TYPE LVC_S_FCAT.
  DATA lt_exclude TYPE ui_functions. &amp;quot;alv不需要的图标按钮
1、控制区域、容器、Grid关系
   先在屏幕绘制一个用户自定义控件区域，然后以自定义区域为基础创建 CL_GUI_CUSTOM_CONTAINER
 容器实例,最后以此容器实例来创建 CL_GUI_ALV_GRID实例。
    DATA : obj_wcl_container TYPE REF TO cl_gui_custom_container, &amp;quot;控制容器类
           obj_wcl_alv TYPE REF TO cl_gui_alv_grid . &amp;quot;ALV控制类
    IF obj_wcl_alv IS INITIAL.
       CREATE OBJECT obj_wcl_container
          EXPORTING
             container_name  =  &#39;OBJ_WCL_CONTAINER&#39;.
       CREATE OBJECT obj_wcl_alv
          EXPORTING
             i_parent  = obj_wcl_container.
2、给ALV对象注册事件
  (1) HANDLE_TOOLBAR:这个事件用于给ALV加自定义工具条按钮。
  (2) HANDLE_CLICK:用于给ALV点击其中一行后处理代码段。
  (3) HANDLE_COMMAND:事件用于接收用户按了自定义按钮后，触发的代码段。
  (4) HANDLE_DOUBLE_CLICK：双击事件
  (5) 
  事件的使用：
    &amp;lt;1&amp;gt; 定义事件方法
    &amp;lt;2&amp;gt; 指定事件的执行方法代码
    &amp;lt;3&amp;gt; 事件变量实例化
    &amp;lt;4&amp;gt; 把事件指定到ALV控制中(注册事件)

    CREATE OBJECT event_receiver.
    SET HANDLER event_receiver -&amp;gt; handle_double_click FOR obj_wcl_alv.
3、CL_GUI_ALV_GRID重要方法
  *-----显示ALV 
     CALL METHOD obj_wcl_alv-&amp;gt;set_table_for_first_display 
        EXPORTING 
           is_variant                    = ls_variant   :指定布局变式
           is_layout                     = ls_layout 
           i_save                        = &#39;A&#39;          :保存表格布局
           it_toolbar_excluding          = lt_exclude 
        CHANGING 
           it_outtab                     = gt_list[]    :需要显示的内表数据
           it_fieldcatalog               = lt_fieldcat  :结构字段
        EXCEPTIONS 
           invalid_parameter_combination = 1 
           program_error                 = 2 
           too_many_lines                = 3 
           OTHERS                        = 4.

   ENDFORM.                    &amp;quot; FRM_ALV_DISPLAY

  XXX -&amp;gt; REFRESH_TABLE_DISPLAY.
    IS_STABLE : 刷新的稳定性，就是滚动条保持不动
    I_SOFT_REFRESH:  软刷新，临时给ALV创建的合计，排序，等保持不变
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;14-前导零问题&#34;&gt;14.前导零问题&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;加上p_in的前导零
  FORM add_zero  CHANGING p_in.
CALL FUNCTION &#39;CONVERSION_EXIT_ALPHA_INPUT&#39;
  EXPORTING
    input  = p_in
    IMPORTING
      output = p_in.
 ENDFORM.
去除p_out的前导零
  FORM del_zero CHANGING p_out.
    CALL FUNCTION &#39;CONVERSION_EXIT_ALPHA_OUTPUT&#39;
    EXPORTING
      input  = p_out
    IMPORTING
     output = p_out.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;15-hash-table-sort-table-standy-table&#34;&gt;15.Hash table, sort table, standy table&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;   对于排序内表，不要使用append，append lines附加数据，使用insert、insert lines向
排序内表中插入数据
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;16-search-help-的创建&#34;&gt;16.search help 的创建&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;PARAMETERS p_cur TYPE XXX VALUE CHECK .
PROCESS ON VALUE-REQUEST ， AT SELECTION-SCREEN ON VALUE-REQUEST。
在屏幕的 ON VALUE-REQUEST 事件里可以通过下面几个函数来创建搜索帮助：
  F4IF_ FIELD _VALUE_REQUEST ： 函数的作用是在运行时，可以动态的为某个屏幕字段指定 
     Search Help ，这个被引用的 Help 来自某个表（或结构）字段上绑定的 Help
  F4IF_ INT_TABLE _VALUE_REQUEST : 在程序运行时， 将某个内表动态的用作 Search help 的
     数据来源,即使用该函数可以将某个内表转换为 Search help ，可实现联动效果
  TR_F4_HELP ： 简单实现 Search Help ，数据来源于内表。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;17-sql-语句的执行顺序&#34;&gt;17. SQL 语句的执行顺序&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;书写顺序：SELECT[DISTINCT]--&amp;gt;FROM--&amp;gt;WHERE--&amp;gt;GROUP BY--&amp;gt;HAVING--&amp;gt;UNION--&amp;gt;ORDER BY
其执行顺序为：FROM--&amp;gt;WHERE--&amp;gt;GROUP BY--&amp;gt;HAVING--&amp;gt;SELECT--&amp;gt;DISTINCT--&amp;gt;UNION-&amp;gt;ORDER BY
1、FROM 才是 SQL 语句执行的第一步，并非 SELECT 
2、SELECT 是在大部分语句执行了之后才执行的，严格的说是在 FROM 和 GROUP BY 之后执行的。
3、无论在语法上还是在执行顺序上， UNION 总是排在在 ORDER BY 之前。
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;open-sql&#34;&gt;Open SQL&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;focus&#34;&gt;Focus&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;1. 多表的结合的查询，首先进行各自的关键字查询，然后进行表与表转换可以提升效率
2. 表相应字段非关键字时，寻找有该关键字的相对应的关联表进行查询并合并表数据
3. binary search 和 sort 进行使用时注意sort的关键字与binary search 保持统一
4. MODIFY itab1 INDEX sy-tabix.进行修改时最好定义变量记录sy-tabix.
5. inner join 和 left outer join 的连接条件最好都是关键字.
6. 双层loop循环时，第二个内部表定义为SORTED TABLE会大大的提高处理速度
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>报表开发(一)</title>
      <link>https://coldinfire.github.io/2018/ABAPTable1/</link>
      <pubDate>Sun, 26 Aug 2018 17:20:58 +0800</pubDate>
      
      <guid>https://coldinfire.github.io/2018/ABAPTable1/</guid>
      <description>

&lt;h2 id=&#34;执行程序的使用范围-报表事件&#34;&gt;执行程序的使用范围，报表事件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;LOAD-OF-PROGRAM.
INITIALIZATION.          （Before display the selection screen）
  AT-SELECTION SCREEN ON fiedl.（在PAI事件结束后执行，进行校验和检查输入值）
  AT SELECTION-SCREEN ON VALUE-REQUEST FOR Z_XXX.
AT SELECTION-SCREEN. //After enter the option data check
   PERFORM check_input.
START-OF-SELECTION.//Begin the main programer
  xxxx
END-OF-SELECTION.
Interactive Eventrs. (User for interactive reporting)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;报表程序大体逻辑结构&#34;&gt;报表程序大体逻辑结构&lt;/h2&gt;

&lt;p&gt;​   &lt;strong&gt;抬  头:&lt;/strong&gt; 报表的主要信息(抬头信息)&lt;/p&gt;

&lt;p&gt;​   &lt;strong&gt;行项目:&lt;/strong&gt; 查询出的每行记录信息&lt;/p&gt;

&lt;p&gt;​   &lt;strong&gt;明  细:&lt;/strong&gt; 每个行项目出关键字外其他明细内容&lt;/p&gt;

&lt;h2 id=&#34;字段符号&#34;&gt;字段符号&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt; FIELD-SYMBOLS &lt;FS&gt; LIKE structure.&lt;/p&gt;

&lt;p&gt;​    &lt;1&gt; FS必须和某个变量，结构或者内表绑定后才能使用，在使用FS前必须分配给某个变量，不然会发生FS未分配的运行时错误。如果LOOP内表时ASSIGNING到FS，之后假如有REFRESH内表的操作的话，FS也会再次回到初始未被ASSIGN的状态，这时如果使用FS也会发生FS未分配的RUNTIME ERROR。&lt;/p&gt;

&lt;p&gt;​   &lt;2&gt; &lt;code&gt;ASSIGN structure TO &amp;lt;fs&amp;gt;&lt;/code&gt;:将某个内存区域分配给字段符号，这样字段符号就代表了该内存区域，即该内存区域别名字段符号可以看作仅是已经被解引用的指针，即某个变量的别名。
  &lt;code&gt;ASSIGN &amp;lt;Val&amp;gt; TO &amp;lt;fs&amp;gt;&lt;/code&gt;: 将某个内存区域分配给字段符号，这样字段符号就代表了该内存区域。&lt;/p&gt;

&lt;p&gt;UNASSIGN: 该语句是初始化&lt;code&gt;&amp;lt;FS&amp;gt;&lt;/code&gt;字段符号，执行后字段符号将不再引用内存区域，&lt;code&gt;&amp;lt;fs&amp;gt; is assigned&lt;/code&gt;返回假。&lt;/p&gt;

&lt;p&gt;CLEAR: 与UNASSIGN不同的是，只有一个作用就是初始化它所指向的内存区域，而不是解除分配。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;循环：&lt;/strong&gt;LOOP内表INTO Structure和 LOOP内表ASSIGNING Structure的比较&lt;/p&gt;

&lt;p&gt;​    LOOP内表INTO结构时，系统会把先把当前行的数据复制到结构，如果结构的值改了，还需要使用
  MODIFY语句把更改后的值传回内表。也就是说，结构是内表里的数据的一个副本，操作这个副本不会
  影响内表里的数据。为了提高效率，可以使用FS，FS直接指向内表数据，省去了复制数据到结构的过程
  修改FS的值也就是相当于直接修改内表里的数据，不需要再使用MODIFY语句。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;读表：&lt;/strong&gt;READ TABLE内表&lt;/p&gt;

&lt;p&gt;ASSIGN隐式强转&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;TYPES: BEGIN OF t_date,
​    year(4) TYPE  n,
​        month(2) TYPE n,
​    day(2) TYPE n,
  END OF t_date.
FIELD-SYMBOLS &amp;lt;fs&amp;gt; TYPE t_date.&amp;quot;将&amp;lt;fs&amp;gt;定义成了具体限定类型
ASSIGN sy-datum TO &amp;lt;fs&amp;gt; CASTING. &amp;quot;后面没有指定具体类型，所以使用定义时的类型进行隐式转换
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ASSIGN显示强转&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;  DATA txt(8) TYPE c VALUE &#39;19980606&#39;.
  FIELD-SYMBOLS &amp;lt;fs&amp;gt;.
  ASSIGN txt TO &amp;lt;fs&amp;gt; CASTING TYPE d.&amp;quot;由于定义时未指定具体的类型，所以这里需要显示强转
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;动态引用：&lt;/strong&gt;通过循环赋值给定义的字段符号，对其进行修改，等于直接修改原内表。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;  field-symbols:&amp;lt;l_shortageqty&amp;gt; type mng01.
  loop at &amp;lt;dyn_table&amp;gt; assigning &amp;lt;dyn_wa&amp;gt;.
​    assign component &#39;SHORTAGEQTY&#39; of structure &amp;lt;dyn_wa&amp;gt; to &amp;lt;l_shortageqty&amp;gt;.
​    &amp;lt;l_shortageqty&amp;gt; = &amp;lt;l_shortageqty&amp;gt; - &amp;lt;l_fvalue&amp;gt;.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;message-se91&#34;&gt;MESSAGE ：SE91&lt;/h2&gt;

&lt;p&gt;&lt;1&gt; 消息类的操作&lt;/p&gt;

&lt;p&gt;​   使用T-CODE:SE91对Message定义，还能够对Message进行创建，修改及删除等维护操作。Message Short Text字段为类描述，可以定义输入参数&amp;amp;，如&amp;rdquo;1&amp;amp;2&amp;amp;3&amp;amp;&amp;ldquo;表示有三个输入参数。&lt;/p&gt;

&lt;p&gt;​   Message共分以下几种类型：E:错误、W:警告、I：信息、A：异常中止、S:成功。&lt;/p&gt;

&lt;p&gt;​   引用语法为：Message W000(00)，表示调用&amp;rsquo;00&amp;rsquo;类的&amp;rsquo;000&amp;rsquo; Message类型为警告。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;EX: Message W001(ZTEST) WITH &#39;P1&#39; &#39;P2&#39; &#39;P3&#39;.
	1. 消息ID MESSAGE e001(00) WITH &#39;12345678&#39;. //利用定义的参数
	2. MESSAGE &#39;XXXXXXXXXX&#39; TYPE &#39;X&#39;.          //直接附加消息
	3. MESSAGE s001(00) WITH &#39;No data&#39; DISPLAY LIKE &#39;E&#39;.
   	   EXIT.                                   //Screen 界面查询数据无，则返回原界面
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;search-help-的创建&#34;&gt;search help 的创建&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;PARAMETERS p_cur TYPE XXX VALUE CHECK .
PROCESS ON VALUE-REQUEST ， AT SELECTION-SCREEN ON VALUE-REQUEST。
在屏幕的 ON VALUE-REQUEST 事件里可以通过下面几个函数来创建搜索帮助：
  F4IF_ FIELD _VALUE_REQUEST ： 函数的作用是在运行时，可以动态的为某个屏幕字段指定 
     Search Help ，这个被引用的 Help 来自某个表（或结构）字段上绑定的 Help
  F4IF_ INT_TABLE _VALUE_REQUEST : 在程序运行时， 将某个内表动态的用作 Search help 的
     数据来源,即使用该函数可以将某个内表转换为 Search help ，可实现联动效果
  TR_F4_HELP ： 简单实现 Search Help ，数据来源于内表。
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ABAP 语法详解(五)</title>
      <link>https://coldinfire.github.io/2018/ABAP5/</link>
      <pubDate>Tue, 26 Jun 2018 17:20:58 +0800</pubDate>
      
      <guid>https://coldinfire.github.io/2018/ABAP5/</guid>
      <description>

&lt;h2 id=&#34;效率优化&#34;&gt;效率优化&lt;/h2&gt;

&lt;h3 id=&#34;数据库&#34;&gt;数据库&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;不要使用 SELECT * &amp;hellip;，选择需要的字段, SELECT * 既浪费CPU，还需占用大量的ABAP内存&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不要使用SELECT DISTINCT .，会绕过缓存，可使用 SORT BY + DELETE ADJACENT DUPLICATES&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;少用相关子查询，因为子查询对外层查询结果集中的每条记录都会执行一次&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;少用嵌套SELECT … ENDSELECT，可以使用联合查询或FOR ALL ENTRIES来替换,减少循环次数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果确定只查一条数据时，使用 SELECT SINGLE&amp;hellip; 或者是 SELECT &amp;hellip;UP TO 1 ROWS &amp;hellip;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;统计时，直接使用SQL聚合函数，而不是将数据读取出来后在程序里再进行统计&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用游标读取数据，这样省掉了将从数据库中的取记录放入内表的INTO语句这一过程开销&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;多使用inner join，必要时才使用left join&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;inner join获取数据时，尽量不要用太多的表关联，特别是大表关联，关联顺序为：小表-大表&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;where 条件里面多用索引、主键，顺序也要遵循小表-大表&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;inner join条件放置的位置应该按照 On、Where、Having的顺序放，因为SQL条件的的执行一般
是按这个顺序来执行的，将条件放在最开始执行，则可过滤掉大部数据；但要注意Left Outer
Join，是否可以将ON中的条件移动到Where从句则要考虑（如果真能放在Where从句中，则应该用
Inner Join，而非Left Outer Join，因为Where条件会过滤掉那些包括在右表中不存在的左表数据），因为此时条件放在
On后面与放在Where语句后面结果是不一样的（因为不管on中的条件是否为真，左表中在右边表不存在的数据也会被返回，
但如放在where条件中，则会对On产生的数据再次过滤的条件，会滤掉不满足条件的记录，包括左表在右表中找不到的记录，
这时已经没有left join的含义）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;要根据主键或索引字段查找数据，且WHERE从句中的条件字段需按INDEX字段顺序书写，且将索引字段条件靠前（左边），
检查条件组合字段是否是主键，或者是上在上面创建了索引，避免条件组合字段即不是主键又没有索引。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;SELECT语句WHERE条件，应该先将主键相关条件放在前面 然后按照比较符 = 、&amp;lt; 、&amp;gt;、 &amp;lt;&amp;gt; 、LIKE IN 的顺序排列&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用部分索引字段问题：如果一个索引是由多个字段组成的，只使用一部分关键字段来进行查询时，也是可以使用到索引，
 但使用时要注意要按照索引定义的顺序且取其前面部分。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;请根据索引字段进行ORDER BY，否则通过程序进行SORT BY。与其在数据库在通过非索引字段进行排序，不如在程序中用
 SORT BY语句进行排序，因为此情况下应用服务器上的执行速度要比数据库服务器快(应用服务器上采用的是内存排序)。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;避免在索引字段上使用：not、&amp;lt;&amp;gt;、!=、IS NULL、IS NOT NULL,可以用&amp;gt; 与 &amp;lt; 来替代避免使用 LIKE，但LIKE
 &amp;lsquo;销售组1000&amp;rsquo;和LIKE &amp;lsquo;销售组1000%&amp;lsquo;可以用到，而LIKE &amp;lsquo;%销售组1000&amp;rsquo;（百分号前置）则用不到索引不要使用OR来连接
 多个索引字段(但同一字段多个值之间可以使用OR)；对于同一索引字段，可以使用IN来替代OR：带有BETWEEN 的WHERE
 条件不能通过索引来搜索？也可使用IN代替。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在下面情况下使用FOR ALL ENTRIES IN:
在循环内表时Loop&amp;hellip;at itab时
join超过三个表会出现性能问题，当使用JOIN连接超过3个表时
表数据非常大时，使用JOIN会很慢，此时改用FOR ALL ENTRIES IN&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;避免使用以下语句，因为使用这些语句时，不能使用 Table Buffer：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;Aggregate expressions
Select distinct
Select … for update
Order by、group by、having从句
Joins，使用JOIN时，会绕过SAP缓存，可以使用FOR ALL ENTRIES来代替
WHERE从句中使用Sub queries（子查询）
WHERE从句中使用IS NULL条件
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用内表批量操作数据库，而不要使用工作区一条条操作,如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;SELECT ... INTO TABLE itab
INSERT dbtab FROM TABLE itab
DELETE dbtab FROM TABLE itab
UPDATE/MODIFY dbtab FROM TABLE itab
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;​&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;程序&#34;&gt;程序&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;READ TABLE &amp;hellip;WITH [TABLE] KEY&amp;hellip;BINARY SEARCH读取标准内表使用二分查找&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在循环（LOOP AT &amp;hellip;WHERE..）或查询（READ TABLE &amp;hellip;）某内表时，如果未使用索引（排序表、哈希表）或二分查找，
则在查询组合字段创建第二索引，查询时通过USE KEY或WITH [TABLE] KEY选项使用第二索引，这样在查询时会自动进行二分
查找或哈希找查在没有用二分查找的情况下，可在查询组合字段上创建第二索引（哈希或排序索引），则在读取或循环内表时会
自动使用二分查找或哈希查找算法&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查找时，优先考虑使用哈希表进行查找，再考虑使用排序表进行二分查找，因为哈希查找的时间复杂度为(O (1))，不会因
数据的增加而受到影响;而二分查找虽然比顺序搜索快很多，但随着数据的增加会慢下来，其时间复杂度为(O (log2n))；标准
内表的时间复杂度为O(n)。
注：如果只使用到部分关键字为搜索条件，哈希表则会全表扫描，此时应该使用二分找查&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;FOR ALL ENTRIES：需要判断内表是否为空，否则会查询出所有数据&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;LOOP AT itab&amp;hellip; ASSIGNING &amp;hellip;、READTABLE &amp;hellip;ASSIGNING &amp;hellip; 在循环或读取内表 时，使用字段符号来替换表工作
区，将数据分配给字段符号Field Symbols，减少数据来回传递&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;尽量避免嵌套循环，如必须时，将循环次数少的放在外层，次数多的放在内层，这样可以减少在不同循环层之间的频繁地
切换及内部循环次数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;条件语句中多使用短路与或，“与”连接时将为假的机率大的条件放在前面，“或”连接时将为真的机率大的条件放在前面&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;少使用递归算法，递归时会增加调用栈层次，降低了性能，可使用队列或栈来避免递归&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;尽量不要使用通用类型（如FIELD-SYMBOLS、及形式参数），使用具体限定类型；比较时尽量使用同一数据类型：
IF c = c.比IF i = c.快，原因是未发生类型转换&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不要使用混合类型进行计算与比较，除非有必须&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;尽量使用静态语句，少用动态编程，动态编辑虽然灵活，但性能有所下降&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在对字符进行操作进，尽量使用String代替C固定长度类型，如：concatenate[kənˈkatɪneɪt]语句对固定长度的C连接时
 会去扫描那些非空字符出来再进行连接，速度没有String快&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;READ/MODIFY TABLE时使用TRANSPORTING只读取或修改必要的字段&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;尽量避免使用MOVE-CORRESPONDING和 SELECT&amp;hellip;INTO CORRESPONDING FIELDS OF &lt;a href=&#34;SELECT时，查询几个字
 段就定义具有这几个字段的内表，而不是直接使用基于数据库表类型创建的内表，否则如果直接使用INTO TABLE语法检查
 时会警告，但结果是没有问题的&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;TABLE&lt;/a&gt;。
 CORRESPONDING语句在系统内部存在隐式操作: 逐个字段的检查元素名称匹配; 检查元素类型匹配;元素类型转换；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最好不要向排序内表中插入（INSERT &amp;hellip; INTO TABLE &amp;hellip;）数据，因为在插入时会进行排序，速度会随着数据量的增加
 而慢下来，所以最好只向标准内表或哈希表中插入数据&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将某个内表中的全部记录或部分记录追加到另一内表时，使用INSERT/APPEND LINES OF … 代替循环逐条追加；
 如果是全新赋值，直接对内表使用“=”进行赋值操作即可&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;调用类方法要快于Function：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Calling Methods of global Classes：&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;call method CL_PERFORMANCE_TEST=&amp;gt;M1.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Calling Function Modules：&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;call function &#39;FUNCTION1&#39;.&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过运行事务代码SLIN(或者直接通过SE38的菜单)，进行代码静态检查，根据SAP提供的反馈信息，优化代码&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过老式方式定义内表时，使用&lt;code&gt;OCCURS 0&lt;/code&gt;而非&lt;code&gt;OCCURS n&lt;/code&gt; ：重现
    lOCCURS n 代表初始化内表的空间大小为n（空间固定），当内表存储记录条数超出n时，系统将依靠页面文件存放
              超出部分的数据。 当系统内存资源十分紧缺的时候，我们可以使用OCCURS n的初始化方法，
               但是这样的效率稍微慢
    lOCCURS 0 代表初始化内表的空间大小为无限，当内表存储记录条数不断增加时， 内表所使用的内存空间不断扩大，
              直到系统无法分配为止。使用内存比使用页面交换更快一些， 但是要考虑系统的资源状态&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用完成后及时清空释放内表所占用的空间：FREE &lt;itab&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用CASE…WHEN语句代替 IF…ELSEIF…；使用WHILE…ENDWHILE 代替 DO…ENDDO&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;LOOP循环内表时加上Where条件减少CPU负荷，而不是在循环里通过IF语句来过滤数据&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>CSS格式与标准总结</title>
      <link>https://coldinfire.github.io/2018/CSS/</link>
      <pubDate>Tue, 26 Jun 2018 17:20:58 +0800</pubDate>
      
      <guid>https://coldinfire.github.io/2018/CSS/</guid>
      <description>

&lt;h2 id=&#34;css语法&#34;&gt;CSS语法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;使用双空格短缩进——只有这样才能保证代码能在所有渲染器中显示一致；&lt;/li&gt;
&lt;li&gt;当成组使用选择器时，每个选择器单独一行；&lt;/li&gt;
&lt;li&gt;一条声明的开大括号前留一空格；&lt;/li&gt;
&lt;li&gt;声明的关闭右括号请新起一行；&lt;/li&gt;
&lt;li&gt;每条引用声明冒号后留一个空格；&lt;/li&gt;
&lt;li&gt;每条声明有单独的一行，以便错误报告更精确；&lt;/li&gt;
&lt;li&gt;每条声明以分号结尾，最后一个可以没有，但这样容易出错；&lt;/li&gt;
&lt;li&gt;以逗号分隔属性值之间，要在逗号后面保留一个空格（例如： &lt;code&gt;box-shadow&lt;/code&gt;）；&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;rgb()&lt;/code&gt;、&lt;code&gt;rgba()&lt;/code&gt;、&lt;code&gt;hsl()&lt;/code&gt;、&lt;code&gt;hsla()&lt;/code&gt;以及&lt;code&gt;rect()&lt;/code&gt;属性值*中*逗号后不要加空格，这样能把多色彩值（逗号无空格）与多属性值的情况区分开来（逗号带空格）；&lt;/li&gt;
&lt;li&gt;省略掉属性值以及颜色参数的首位0（例如：用 &lt;code&gt;.5&lt;/code&gt; 代替 &lt;code&gt;0.5&lt;/code&gt; ，用 &lt;code&gt;-.5px&lt;/code&gt; 取代 &lt;code&gt;-0.5px&lt;/code&gt;）；&lt;/li&gt;
&lt;li&gt;十六进制值要用小写，像 &lt;code&gt;#fff&lt;/code&gt;这样，当一个文档中有很多的字母时，小写字母更容易分辨；&lt;/li&gt;
&lt;li&gt;如果可以的话，简化十六进制值的写法，如用 &lt;code&gt;#fff&lt;/code&gt; 代替 &lt;code&gt;#ffffff&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;在选择器中引用属性值，例如：&lt;code&gt;input[type=&amp;quot;text&amp;quot;]&lt;/code&gt;，&lt;a href=&#34;http://mathiasbynens.be/notes/unquoted-attribute-values#css&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;在某些情况下可选是否使用&lt;/a&gt;，这样做也能更好地统一代码；&lt;/li&gt;
&lt;li&gt;零值不需要添加单位，例如：用 &lt;code&gt;margin: 0;&lt;/code&gt; 代替 &lt;code&gt;margin: 0px;&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;声明顺序&#34;&gt;声明顺序&lt;/h3&gt;

&lt;p&gt;有关联的属性声明之间应该按照以下顺序组在一起：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;定位&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;盒模型&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;排字&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;视觉设计&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;其他杂项&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;定位摆在第一位，因为它能把元素从文档正常流中脱离出来，覆盖盒模型样式。而盒模型表示着组件的度量尺寸和摆放位置，因此排第二。排版和视觉都是属于元素内部的属性，不会影响到前两项，所以排为3、4。&lt;/p&gt;

&lt;h3 id=&#34;选择器&#34;&gt;选择器&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;为了更好的显示性能，请使用类名而非一般的元素标签；&lt;/li&gt;
&lt;li&gt;对于经常使用的组件，不要使用多个属性选择器，这样调用对浏览器性能有不小影响；&lt;/li&gt;
&lt;li&gt;尽可能保持简短，如果可以请限制在3个元素以内；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;只有&lt;/strong&gt;在不得已的情况下再回溯最近的父级元素（例如：类名无前缀时）；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;标签&#34;&gt;标签&lt;/h2&gt;

&lt;h2 id=&#34;引用css和javascript文件&#34;&gt;引用CSS和JavaScript文件&lt;/h2&gt;

&lt;p&gt;​   按照HTML5规范，一般来说，当CSS和JS文件被引用时，都会默认以 &lt;code&gt;text/css&lt;/code&gt;和 &lt;code&gt;text/javascript&lt;/code&gt; 的方式，没必要特意为其指定 &lt;code&gt;type&lt;/code&gt; 类型。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;&amp;lt;!-- 外部 CSS --&amp;gt;
&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;code-guide.css&amp;quot;&amp;gt;

&amp;lt;!-- 文档内CSS --&amp;gt;
&amp;lt;style&amp;gt;
/* ... */
&amp;lt;/style&amp;gt;

&amp;lt;!-- JavaScript --&amp;gt;
&amp;lt;script src=&amp;quot;code-guide.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;属性顺序&#34;&gt;属性顺序&lt;/h2&gt;

&lt;p&gt;HTML属性应按照特定的顺序排列，以方便代码查阅。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;class&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;id&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;data-*&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;src&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;href&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;title&lt;/code&gt;, &lt;code&gt;alt&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;role&lt;/code&gt;, &lt;code&gt;aria-*&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Class能让我们更好地重用组件，所以它打头阵；id则更加特定和专属，应尽量控制其使用（例如：内页书签）。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
